{
  "success": true,
  "data": {
    "id": 44413,
    "name": "<p>请说明 Go 的 context 底层实现、使用场景，以及它是否是并发安全的，并解释什么是并发安全</p>",
    "options": null,
    "answer": "<h3>1. Go 的 context 底层实现</h3>\n<p>Go 语言的 <code>context</code> 包提供了上下文机制，用于在不同的 Go 协程之间传递请求范围的数据、取消信号以及截止时间等。其核心是 <code>Context</code> 接口，定义如下：</p>\n<pre><code class=\"language-go\">type Context interface {\n    Deadline() (deadline time.Time, ok bool)\n    Done() &#x3C;-chan struct{}\n    Err() error\n    Value(key interface{}) interface{}\n}\n</code></pre>\n<ul>\n  <li><strong><code>Deadline</code> 方法</strong>：返回该上下文的截止时间，如果没有设置截止时间，<code>ok</code> 为 <code>false</code>。</li>\n  <li><strong><code>Done</code> 方法</strong>：返回一个只读的 <code>chan struct{}</code> 类型的通道，当上下文被取消或者超时，该通道会被关闭。</li>\n  <li><strong><code>Err</code> 方法</strong>：返回上下文被取消的原因。</li>\n  <li><strong><code>Value</code> 方法</strong>：用于获取上下文中存储的键值对数据。</li>\n</ul>\n<p><code>context</code> 包提供了几个基础的上下文实现：</p>\n<ul>\n  <li><strong><code>emptyCtx</code></strong>：是一个空的上下文，不包含任何值、截止时间，也不能被取消，<code>context.Background()</code> 和 <code>context.TODO()</code> 都返回 <code>emptyCtx</code> 类型的实例。</li>\n  <li><strong><code>cancelCtx</code></strong>：可以被取消的上下文，内部维护了一个 <code>done</code> 通道和一个 <code>children</code> 列表，当调用 <code>CancelFunc</code> 时，会关闭 <code>done</code> 通道，并递归取消所有子上下文。</li>\n  <li><strong><code>timerCtx</code></strong>：继承自 <code>cancelCtx</code>，增加了一个 <code>timer</code> 和 <code>deadline</code>，当到达截止时间时，会自动取消上下文。</li>\n  <li><strong><code>valueCtx</code></strong>：用于存储键值对数据，内部维护了一个 <code>key</code> 和 <code>val</code>，可以通过 <code>Value</code> 方法获取存储的值。</li>\n</ul>\n<h3>2. 使用场景</h3>\n<ul>\n  <li><strong>请求作用域数据传递</strong>：在处理 HTTP 请求时，可能需要在不同的处理函数之间传递一些请求相关的数据，如用户信息、请求 ID 等。可以将这些数据存储在上下文中，在不同的协程中使用。</li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n)\n\nfunc main() {\n    ctx := context.WithValue(context.Background(), \"user\", \"John\")\n    handleRequest(ctx)\n}\n\nfunc handleRequest(ctx context.Context) {\n    user := ctx.Value(\"user\")\n    fmt.Printf(\"User: %v\\n\", user)\n}\n</code></pre>\n<ul>\n  <li><strong>取消信号传递</strong>：当一个操作可以被取消时，如一个长时间运行的任务，可以使用上下文来传递取消信号。当某个条件满足时，取消上下文，所有依赖该上下文的操作都会收到取消信号并停止执行。</li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    ctx, cancel := context.WithCancel(context.Background())\n    go doWork(ctx)\n\n    // 模拟一段时间后取消任务\n    time.Sleep(2 * time.Second)\n    cancel()\n    time.Sleep(1 * time.Second)\n}\n\nfunc doWork(ctx context.Context) {\n    for {\n        select {\n        case &#x3C;-ctx.Done():\n            fmt.Println(\"Task cancelled\")\n            return\n        default:\n            fmt.Println(\"Working...\")\n            time.Sleep(500 * time.Millisecond)\n        }\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>超时控制</strong>：对于一些需要在一定时间内完成的操作，可以使用 <code>context.WithTimeout</code> 或 <code>context.WithDeadline</code> 来设置超时时间。当超过指定时间后，上下文会自动取消。</li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n    defer cancel()\n\n    go doWork(ctx)\n\n    time.Sleep(3 * time.Second)\n}\n\nfunc doWork(ctx context.Context) {\n    select {\n    case &#x3C;-ctx.Done():\n        fmt.Println(\"Task cancelled due to timeout\")\n    case &#x3C;-time.After(3 * time.Second):\n        fmt.Println(\"Task completed\")\n    }\n}\n</code></pre>\n<h3>3. 并发安全</h3>\n<p><code>context</code> 是并发安全的。并发安全是指在多个协程同时访问某个资源时，不会出现数据竞争、不一致等问题，程序的行为是可预测的。</p>\n<p><code>context</code> 包的设计保证了在多个协程中同时使用上下文是安全的。例如，多个协程可以同时调用 <code>ctx.Done()</code> 方法来监听上下文的取消信号，不会出现数据竞争的问题。同时，<code>context.WithValue</code> 方法返回的是一个新的上下文实例，不会影响原有的上下文，因此在多个协程中使用 <code>WithValue</code> 方法也是安全的。</p>\n<p>综上所述，Go 的 <code>context</code> 是一个强大且并发安全的工具，在处理并发编程中的请求范围数据传递、取消信号传递和超时控制等方面非常有用。</p>",
    "type": 6,
    "level": 3,
    "freq": 0.03327787,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：说明Go的context底层实现、使用场景，判断其是否并发安全并解释并发安全。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Go的context底层实现原理的掌握。</li>\n      <li>了解context的常见使用场景。</li>\n      <li>理解并发安全的概念。</li>\n      <li>判断context是否并发安全并给出合理依据。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）并发编程基础</h4>\n<p>在Go语言中，goroutine是轻量级的线程，多个goroutine可以并发执行。并发编程中会面临数据竞争等问题，需要保证程序的正确性和稳定性。</p>\n<h4>（2）context的引入</h4>\n<p>在复杂的程序中，需要对多个goroutine进行统一的控制，如取消操作、设置截止时间等，context就是为解决这些问题而设计的。</p>\n<h3>3. 解析</h3>\n<h4>（1）底层实现</h4>\n<p>Go的context是一个接口，定义如下：</p>\n<pre><code class=\"language-go\">type Context interface {\n    Deadline() (deadline time.Time, ok bool)\n    Done() &#x3C;-chan struct{}\n    Err() error\n    Value(key interface{}) interface{}\n}\n</code></pre>\n<ul>\n  <li><strong>Deadline</strong>：返回该context的截止时间。</li>\n  <li><strong>Done</strong>：返回一个只读的channel，当context被取消或超时，该channel会被关闭。</li>\n  <li><strong>Err</strong>：返回context被取消的原因。</li>\n  <li><strong>Value</strong>：返回与key关联的值。</li>\n</ul>\n<p>常见的context实现有<code>emptyCtx</code>、<code>cancelCtx</code>、<code>timerCtx</code>和<code>valueCtx</code>：</p>\n<ul>\n  <li><code>emptyCtx</code>：是一个空的context，不具备取消和超时功能，通常作为根context。</li>\n  <li><code>cancelCtx</code>：可以被取消，当调用<code>CancelFunc</code>时，会关闭<code>Done</code> channel，并通知所有子context。</li>\n  <li><code>timerCtx</code>：继承自<code>cancelCtx</code>，增加了超时功能，当到达截止时间时会自动取消。</li>\n  <li><code>valueCtx</code>：用于存储键值对，可在不同的goroutine之间传递数据。</li>\n</ul>\n<h4>（2）使用场景</h4>\n<ul>\n  <li><strong>取消操作</strong>：在多个goroutine协作的场景中，当某个条件满足时，需要取消所有相关的goroutine。例如，在一个HTTP请求处理中，如果客户端取消了请求，服务器可以通过context取消所有相关的操作。</li>\n  <li><strong>超时控制</strong>：为操作设置一个截止时间，当超过这个时间时，自动取消操作。比如数据库查询、网络请求等操作，避免长时间阻塞。</li>\n  <li><strong>传递请求范围的数据</strong>：在不同的函数调用和goroutine之间传递请求相关的数据，如用户ID、请求ID等。</li>\n</ul>\n<h4>（3）并发安全</h4>\n<p>Go的context是并发安全的。这是因为context的实现保证了在多个goroutine同时访问时不会出现数据竞争等问题。具体来说：</p>\n<ul>\n  <li><code>Done</code> channel是只读的，多个goroutine可以同时监听该channel，不会出现数据竞争。</li>\n  <li><code>CancelFunc</code>是线程安全的，多个goroutine可以同时调用<code>CancelFunc</code>，不会导致数据不一致。</li>\n  <li><code>Value</code>方法在存储和获取数据时，使用了互斥锁来保证并发安全。</li>\n</ul>\n<h4>（4）并发安全的定义</h4>\n<p>并发安全是指在多线程或多goroutine环境下，对共享资源的访问不会导致数据竞争、不一致或其他未定义行为。当多个并发单元（如goroutine）同时访问一个对象或资源时，如果该对象或资源的实现能够保证在任何情况下都能正确处理这些并发访问，那么就称该对象或资源是并发安全的。</p>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc worker(ctx context.Context) {\n    for {\n        select {\n        case &#x3C;-ctx.Done():\n            fmt.Println(\"worker: cancelled\")\n            return\n        default:\n            fmt.Println(\"worker: working...\")\n            time.Sleep(1 * time.Second)\n        }\n    }\n}\n\nfunc main() {\n    ctx, cancel := context.WithCancel(context.Background())\n    go worker(ctx)\n\n    time.Sleep(3 * time.Second)\n    cancel()\n    time.Sleep(1 * time.Second)\n}\n</code></pre>\n<p>在这个例子中，<code>context.WithCancel</code>创建了一个可取消的context，<code>worker</code> goroutine监听<code>ctx.Done()</code> channel，当调用<code>cancel()</code>时，<code>worker</code> goroutine会收到通知并退出。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）错误使用context</h4>\n<p>\n  误区：在不需要取消或超时控制的场景中使用context，增加了代码的复杂性。\n  纠正：根据实际需求合理使用context，避免不必要的使用。\n</p>\n<h4>（2）误解并发安全</h4>\n<p>\n  误区：认为只要使用了context就可以解决所有并发问题。\n  纠正：context只是用于控制和传递信息，对于其他共享资源的并发访问，还需要使用锁等机制来保证并发安全。\n</p>\n<h3>6. 总结回答</h3>\n<p>Go的context是一个接口，常见实现有<code>emptyCtx</code>、<code>cancelCtx</code>、<code>timerCtx</code>和<code>valueCtx</code>。它主要用于取消操作、超时控制和传递请求范围的数据。</p>\n<p>context是并发安全的，其<code>Done</code> channel只读，<code>CancelFunc</code>线程安全，<code>Value</code>方法使用互斥锁保证并发访问。</p>\n<p>并发安全指在多线程或多goroutine环境下，对共享资源的访问不会导致数据竞争、不一致或其他未定义行为。在使用context时，要根据实际需求合理使用，同时对于其他共享资源的并发访问，还需使用锁等机制保证安全。</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      <strong>context 超时机制的底层原理是什么</strong>\n      提示：思考 Go 语言中如何实现时间控制，结合 context 结构体里与时间相关的字段。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在多层嵌套的 context 中，子 context 的取消操作会对父 context 有什么影响</strong>\n      提示：分析 context 父子关系的特性，以及取消信号的传递方向。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如何在 context 中传递自定义的数据，有什么注意事项</strong>\n      提示：考虑 context 提供的存储数据的方法，思考数据类型、生命周期等方面。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>当多个 goroutine 同时监听同一个 context 的取消信号时，会出现什么情况</strong>\n      提示：结合并发编程的知识，分析多个 goroutine 对同一信号的响应机制。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>context 的 WithValue 方法存储的数据是线程安全的吗，为什么</strong>\n      提示：分析 WithValue 存储数据的结构和操作方式，判断是否存在并发访问问题。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在使用 context 进行请求链路追踪时，如何确保数据的完整性</strong>\n      提示：思考请求链路中数据传递的过程，以及可能出现的数据丢失或错误情况。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如果 context 没有正确取消，会导致什么后果</strong>\n      提示：从资源占用、程序逻辑等方面分析未取消 context 的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如何优化 context 在高并发场景下的性能</strong>\n      提示：考虑 context 的创建、传递和取消操作，分析高并发时的性能瓶颈。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Go的context))\n    底层实现\n      Context接口\n        Deadline方法\n        Done方法\n        Err方法\n        Value方法\n      基础上下文实现\n        emptyCtx\n        cancelCtx\n        timerCtx\n        valueCtx\n    使用场景\n      请求作用域数据传递\n      取消信号传递\n      超时控制\n    并发安全\n      设计保证多协程使用安全\n      多协程调用方法无数据竞争\n      WithValue返回新实例不影响原上下文",
    "keynote": "Go context底层实现：\n- Context接口：Deadline、Done、Err、Value方法\n- 基础实现：emptyCtx、cancelCtx、timerCtx、valueCtx\n\n使用场景：\n- 请求作用域数据传递\n- 取消信号传递\n- 超时控制\n\n并发安全：\n- 多协程使用安全\n- 调用方法无数据竞争\n- WithValue返回新实例",
    "group_id": 23,
    "kps": [
      "并发编程",
      "标准库"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "读书郎",
      "明智慧远",
      "字节跳动",
      "百度",
      "58同城",
      "腾讯",
      "京东",
      "滴滴",
      "杭州默安",
      "美图"
    ]
  }
}