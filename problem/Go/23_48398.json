{
  "success": true,
  "data": {
    "id": 48398,
    "name": "<p>context有几种类型</p>",
    "options": null,
    "answer": "<p>在Go语言里，<code>context</code> 主要有以下几种类型：</p>\n<h3>空上下文（Empty Context）</h3>\n<ul>\n  <li><code>context.Background()</code>：这是最基础的上下文，通常作为根上下文使用。它不能被取消，没有截止时间，也没有携带任何值。一般在主函数、初始化和测试等场景中作为上下文树的根节点。</li>\n  <li><code>context.TODO()</code>：同样是一个空上下文，当你还不确定使用什么上下文，或者函数需要一个上下文参数但当前还无法提供合适的上下文时使用。它和 <code>context.Background()</code> 功能类似，只是语义上表示这是一个待处理的上下文。</li>\n</ul>\n<h3>可取消上下文（Cancelable Context）</h3>\n<ul>\n  <li>\n    <code>context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code>：基于父上下文创建一个可取消的子上下文。调用返回的 <code>cancel</code> 函数可以取消该上下文及其所有子上下文，同时会向该上下文关联的 <code>Done</code> 通道发送信号，通知所有监听该通道的 goroutine 停止操作。\n    示例代码：\n  </li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc worker(ctx context.Context) {\n    for {\n        select {\n        case &#x3C;-ctx.Done():\n            fmt.Println(\"Worker stopped:\", ctx.Err())\n            return\n        default:\n            fmt.Println(\"Worker is working...\")\n            time.Sleep(1 * time.Second)\n        }\n    }\n}\n\nfunc main() {\n    ctx, cancel := context.WithCancel(context.Background())\n    go worker(ctx)\n\n    time.Sleep(3 * time.Second)\n    cancel()\n    time.Sleep(1 * time.Second)\n}\n</code></pre>\n<h3>超时上下文（Timeout Context）</h3>\n<ul>\n  <li>\n    <code>context.WithTimeout(parent Context, timeout time.Duration) (ctx Context, cancel CancelFunc)</code>：创建一个带有超时时间的上下文。当超过指定的 <code>timeout</code> 时间后，上下文会自动取消。它本质上是 <code>context.WithDeadline</code> 的便捷封装。\n    示例代码：\n  </li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc task(ctx context.Context) {\n    select {\n    case &#x3C;-ctx.Done():\n        fmt.Println(\"Task cancelled:\", ctx.Err())\n    case &#x3C;-time.After(2 * time.Second):\n        fmt.Println(\"Task completed\")\n    }\n}\n\nfunc main() {\n    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n    defer cancel()\n\n    task(ctx)\n}\n</code></pre>\n<h3>截止时间上下文（Deadline Context）</h3>\n<ul>\n  <li>\n    <code>context.WithDeadline(parent Context, deadline time.Time) (ctx Context, cancel CancelFunc)</code>：创建一个带有截止时间的上下文。当到达指定的 <code>deadline</code> 时间时，上下文会自动取消。\n    示例代码：\n  </li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc doWork(ctx context.Context) {\n    select {\n    case &#x3C;-ctx.Done():\n        fmt.Println(\"Work cancelled:\", ctx.Err())\n    case &#x3C;-time.After(3 * time.Second):\n        fmt.Println(\"Work completed\")\n    }\n}\n\nfunc main() {\n    deadline := time.Now().Add(1 * time.Second)\n    ctx, cancel := context.WithDeadline(context.Background(), deadline)\n    defer cancel()\n\n    doWork(ctx)\n}\n</code></pre>\n<h3>值上下文（Value Context）</h3>\n<ul>\n  <li>\n    <code>context.WithValue(parent Context, key, val interface{}) Context</code>：创建一个携带键值对的上下文。可以通过 <code>ctx.Value(key)</code> 方法获取存储在上下文中的值。需要注意的是，<code>key</code> 应该是自定义类型，以避免不同包之间的键冲突。\n    示例代码：\n  </li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n)\n\ntype userKey string\n\nfunc printUser(ctx context.Context) {\n    user, ok := ctx.Value(userKey(\"user\")).(string)\n    if ok {\n        fmt.Println(\"User:\", user)\n    } else {\n        fmt.Println(\"User not found in context\")\n    }\n}\n\nfunc main() {\n    ctx := context.WithValue(context.Background(), userKey(\"user\"), \"Alice\")\n    printUser(ctx)\n}\n</code></pre>",
    "type": 6,
    "level": 2,
    "freq": 0.006655574,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Go语言中context有几种类型。</li>\n  <li><strong>考察点</strong>：对Go语言标准库中context包的了解，不同类型context的特点和用途。</li>\n</ul>\n<h3>2. 背景知识</h3>\n<p>在Go语言里，context包用于在多个Go协程之间传递请求作用域的数据、取消信号以及截止时间等。它在处理请求、控制并发等场景中非常重要。</p>\n<h3>3. 解析</h3>\n<p>Go语言的context包中主要有以下几种类型的context：</p>\n<h4>（1）空上下文（emptyCtx）</h4>\n<ul>\n  <li>这是最基础的上下文类型，它不包含任何值、取消信号和截止时间。</li>\n  <li>通常作为根上下文使用，通过<code>context.Background()</code>或<code>context.TODO()</code>函数创建。</li>\n  <li><code>context.Background()</code>一般用于主函数、初始化和测试中，作为顶层上下文；<code>context.TODO()</code>则用于不确定使用哪个上下文时的占位。</li>\n</ul>\n<h4>（2）可取消上下文（cancelCtx）</h4>\n<ul>\n  <li>可以通过调用<code>context.WithCancel(parent)</code>函数创建。</li>\n  <li>它包含一个取消函数<code>CancelFunc</code>，调用该函数会向所有基于此上下文派生的子上下文发送取消信号，同时释放相关资源。</li>\n  <li>常用于需要手动取消操作的场景，比如当用户主动取消一个请求时。</li>\n</ul>\n<h4>（3）超时上下文（timerCtx）</h4>\n<ul>\n  <li>通过<code>context.WithTimeout(parent, timeout)</code>或<code>context.WithDeadline(parent, deadline)</code>函数创建。</li>\n  <li><code>context.WithTimeout</code>指定一个相对时间，<code>context.WithDeadline</code>指定一个绝对时间。</li>\n  <li>当到达指定时间时，会自动触发取消信号，释放相关资源。适用于有时间限制的操作，如网络请求设置超时时间。</li>\n</ul>\n<h4>（4）值上下文（valueCtx）</h4>\n<ul>\n  <li>由<code>context.WithValue(parent, key, val)</code>函数创建。</li>\n  <li>用于在上下文链中传递键值对数据，这些数据可以在不同的Go协程之间共享。</li>\n  <li>注意，键的类型应该是自定义类型，避免与其他包使用的键冲突。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    // 空上下文\n    backgroundCtx := context.Background()\n    todoCtx := context.TODO()\n\n    // 可取消上下文\n    cancelCtx, cancel := context.WithCancel(backgroundCtx)\n    go func() {\n        time.Sleep(2 * time.Second)\n        cancel()\n    }()\n    select {\n    case &#x3C;-cancelCtx.Done():\n        fmt.Println(\"Cancel context is cancelled:\", cancelCtx.Err())\n    }\n\n    // 超时上下文\n    timeoutCtx, _ := context.WithTimeout(backgroundCtx, 3*time.Second)\n    select {\n    case &#x3C;-timeoutCtx.Done():\n        fmt.Println(\"Timeout context is cancelled:\", timeoutCtx.Err())\n    }\n\n    // 值上下文\n    valueCtx := context.WithValue(backgroundCtx, \"key\", \"value\")\n    fmt.Println(\"Value from context:\", valueCtx.Value(\"key\"))\n}\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆不同类型上下文的用途</h4>\n<ul>\n  <li>误区：不清楚在什么场景下使用哪种上下文类型。</li>\n  <li>纠正：理解每种上下文的特点，根据具体需求选择合适的上下文类型，如需要手动取消用可取消上下文，有时间限制用超时上下文，传递数据用值上下文。</li>\n</ul>\n<h4>（2）未正确处理取消信号</h4>\n<ul>\n  <li>误区：创建了可取消或超时上下文，但没有在合适的地方处理取消信号。</li>\n  <li>纠正：在使用可取消或超时上下文时，要通过<code>select</code>语句监听<code>ctx.Done()</code>通道，及时处理取消信号。</li>\n</ul>\n<h4>（3）滥用值上下文</h4>\n<ul>\n  <li>误区：在值上下文中存储大量数据或频繁修改数据。</li>\n  <li>纠正：值上下文主要用于传递少量关键数据，不适合存储大量数据或频繁修改，避免影响性能和代码的可维护性。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“在Go语言中，context主要有四种类型：</p>\n<ul>\n  <li>空上下文：通过<code>context.Background()</code>或<code>context.TODO()</code>创建，作为根上下文，不包含任何值、取消信号和截止时间。</li>\n  <li>可取消上下文：使用<code>context.WithCancel(parent)</code>创建，可手动调用取消函数发送取消信号。</li>\n  <li>超时上下文：通过<code>context.WithTimeout(parent, timeout)</code>或<code>context.WithDeadline(parent, deadline)</code>创建，到达指定时间会自动触发取消信号。</li>\n  <li>值上下文：由<code>context.WithValue(parent, key, val)</code>创建，用于在上下文链中传递键值对数据。</li>\n</ul>\n<p>在实际使用中，应根据具体场景选择合适的上下文类型，并正确处理取消信号和数据传递。”</p>",
    "more_ask": "<ol>\n  <li>\n    <p><strong>context 类型在并发场景中的使用差异</strong></p>\n    <ul>\n      <li>提示：思考不同类型的 context 在多个 goroutine 并发执行时，对取消信号传递、超时控制等方面的表现有何不同。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何在嵌套 context 中正确传递和使用值</strong></p>\n    <ul>\n      <li>提示：考虑多层嵌套的 context 结构，值在不同层级 context 中的设置、获取以及传递规则。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>使用 WithTimeout 和 WithDeadline 的注意事项</strong></p>\n    <ul>\n      <li>提示：从资源释放、性能影响、异常处理等角度思考使用这两种类型 context 时需要留意的地方。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>context 类型对资源管理的影响</strong></p>\n    <ul>\n      <li>提示：分析不同类型的 context 如何影响文件句柄、网络连接等资源的生命周期管理。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在微服务架构中 context 类型的选择和应用</strong></p>\n    <ul>\n      <li>提示：结合微服务之间的调用关系、请求链路追踪、服务熔断等场景，思考不同 context 类型的适用性。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何自定义 context 类型</strong></p>\n    <ul>\n      <li>提示：了解 context 接口的定义，思考如何实现自定义的 context 以满足特定的业务需求。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>context 类型在错误处理中的作用</strong></p>\n    <ul>\n      <li>提示：考虑不同类型的 context 取消或超时后，如何将错误信息正确传递和处理。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>WithCancel 类型 context 多次调用 cancel 函数会怎样</strong></p>\n    <ul>\n      <li>提示：从 context 的状态变化、资源释放、后续操作的影响等方面进行思考。</li>\n    </ul>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Go语言context类型))\n    空上下文（Empty Context）\n      context.Background()\n      context.TODO()\n    可取消上下文（Cancelable Context）\n      context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)\n    超时上下文（Timeout Context）\n      context.WithTimeout(parent Context, timeout time.Duration) (ctx Context, cancel CancelFunc)\n    截止时间上下文（Deadline Context）\n      context.WithDeadline(parent Context, deadline time.Time) (ctx Context, cancel CancelFunc)\n    值上下文（Value Context）\n      context.WithValue(parent Context, key, val interface{}) Context",
    "keynote": "空上下文：\n- context.Background()：基础根上下文，不可取消，无截止时间和携带值，用于主函数等场景\n- context.TODO()：不确定用什么上下文时使用，语义上待处理\n\n可取消上下文：\n- context.WithCancel：基于父上下文创建可取消子上下文，调用cancel函数取消并通知goroutine\n\n超时上下文：\n- context.WithTimeout：创建带超时时间上下文，超时时自动取消\n\n截止时间上下文：\n- context.WithDeadline：创建带截止时间上下文，到达时间自动取消\n\n值上下文：\n- context.WithValue：创建携带键值对上下文，用ctx.Value(key)获取值，key用自定义类型避免冲突",
    "group_id": 23,
    "kps": [
      "标准库"
    ],
    "years": [
      2024,
      2023,
      2022
    ],
    "corps": [
      "居学科技",
      "CVTE视源股份",
      "B站",
      "百度"
    ]
  }
}