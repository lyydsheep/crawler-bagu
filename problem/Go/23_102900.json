{
  "success": true,
  "data": {
    "id": 102900,
    "name": "<p>Go语言里的Context是什么？如何利用Context进行协程并发控制？</p>",
    "options": null,
    "answer": "<h3>Go语言里的Context是什么</h3>\n<p>在Go语言中，<code>context</code> 包提供了 <code>Context</code> 类型，用于在多个 <code>goroutine</code> 之间传递请求作用域的数据、取消信号以及截止时间等信息。它是Go语言标准库中用于处理并发控制和请求作用域数据传递的重要工具，在处理网络请求、数据库查询等场景中非常有用。</p>\n<p><code>Context</code> 是一个接口，定义如下：</p>\n<pre><code class=\"language-go\">type Context interface {\n    Deadline() (deadline time.Time, ok bool)\n    Done() &#x3C;-chan struct{}\n    Err() error\n    Value(key interface{}) interface{}\n}\n</code></pre>\n<ul>\n  <li><code>Deadline()</code>：返回该 <code>Context</code> 的截止时间，如果没有设置截止时间，<code>ok</code> 为 <code>false</code>。</li>\n  <li><code>Done()</code>：返回一个只读的 <code>channel</code>，当 <code>Context</code> 被取消或者超时的时候，该 <code>channel</code> 会被关闭。</li>\n  <li><code>Err()</code>：返回 <code>Context</code> 被取消的原因。</li>\n  <li><code>Value(key interface{})</code>：返回该 <code>Context</code> 中与 <code>key</code> 关联的值，如果没有则返回 <code>nil</code>。</li>\n</ul>\n<h3>如何利用Context进行协程并发控制</h3>\n<h4>1. 取消信号传递</h4>\n<p>可以使用 <code>context.WithCancel</code> 函数创建一个可取消的 <code>Context</code>，当调用 <code>cancel</code> 函数时，会向所有监听该 <code>Context</code> 的 <code>goroutine</code> 发送取消信号。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc worker(ctx context.Context) {\n    for {\n        select {\n        case &#x3C;-ctx.Done():\n            fmt.Println(\"Worker is cancelled\")\n            return\n        default:\n            fmt.Println(\"Worker is working...\")\n            time.Sleep(1 * time.Second)\n        }\n    }\n}\n\nfunc main() {\n    ctx, cancel := context.WithCancel(context.Background())\n\n    go worker(ctx)\n\n    // 模拟一段时间后取消\n    time.Sleep(3 * time.Second)\n    cancel()\n\n    // 等待一段时间，确保 worker 协程输出取消信息\n    time.Sleep(1 * time.Second)\n}\n</code></pre>\n<p>在上述代码中，<code>context.WithCancel</code> 创建了一个可取消的 <code>Context</code>，并返回 <code>ctx</code> 和 <code>cancel</code> 函数。在 <code>worker</code> 协程中，通过 <code>select</code> 语句监听 <code>ctx.Done()</code> 通道，当 <code>cancel</code> 函数被调用时，<code>ctx.Done()</code> 通道会被关闭，<code>worker</code> 协程会收到取消信号并退出。</p>\n<h4>2. 超时控制</h4>\n<p>使用 <code>context.WithTimeout</code> 或 <code>context.WithDeadline</code> 可以设置 <code>Context</code> 的超时时间，当超过指定时间后，<code>Context</code> 会自动取消。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc longRunningTask(ctx context.Context) {\n    select {\n    case &#x3C;-time.After(5 * time.Second):\n        fmt.Println(\"Task completed\")\n    case &#x3C;-ctx.Done():\n        fmt.Println(\"Task cancelled due to timeout:\", ctx.Err())\n    }\n}\n\nfunc main() {\n    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n    defer cancel()\n\n    go longRunningTask(ctx)\n\n    // 等待一段时间，确保任务有足够时间执行\n    time.Sleep(6 * time.Second)\n}\n</code></pre>\n<p>在这个例子中，<code>context.WithTimeout</code> 创建了一个带有超时时间的 <code>Context</code>，超时时间为 3 秒。在 <code>longRunningTask</code> 函数中，使用 <code>select</code> 语句监听 <code>ctx.Done()</code> 通道和 <code>time.After</code> 通道，当超时时间到达时，<code>ctx.Done()</code> 通道会被关闭，任务会收到取消信号并退出。</p>\n<h4>3. 传递请求作用域的数据</h4>\n<p>使用 <code>context.WithValue</code> 可以在 <code>Context</code> 中存储和传递请求作用域的数据。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n)\n\nfunc worker(ctx context.Context) {\n    userID, ok := ctx.Value(\"userID\").(string)\n    if ok {\n        fmt.Println(\"Received user ID:\", userID)\n    } else {\n        fmt.Println(\"No user ID found in context\")\n    }\n}\n\nfunc main() {\n    ctx := context.WithValue(context.Background(), \"userID\", \"123\")\n    go worker(ctx)\n\n    // 等待一段时间，确保 worker 协程有足够时间执行\n    fmt.Scanln()\n}\n</code></pre>\n<p>在这个例子中，<code>context.WithValue</code> 创建了一个带有 <code>userID</code> 的 <code>Context</code>，并将其传递给 <code>worker</code> 协程。在 <code>worker</code> 协程中，通过 <code>ctx.Value</code> 方法获取存储在 <code>Context</code> 中的 <code>userID</code>。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.001663893,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Go语言里的Context是什么，以及如何利用Context进行协程并发控制。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Go语言中Context概念的理解。</li>\n      <li>掌握Context的作用和应用场景。</li>\n      <li>了解如何使用Context进行协程并发控制。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）协程并发问题</h4>\n<p>在Go语言中，协程（goroutine）是轻量级的线程，多个协程可以并发执行。但在并发编程中，会面临一些问题，如需要控制协程的生命周期、传递请求范围的数据、超时控制等。</p>\n<h4>（2）Context的引入</h4>\n<p>为了解决上述协程并发问题，Go语言引入了Context包。Context可以在不同的协程之间传递请求范围的数据、取消信号和截止时间等。</p>\n<h3>3. 解析</h3>\n<h4>（1）Context是什么</h4>\n<p>Context是Go语言标准库<code>context</code>包中的一个接口，定义如下：</p>\n<pre><code class=\"language-go\">type Context interface {\n    Deadline() (deadline time.Time, ok bool)\n    Done() &#x3C;-chan struct{}\n    Err() error\n    Value(key interface{}) interface{}\n}\n</code></pre>\n<ul>\n  <li><code>Deadline</code>：返回该Context的截止时间，如果没有设置截止时间，<code>ok</code>为<code>false</code>。</li>\n  <li><code>Done</code>：返回一个只读的通道，当Context被取消或超时，该通道会被关闭。</li>\n  <li><code>Err</code>：返回Context被取消的原因。</li>\n  <li><code>Value</code>：返回与指定键关联的值。</li>\n</ul>\n<h4>（2）如何利用Context进行协程并发控制</h4>\n<ul>\n  <li><strong>取消信号传递</strong>：可以使用<code>context.WithCancel</code>创建一个可取消的Context，当调用取消函数时，所有基于该Context的协程都会收到取消信号。</li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc worker(ctx context.Context) {\n    for {\n        select {\n        case &#x3C;-ctx.Done():\n            fmt.Println(\"Worker cancelled\")\n            return\n        default:\n            fmt.Println(\"Working...\")\n            time.Sleep(1 * time.Second)\n        }\n    }\n}\n\nfunc main() {\n    ctx, cancel := context.WithCancel(context.Background())\n    go worker(ctx)\n\n    time.Sleep(3 * time.Second)\n    cancel()\n    time.Sleep(1 * time.Second)\n}\n</code></pre>\n<p>在这个例子中，<code>context.WithCancel</code>创建了一个可取消的Context，<code>cancel</code>函数用于取消该Context。在<code>worker</code>协程中，通过<code>select</code>监听<code>ctx.Done()</code>通道，当收到取消信号时，协程退出。</p>\n<ul>\n  <li><strong>超时控制</strong>：使用<code>context.WithTimeout</code>或<code>context.WithDeadline</code>可以设置Context的超时时间，当超过指定时间，Context会自动取消。</li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc worker(ctx context.Context) {\n    for {\n        select {\n        case &#x3C;-ctx.Done():\n            fmt.Println(\"Worker cancelled due to timeout\")\n            return\n        default:\n            fmt.Println(\"Working...\")\n            time.Sleep(1 * time.Second)\n        }\n    }\n}\n\nfunc main() {\n    ctx, _ := context.WithTimeout(context.Background(), 3*time.Second)\n    go worker(ctx)\n\n    time.Sleep(5 * time.Second)\n}\n</code></pre>\n<p>在这个例子中，<code>context.WithTimeout</code>创建了一个带有超时时间的Context，当超过3秒后，Context自动取消，<code>worker</code>协程收到取消信号后退出。</p>\n<ul>\n  <li><strong>传递请求范围的数据</strong>：使用<code>context.WithValue</code>可以在Context中存储和传递请求范围的数据。</li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n)\n\nfunc worker(ctx context.Context) {\n    value := ctx.Value(\"key\")\n    fmt.Println(\"Received value:\", value)\n}\n\nfunc main() {\n    ctx := context.WithValue(context.Background(), \"key\", \"value\")\n    go worker(ctx)\n\n    fmt.Scanln()\n}\n</code></pre>\n<p>在这个例子中，<code>context.WithValue</code>将键值对存储在Context中，在<code>worker</code>协程中可以通过<code>ctx.Value</code>获取该值。</p>\n<h3>4. 常见误区</h3>\n<h4>（1）不及时取消Context</h4>\n<p>\n  误区：创建了可取消的Context，但没有在合适的时机调用取消函数，导致资源无法及时释放。\n  纠正：在不需要使用Context时，及时调用取消函数。\n</p>\n<h4>（2）滥用<code>context.WithValue</code></h4>\n<p>\n  误区：在Context中存储大量数据或敏感数据。\n  纠正：<code>context.WithValue</code>主要用于传递请求范围的少量数据，不适合存储大量数据或敏感数据。\n</p>\n<h4>（3）不处理Context的错误</h4>\n<p>\n  误区：在协程中监听<code>ctx.Done()</code>通道，但不处理<code>ctx.Err()</code>返回的错误。\n  纠正：在协程中处理<code>ctx.Err()</code>返回的错误，以便了解Context被取消的原因。\n</p>\n<h3>5. 总结回答</h3>\n<p>“在Go语言中，Context是一个接口，用于在不同的协程之间传递请求范围的数据、取消信号和截止时间等。它定义了<code>Deadline</code>、<code>Done</code>、<code>Err</code>和<code>Value</code>四个方法。</p>\n<p>利用Context进行协程并发控制主要有以下几种方式：</p>\n<ul>\n  <li>取消信号传递：使用<code>context.WithCancel</code>创建可取消的Context，通过调用取消函数向所有基于该Context的协程发送取消信号。</li>\n  <li>超时控制：使用<code>context.WithTimeout</code>或<code>context.WithDeadline</code>设置Context的超时时间，当超过指定时间，Context自动取消。</li>\n  <li>传递请求范围的数据：使用<code>context.WithValue</code>在Context中存储和传递请求范围的数据。</li>\n</ul>\n<p>在使用Context时，需要注意及时取消Context，避免滥用<code>context.WithValue</code>，并处理Context的错误。”</p>",
    "more_ask": "<h3>1. Context 的底层实现原理是怎样的？</h3>\n<p>提示：可以从 Context 接口的几个方法实现、不同类型 Context（如 EmptyCtx、CancelCtx 等）的结构体组成和操作逻辑去思考。</p>\n<h3>2. 在使用 WithTimeout 和 WithDeadline 时，底层的定时器是如何管理的？</h3>\n<p>提示：考虑 Go 语言的定时器机制，以及在 Context 中如何利用这些机制来实现超时和截止时间控制。</p>\n<h3>3. 当一个父 Context 被取消时，它的子 Context 是如何被取消的？</h3>\n<p>提示：关注 Context 之间的层级关系，以及取消操作在层级间的传播逻辑。</p>\n<h3>4. 如何在 Context 中安全地传递自定义数据？</h3>\n<p>提示：思考使用 <code>context.WithValue</code> 时可能遇到的并发安全问题，以及如何避免这些问题。</p>\n<h3>5. 如果在一个协程中使用了 Context 进行取消控制，但该协程中有阻塞的系统调用，Context 取消时会立即生效吗？</h3>\n<p>提示：考虑阻塞系统调用的特性，以及 Go 语言在处理这类情况时的机制。</p>\n<h3>6. 如何在多个协程中复用同一个 Context 进行并发控制，同时保证数据的一致性？</h3>\n<p>提示：关注并发场景下对 Context 的操作，以及如何避免数据竞争。</p>\n<h3>7. 在微服务架构中，Context 如何在不同服务之间传递和使用？</h3>\n<p>提示：思考微服务之间的通信方式，以及如何将 Context 信息在这些通信过程中传递。</p>\n<h3>8. 当使用 Context 进行并发控制时，如何处理 Context 取消后的资源释放问题？</h3>\n<p>提示：考虑在协程中使用的各种资源，如文件句柄、网络连接等，以及如何在 Context 取消时正确释放这些资源。</p>",
    "mindmap": "mindmap\n  root((Go语言里的Context))\n    定义\n      包提供类型\n      接口定义\n        Deadline()\n        Done()\n        Err()\n        Value(key interface{})\n    用途\n      并发控制\n        取消信号传递\n        超时控制\n        传递请求作用域数据\n      处理网络请求\n      处理数据库查询",
    "keynote": "Go语言中context包提供Context类型\nContext是接口，有Deadline、Done、Err、Value方法\n利用Context进行协程并发控制：\n  取消信号传递：用context.WithCancel创建可取消Context\n  超时控制：用context.WithTimeout或WithDeadline设置超时时间\n  传递请求作用域数据：用context.WithValue存储和传递数据",
    "group_id": 23,
    "kps": [
      "并发编程",
      "标准库"
    ],
    "years": [
      2024
    ],
    "corps": [
      "科大讯飞"
    ]
  }
}