{
  "success": true,
  "data": {
    "id": 109835,
    "name": "<p>简述context的数据结构</p>",
    "options": null,
    "answer": "<p>在Go语言里，<code>context</code> 包提供了上下文管理机制，用于在不同的Go协程之间传递请求范围的数据、取消信号以及截止时间等。<code>context</code> 主要基于接口和几个具体的实现结构体来构建其数据结构。</p>\n<h3>核心接口</h3>\n<p><code>context</code> 包定义了一个核心接口 <code>Context</code>，其定义如下：</p>\n<pre><code class=\"language-go\">type Context interface {\n    Deadline() (deadline time.Time, ok bool)\n    Done() &#x3C;-chan struct{}\n    Err() error\n    Value(key interface{}) interface{}\n}\n</code></pre>\n<ul>\n  <li><code>Deadline()</code>：返回该上下文的截止时间以及一个布尔值 <code>ok</code>。若存在截止时间，<code>ok</code> 为 <code>true</code>，同时返回具体的截止时间；若不存在，<code>ok</code> 为 <code>false</code>。</li>\n  <li><code>Done()</code>：返回一个只读的 <code>chan struct{}</code> 类型的通道。当上下文被取消或者超时的时候，该通道会被关闭。通过监听这个通道，协程可以得知上下文的取消信号。</li>\n  <li><code>Err()</code>：返回上下文被取消的原因。若 <code>Done()</code> 通道未关闭，<code>Err()</code> 返回 <code>nil</code>；若通道已关闭，<code>Err()</code> 会返回一个非 <code>nil</code> 的错误，如 <code>context.Canceled</code> 表示手动取消，<code>context.DeadlineExceeded</code> 表示超过截止时间。</li>\n  <li><code>Value(key interface{})</code>：用于获取上下文中与指定键关联的值。若键不存在，则返回 <code>nil</code>。</li>\n</ul>\n<h3>具体实现结构体</h3>\n<h4>1. <code>emptyCtx</code></h4>\n<p><code>emptyCtx</code> 是一个最简单的上下文实现，它不包含任何截止时间、取消信号和关联的值。<code>context</code> 包中定义了两个全局的 <code>emptyCtx</code> 实例：<code>background</code> 和 <code>todo</code>。</p>\n<pre><code class=\"language-go\">type emptyCtx int\n\nfunc (*emptyCtx) Deadline() (deadline time.Time, ok bool) {\n    return\n}\n\nfunc (*emptyCtx) Done() &#x3C;-chan struct{} {\n    return nil\n}\n\nfunc (*emptyCtx) Err() error {\n    return nil\n}\n\nfunc (*emptyCtx) Value(key interface{}) interface{} {\n    return nil\n}\n</code></pre>\n<p><code>background</code> 和 <code>todo</code> 通常作为上下文树的根节点使用，例如：</p>\n<pre><code class=\"language-go\">ctx := context.Background()\n</code></pre>\n<h4>2. <code>cancelCtx</code></h4>\n<p><code>cancelCtx</code> 是可取消的上下文，它包含一个父上下文、一个取消函数和一个用于通知取消的通道。</p>\n<pre><code class=\"language-go\">type cancelCtx struct {\n    Context\n\n    mu       sync.Mutex            // 用于保护以下字段\n    done     chan struct{}         // 当被取消时关闭\n    children map[canceler]struct{} // 子上下文\n    err      error                 // 取消的错误信息\n}\n</code></pre>\n<p><code>cancelCtx</code> 可以通过 <code>context.WithCancel</code> 函数创建：</p>\n<pre><code class=\"language-go\">ctx, cancel := context.WithCancel(context.Background())\n</code></pre>\n<p>调用 <code>cancel()</code> 函数会关闭 <code>done</code> 通道，通知所有子上下文取消，并设置 <code>err</code> 为 <code>context.Canceled</code>。</p>\n<h4>3. <code>timerCtx</code></h4>\n<p><code>timerCtx</code> 是带有截止时间的上下文，它嵌入了 <code>cancelCtx</code>，并包含一个 <code>time.Timer</code> 用于在截止时间到达时自动取消上下文。</p>\n<pre><code class=\"language-go\">type timerCtx struct {\n    cancelCtx\n    timer *time.Timer // 截止时间到达时触发取消\n\n    deadline time.Time\n}\n</code></pre>\n<p><code>timerCtx</code> 可以通过 <code>context.WithDeadline</code> 或 <code>context.WithTimeout</code> 函数创建：</p>\n<pre><code class=\"language-go\">ctx, cancel := context.WithTimeout(context.Background(), time.Second)\n</code></pre>\n<p>当截止时间到达时，<code>timer</code> 会触发取消操作，关闭 <code>done</code> 通道，并设置 <code>err</code> 为 <code>context.DeadlineExceeded</code>。</p>\n<h4>4. <code>valueCtx</code></h4>\n<p><code>valueCtx</code> 用于在上下文中存储键值对，它包含一个父上下文、一个键和一个值。</p>\n<pre><code class=\"language-go\">type valueCtx struct {\n    Context\n    key, val interface{}\n}\n</code></pre>\n<p><code>valueCtx</code> 可以通过 <code>context.WithValue</code> 函数创建：</p>\n<pre><code class=\"language-go\">ctx := context.WithValue(context.Background(), \"key\", \"value\")\n</code></pre>\n<p>调用 <code>Value(key)</code> 方法时，会先检查当前上下文的键是否匹配，若匹配则返回对应的值；若不匹配，则递归调用父上下文的 <code>Value(key)</code> 方法。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.008319467,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：简述Go语言中<code>context</code>的数据结构。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对<code>context</code>包的了解。</li>\n      <li><code>context</code>接口及其实现类型的结构特点。</li>\n      <li><code>context</code>在Go并发编程中的作用。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<ul>\n  <li><code>context</code>包是Go语言标准库中用于在多个Go协程之间传递请求作用域的数据、取消信号和截止时间等信息的工具。它在处理请求链路中的并发操作时非常有用，能帮助管理资源和控制程序的执行流程。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）<code>context</code>接口</h4>\n<p><code>context</code>包定义了一个<code>Context</code>接口，这是<code>context</code>数据结构的基础。其定义如下：</p>\n<pre><code class=\"language-go\">type Context interface {\n    Deadline() (deadline time.Time, ok bool)\n    Done() &#x3C;-chan struct{}\n    Err() error\n    Value(key interface{}) interface{}\n}\n</code></pre>\n<ul>\n  <li><code>Deadline()</code>：返回该<code>context</code>的截止时间，如果没有设置截止时间，<code>ok</code>为<code>false</code>。</li>\n  <li><code>Done()</code>：返回一个只读的<code>channel</code>，当<code>context</code>被取消或超时，该<code>channel</code>会被关闭。</li>\n  <li><code>Err()</code>：返回<code>context</code>被取消的原因。</li>\n  <li><code>Value(key interface{})</code>：返回与<code>key</code>关联的值，如果没有则返回<code>nil</code>。</li>\n</ul>\n<h4>（2）实现类型</h4>\n<p><code>context</code>包提供了几种实现<code>Context</code>接口的具体类型：</p>\n<ul>\n  <li><strong><code>emptyCtx</code></strong>：是一个空的<code>context</code>实现，不包含任何值、截止时间和取消信号。有两个预定义的<code>emptyCtx</code>实例：<code>background</code>和<code>todo</code>，通常作为<code>context</code>树的根节点。</li>\n</ul>\n<pre><code class=\"language-go\">type emptyCtx int\n\nfunc (*emptyCtx) Deadline() (deadline time.Time, ok bool) {\n    return\n}\n\nfunc (*emptyCtx) Done() &#x3C;-chan struct{} {\n    return nil\n}\n\nfunc (*emptyCtx) Err() error {\n    return nil\n}\n\nfunc (*emptyCtx) Value(key interface{}) interface{} {\n    return nil\n}\n</code></pre>\n<ul>\n  <li><strong><code>cancelCtx</code></strong>：用于取消操作。它包含一个父<code>context</code>、一个取消函数<code>cancel</code>和一个用于通知取消的<code>channel</code>。当调用<code>cancel</code>函数时，会关闭<code>Done()</code>返回的<code>channel</code>，并向所有子<code>context</code>传播取消信号。</li>\n</ul>\n<pre><code class=\"language-go\">type cancelCtx struct {\n    Context\n    mu       sync.Mutex            // 保护以下字段\n    done     chan struct{}         // 延迟初始化\n    children map[canceler]struct{} // 子context\n    err      error                 // 取消原因\n}\n</code></pre>\n<ul>\n  <li><strong><code>timerCtx</code></strong>：继承自<code>cancelCtx</code>，增加了一个<code>time.Timer</code>和截止时间<code>deadline</code>。当到达截止时间时，会自动触发取消操作。</li>\n</ul>\n<pre><code class=\"language-go\">type timerCtx struct {\n    cancelCtx\n    timer *time.Timer // 用于在截止时间触发取消\n    deadline time.Time\n}\n</code></pre>\n<ul>\n  <li><strong><code>valueCtx</code></strong>：用于在<code>context</code>中存储键值对。它包含一个父<code>context</code>和一个键值对。</li>\n</ul>\n<pre><code class=\"language-go\">type valueCtx struct {\n    Context\n    key, val interface{}\n}\n</code></pre>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n    defer cancel()\n\n    go func() {\n        select {\n        case &#x3C;-ctx.Done():\n            fmt.Println(\"Context is cancelled:\", ctx.Err())\n        case &#x3C;-time.After(3 * time.Second):\n            fmt.Println(\"Task completed\")\n        }\n    }()\n\n    time.Sleep(3 * time.Second)\n}\n</code></pre>\n<p>在这个例子中，使用<code>context.WithTimeout</code>创建了一个<code>timerCtx</code>，设置了2秒的超时时间。当超时发生时，<code>ctx.Done()</code>返回的<code>channel</code>会被关闭，从而触发相应的操作。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）不理解<code>context</code>的层级关系</h4>\n<ul>\n  <li>误区：认为所有<code>context</code>都是独立的，没有层级关系。</li>\n  <li>纠正：<code>context</code>通常是通过父<code>context</code>创建子<code>context</code>形成树状结构，取消信号会从父<code>context</code>向子<code>context</code>传播。</li>\n</ul>\n<h4>（2）滥用<code>context.Value</code></h4>\n<ul>\n  <li>误区：在<code>context</code>中存储大量数据或频繁使用<code>context.Value</code>传递数据。</li>\n  <li>纠正：<code>context.Value</code>主要用于传递请求作用域的元数据，不适合存储大量数据，大量使用会影响代码的可读性和性能。</li>\n</ul>\n<h4>（3）忘记调用取消函数</h4>\n<ul>\n  <li>误区：使用可取消的<code>context</code>时，忘记调用取消函数，导致资源泄漏。</li>\n  <li>纠正：在使用<code>context.WithCancel</code>、<code>context.WithTimeout</code>等创建可取消的<code>context</code>时，要确保在合适的时机调用取消函数。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>Go语言中的<code>context</code>数据结构以<code>Context</code>接口为基础，该接口定义了<code>Deadline()</code>、<code>Done()</code>、<code>Err()</code>和<code>Value(key interface{})</code>四个方法。常见的实现类型有：</p>\n<ul>\n  <li><code>emptyCtx</code>：空的<code>context</code>，作为根节点，不包含任何值、截止时间和取消信号。</li>\n  <li><code>cancelCtx</code>：用于取消操作，包含父<code>context</code>、取消函数和通知取消的<code>channel</code>。</li>\n  <li><code>timerCtx</code>：继承自<code>cancelCtx</code>，增加了<code>time.Timer</code>和截止时间，可在到达截止时间时自动触发取消。</li>\n  <li><code>valueCtx</code>：用于存储键值对，包含父<code>context</code>和一个键值对。</li>\n</ul>\n<p><code>context</code>通过层级关系形成树状结构，取消信号会从父<code>context</code>向子<code>context</code>传播。使用时要注意避免滥用<code>context.Value</code>，并确保在合适的时机调用取消函数，防止资源泄漏。</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      <strong>context 超时机制的底层实现原理是什么</strong>\n      提示：思考 Go 语言中如何利用定时器和信号机制来实现超时控制，结合 context 源码里与超时相关的字段和方法。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在一个复杂的微服务架构中，如何合理使用 context 进行请求追踪</strong>\n      提示：考虑如何在不同服务间传递 context，以及如何利用 context 携带的信息来构建请求链路。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如果在一个 goroutine 中使用了 context，当 context 被取消时，如何确保 goroutine 内的资源被正确释放</strong>\n      提示：关注 context 的 Done 通道，以及在 goroutine 中如何监听该通道并执行资源释放操作。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>context 与 Go 语言的并发模型是如何协同工作的</strong>\n      提示：从 goroutine 的创建、调度和通信角度，分析 context 在其中起到的作用。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在使用 context 时，如何避免出现 context 泄漏的问题</strong>\n      提示：思考 context 的生命周期管理，以及在哪些情况下可能会导致 context 无法正常取消。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>自定义一个 context 类型需要注意哪些方面</strong>\n      提示：参考标准库中 context 接口的定义，考虑如何实现接口方法以及如何处理取消和超时逻辑。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>当多个 context 嵌套使用时，它们的取消顺序是怎样的</strong>\n      提示：分析 context 树状结构中，父 context 和子 context 取消操作的传播机制。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在 context 中传递的数据有什么限制和最佳实践</strong>\n      提示：考虑数据的类型、大小和并发安全性，以及如何避免在 context 中传递过多的业务数据。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Go语言context包))\n    上下文管理机制\n      不同Go协程间传递数据\n      传递取消信号\n      传递截止时间\n    核心接口\n      Context接口\n        Deadline()\n        Done()\n        Err()\n        Value(key interface{})\n    具体实现结构体\n      emptyCtx\n        无截止时间、取消信号和关联值\n        全局实例：background和todo\n      cancelCtx\n        可取消上下文\n        包含父上下文、取消函数和通知通道\n        通过context.WithCancel创建\n      timerCtx\n        带截止时间上下文\n        嵌入cancelCtx，含time.Timer\n        通过context.WithDeadline或WithTimeout创建\n      valueCtx\n        存储键值对\n        包含父上下文、键和值\n        通过context.WithValue创建",
    "keynote": "Go语言context包\n- 提供上下文管理机制，用于协程间传递数据、取消信号和截止时间\n- 核心接口Context：Deadline()、Done()、Err()、Value(key interface{})\n- 具体实现结构体：\n  - emptyCtx：无截止时间等，有background和todo实例\n  - cancelCtx：可取消，含父上下文等，用context.WithCancel创建\n  - timerCtx：带截止时间，嵌入cancelCtx，用context.WithDeadline或WithTimeout创建\n  - valueCtx：存储键值对，含父上下文等，用context.WithValue创建",
    "group_id": 23,
    "kps": [
      "标准库",
      "编译和运行时"
    ],
    "years": [
      2024,
      2023
    ],
    "corps": [
      "腾讯",
      "京东",
      "深信服",
      "知乎"
    ]
  }
}