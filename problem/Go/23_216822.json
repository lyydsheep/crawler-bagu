{
  "success": true,
  "data": {
    "id": 216822,
    "name": "<p>GMP中的M具体指什么，对应内核的什么，除了系统调用，G还有哪些情况会阻塞，请详细说明</p>",
    "options": null,
    "answer": "<h3>M的含义及对应内核内容</h3>\n<p>在Go的GMP调度模型中，M（Machine）代表着操作系统线程。它是Go程序与操作系统内核之间的桥梁，负责执行G（Goroutine）。每个M都对应着一个内核线程，内核线程由操作系统进行调度，拥有自己独立的栈空间和寄存器状态。当M被操作系统调度执行时，它会从P（Processor）的本地队列或者全局队列中获取G来执行。</p>\n<h3>G阻塞的其他情况</h3>\n<p>除了系统调用会导致G阻塞外，以下几种情况也会使G阻塞：</p>\n<ol>\n  <li><strong>通道操作阻塞</strong>\n    <ul>\n      <li><strong>发送阻塞</strong>：当向一个已满的有缓冲通道或者无缓冲通道发送数据时，当前G会被阻塞。例如：</li>\n    </ul>\n  </li>\n</ol>\n<pre><code class=\"language-go\">package main\n\nfunc main() {\n    ch := make(chan int, 1)\n    ch &#x3C;- 1 // 第一次发送成功\n    ch &#x3C;- 2 // 此时通道已满，当前G会阻塞\n}\n</code></pre>\n<pre><code>- **接收阻塞**：当从一个空的有缓冲通道或者无缓冲通道接收数据时，当前G会被阻塞。例如：\n</code></pre>\n<pre><code class=\"language-go\">package main\n\nfunc main() {\n    ch := make(chan int, 1)\n    &#x3C;-ch // 此时通道为空，当前G会阻塞\n}\n</code></pre>\n<ol start=\"2\">\n  <li><strong>锁操作阻塞</strong>\n    <ul>\n      <li><strong>互斥锁（sync.Mutex）</strong>：当一个G已经获取了互斥锁，其他G尝试获取该锁时会被阻塞，直到持有锁的G释放锁。例如：</li>\n    </ul>\n  </li>\n</ol>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nvar mu sync.Mutex\n\nfunc worker() {\n    mu.Lock()\n    defer mu.Unlock()\n    // 模拟一些工作\n    fmt.Println(\"Working...\")\n}\n\nfunc main() {\n    go worker()\n    mu.Lock() // 由于另一个G已经获取了锁，这里会阻塞\n    defer mu.Unlock()\n}\n</code></pre>\n<pre><code>- **读写锁（sync.RWMutex）**：读写锁允许多个G同时进行读操作，但写操作是互斥的。当有G持有写锁时，其他G的读操作和写操作都会被阻塞；当有G持有读锁时，其他G的写操作会被阻塞。例如：\n</code></pre>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nvar rwmu sync.RWMutex\n\nfunc read() {\n    rwmu.RLock()\n    defer rwmu.RUnlock()\n    // 模拟读操作\n    fmt.Println(\"Reading...\")\n}\n\nfunc write() {\n    rwmu.Lock()\n    defer rwmu.Unlock()\n    // 模拟写操作\n    fmt.Println(\"Writing...\")\n}\n\nfunc main() {\n    go read()\n    rwmu.Lock() // 由于有G持有读锁，这里会阻塞\n    defer rwmu.Unlock()\n}\n</code></pre>\n<ol start=\"3\">\n  <li>\n    <strong>等待组（sync.WaitGroup）阻塞</strong>\n    当G调用<code>WaitGroup</code>的<code>Wait</code>方法时，如果<code>WaitGroup</code>的计数器不为0，当前G会被阻塞，直到计数器变为0。例如：\n  </li>\n</ol>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc worker(wg *sync.WaitGroup) {\n    defer wg.Done()\n    // 模拟一些工作\n    fmt.Println(\"Working...\")\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n    wg.Add(1)\n    go worker(&#x26;wg)\n    wg.Wait() // 等待所有任务完成，当前G会阻塞\n    fmt.Println(\"All tasks done.\")\n}\n</code></pre>\n<ol start=\"4\">\n  <li><strong>定时器（time.Timer和time.Ticker）阻塞</strong>\n    <ul>\n      <li><strong>time.Timer</strong>：当调用<code>Timer</code>的<code>C</code>通道接收数据时，如果定时器还未到期，当前G会被阻塞。例如：</li>\n    </ul>\n  </li>\n</ol>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    timer := time.NewTimer(2 * time.Second)\n    &#x3C;-timer.C // 等待2秒，当前G会阻塞\n    fmt.Println(\"Timer expired.\")\n}\n</code></pre>\n<pre><code>- **time.Ticker**：当调用`Ticker`的`C`通道接收数据时，如果还未到下一个时间间隔，当前G会被阻塞。例如：\n</code></pre>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    ticker := time.NewTicker(1 * time.Second)\n    for range ticker.C {\n        fmt.Println(\"Tick...\")\n    }\n}\n</code></pre>",
    "type": 6,
    "level": 2,
    "freq": 0.001663893,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：\n    <ul>\n      <li>GMP中的M具体指什么，对应内核的什么。</li>\n      <li>除了系统调用，G还有哪些情况会阻塞。</li>\n    </ul>\n  </li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Go语言GMP调度模型中M的理解。</li>\n      <li>M与内核资源的对应关系。</li>\n      <li>Go协程（G）阻塞情况的掌握。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）GMP调度模型</h4>\n<ul>\n  <li>GMP是Go语言的调度模型，其中G代表Goroutine（协程），M代表Machine（内核线程），P代表Processor（处理器）。该模型用于高效地调度和管理大量的Goroutine。</li>\n</ul>\n<h4>（2）阻塞的概念</h4>\n<ul>\n  <li>在Go中，阻塞是指Goroutine暂时停止执行，等待某个条件满足后再继续执行。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）M的含义及对应内核资源</h4>\n<ul>\n  <li><strong>含义</strong>：M是Machine的缩写，代表内核线程。它是Go运行时系统与操作系统内核之间的桥梁，负责执行Goroutine。</li>\n  <li><strong>对应内核资源</strong>：每个M都对应一个操作系统的内核线程。内核线程由操作系统内核管理，负责执行具体的指令，拥有自己的栈空间、寄存器等资源。Go运行时系统通过M来利用操作系统的多线程能力，实现并发执行。</li>\n</ul>\n<h4>（2）除系统调用外G的阻塞情况</h4>\n<ul>\n  <li><strong>通道操作阻塞</strong>\n    <ul>\n      <li><strong>发送阻塞</strong>：当向一个已满的有缓冲通道发送数据，或者向一个无缓冲通道发送数据且没有接收者准备好接收时，Goroutine会阻塞。例如：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nfunc main() {\n    ch := make(chan int, 1)\n    ch &#x3C;- 1\n    ch &#x3C;- 2 // 这里会阻塞，因为通道已满\n}\n</code></pre>\n<pre><code>- **接收阻塞**：当从一个空的有缓冲通道接收数据，或者从一个无缓冲通道接收数据且没有发送者准备好发送时，Goroutine会阻塞。例如：\n</code></pre>\n<pre><code class=\"language-go\">package main\n\nfunc main() {\n    ch := make(chan int)\n    &#x3C;-ch // 这里会阻塞，因为通道为空且没有发送者\n}\n</code></pre>\n<ul>\n  <li><strong>锁操作阻塞</strong>\n    <ul>\n      <li><strong>互斥锁（sync.Mutex）</strong>：当一个Goroutine尝试获取一个已经被其他Goroutine持有的互斥锁时，该Goroutine会阻塞，直到锁被释放。例如：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nvar mu sync.Mutex\n\nfunc worker() {\n    mu.Lock()\n    defer mu.Unlock()\n    // 模拟一些工作\n    fmt.Println(\"Working...\")\n}\n\nfunc main() {\n    go worker()\n    mu.Lock() // 这里会阻塞，因为worker已经持有锁\n    defer mu.Unlock()\n}\n</code></pre>\n<pre><code>- **读写锁（sync.RWMutex）**：写锁是排他的，当一个Goroutine尝试获取写锁时，如果有其他Goroutine持有读锁或写锁，该Goroutine会阻塞；读锁在有写锁被持有时也会阻塞。\n</code></pre>\n<ul>\n  <li><strong>等待组（sync.WaitGroup）阻塞</strong>\n    <ul>\n      <li>当Goroutine调用<code>WaitGroup</code>的<code>Wait</code>方法时，如果<code>WaitGroup</code>的计数器不为零，该Goroutine会阻塞，直到计数器变为零。例如：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc worker(wg *sync.WaitGroup) {\n    defer wg.Done()\n    // 模拟一些工作\n    fmt.Println(\"Working...\")\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n    wg.Add(1)\n    go worker(&#x26;wg)\n    wg.Wait() // 这里会阻塞，直到worker调用Done\n    fmt.Println(\"All workers done.\")\n}\n</code></pre>\n<ul>\n  <li><strong>定时器阻塞</strong>\n    <ul>\n      <li>当使用<code>time.Sleep</code>、<code>time.Timer</code>或<code>time.Ticker</code>时，Goroutine会阻塞相应的时间。例如：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    fmt.Println(\"Before sleep\")\n    time.Sleep(2 * time.Second) // 这里会阻塞2秒\n    fmt.Println(\"After sleep\")\n}\n</code></pre>\n<h3>4. 总结回答</h3>\n<p>“在Go语言的GMP调度模型中，M代表Machine，即内核线程。每个M对应一个操作系统的内核线程，它是Go运行时系统与操作系统内核之间的桥梁，负责执行Goroutine。</p>\n<p>除了系统调用，Goroutine（G）还有以下几种阻塞情况：</p>\n<ol>\n  <li><strong>通道操作阻塞</strong>：向已满的有缓冲通道发送数据、向无缓冲通道发送数据且无接收者、从空的有缓冲通道接收数据、从无缓冲通道接收数据且无发送者时，Goroutine会阻塞。</li>\n  <li><strong>锁操作阻塞</strong>：尝试获取已被其他Goroutine持有的互斥锁（sync.Mutex）或在有其他Goroutine持有读写锁（sync.RWMutex）时获取写锁或读锁，Goroutine会阻塞。</li>\n  <li><strong>等待组（sync.WaitGroup）阻塞</strong>：调用<code>WaitGroup</code>的<code>Wait</code>方法时，若计数器不为零，Goroutine会阻塞。</li>\n  <li><strong>定时器阻塞</strong>：使用<code>time.Sleep</code>、<code>time.Timer</code>或<code>time.Ticker</code>时，Goroutine会阻塞相应的时间。”</li>\n</ol>",
    "more_ask": "<h3>1. M的资源管理相关</h3>\n<ul>\n  <li><strong>问题</strong>：M在获取和释放资源时，有哪些机制来保证资源的合理利用和避免竞争？\n    <ul>\n      <li><strong>提示</strong>：思考M在获取资源（如线程栈空间等）时的分配策略，以及释放资源时如何避免与其他M产生冲突，可结合Go的内存管理和同步机制。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. M与P、G的协作细节</h3>\n<ul>\n  <li><strong>问题</strong>：当一个M上的G阻塞时，M和P、G之间是如何重新调度和协作的？\n    <ul>\n      <li><strong>提示</strong>：考虑G阻塞后M的状态变化，P是否会与其他M绑定，以及阻塞的G后续如何恢复执行。</li>\n    </ul>\n  </li>\n</ul>\n<h3>3. M的创建和销毁策略</h3>\n<ul>\n  <li><strong>问题</strong>：Go运行时系统是基于什么策略来创建和销毁M的？\n    <ul>\n      <li><strong>提示</strong>：分析系统在什么情况下会创建新的M，以及在什么条件下会销毁M，可结合系统负载、G的数量等因素。</li>\n    </ul>\n  </li>\n</ul>\n<h3>4. 不同阻塞场景下M的行为差异</h3>\n<ul>\n  <li><strong>问题</strong>：在网络I/O阻塞和锁阻塞这两种不同场景下，M的行为有什么不同？\n    <ul>\n      <li><strong>提示</strong>：对比网络I/O阻塞和锁阻塞时M的状态变化、是否会让出P、以及后续的调度流程。</li>\n    </ul>\n  </li>\n</ul>\n<h3>5. M的调度优先级</h3>\n<ul>\n  <li><strong>问题</strong>：M是否有调度优先级之分？如果有，是如何确定的？\n    <ul>\n      <li><strong>提示</strong>：思考Go运行时系统是否会根据M的某些属性（如负载、执行的G的类型等）来确定其调度优先级。</li>\n    </ul>\n  </li>\n</ul>\n<h3>6. M的异常处理</h3>\n<ul>\n  <li><strong>问题</strong>：当M在执行过程中出现异常（如栈溢出）时，Go运行时系统是如何处理的？\n    <ul>\n      <li><strong>提示</strong>：考虑异常发生时M的状态保存、错误信息的传递以及后续的恢复或清理操作。</li>\n    </ul>\n  </li>\n</ul>\n<h3>7. M与多核CPU的关系</h3>\n<ul>\n  <li><strong>问题</strong>：在多核CPU环境下，M是如何利用多核资源的？\n    <ul>\n      <li><strong>提示</strong>：分析M在多核CPU上的分布情况、调度策略以及如何避免多核之间的竞争和冲突。</li>\n    </ul>\n  </li>\n</ul>",
    "mindmap": "mindmap\n  root((Go的GMP调度模型及G阻塞情况))\n    M的含义及对应内核内容\n      M代表操作系统线程\n      是Go程序与内核桥梁\n      负责执行G\n      对应内核线程\n      有独立栈空间和寄存器状态\n      从P队列获取G执行\n    G阻塞的其他情况\n      通道操作阻塞\n        发送阻塞\n        接收阻塞\n      锁操作阻塞\n        互斥锁（sync.Mutex）\n        读写锁（sync.RWMutex）\n      等待组（sync.WaitGroup）阻塞\n      定时器（time.Timer和time.Ticker）阻塞\n        time.Timer\n        time.Ticker",
    "keynote": "M含义及内核内容：M代表操作系统线程，是Go与内核桥梁，执行G，对应内核线程，有独立栈和寄存器状态，从P队列取G执行\nG阻塞情况：\n- 通道操作阻塞：发送（满通道）、接收（空通道）\n- 锁操作阻塞：互斥锁、读写锁\n- 等待组阻塞：WaitGroup计数器不为0\n- 定时器阻塞：Timer未到期、Ticker未到间隔",
    "group_id": 23,
    "kps": [
      "并发编程"
    ],
    "years": [
      2022
    ],
    "corps": [
      "百度教育"
    ]
  }
}