{
  "success": true,
  "data": {
    "id": 109252,
    "name": "<p>Slice 扩容后在原 Slice 上修改数据，新 Slice 是否会发生变化</p>",
    "options": null,
    "answer": "<p>在 Go 语言中，Slice 扩容后在原 Slice 上修改数据，新 Slice 是否会发生变化取决于扩容时是否发生了底层数组的重新分配。</p>\n<h3>情况一：未发生底层数组重新分配</h3>\n<p>当扩容时所需容量没有超过原底层数组的容量时，不会重新分配底层数组，新 Slice 和原 Slice 仍然共享同一个底层数组。此时在原 Slice 上修改数据，新 Slice 会发生变化。</p>\n<p>示例代码如下：</p>\n<pre><code class=\"language-go\">package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 创建一个初始容量为 5 的 Slice\n    originalSlice := make([]int, 3, 5)\n    for i := 0; i &#x3C; 3; i++ {\n        originalSlice[i] = i\n    }\n    // 扩容，由于所需容量未超过原底层数组容量，不会重新分配底层数组\n    newSlice := originalSlice[:4]\n    // 在原 Slice 上修改数据\n    originalSlice[0] = 100\n    // 输出新 Slice，会发现新 Slice 也发生了变化\n    fmt.Println(\"New Slice:\", newSlice) \n}\n</code></pre>\n<p>在上述代码中，<code>originalSlice</code> 的初始容量为 5，当创建 <code>newSlice</code> 时，所需容量未超过原底层数组的容量，因此它们共享同一个底层数组。当在 <code>originalSlice</code> 上修改数据时，<code>newSlice</code> 也会发生变化。</p>\n<h3>情况二：发生底层数组重新分配</h3>\n<p>当扩容时所需容量超过了原底层数组的容量，Go 会重新分配一个新的底层数组，并将原底层数组的数据复制到新的底层数组中。此时新 Slice 和原 Slice 不再共享同一个底层数组，在原 Slice 上修改数据，新 Slice 不会发生变化。</p>\n<p>示例代码如下：</p>\n<pre><code class=\"language-go\">package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 创建一个初始容量为 2 的 Slice\n    originalSlice := make([]int, 2, 2)\n    for i := 0; i &#x3C; 2; i++ {\n        originalSlice[i] = i\n    }\n    // 扩容，所需容量超过原底层数组容量，会重新分配底层数组\n    newSlice := append(originalSlice, 2)\n    // 在原 Slice 上修改数据\n    originalSlice[0] = 100\n    // 输出新 Slice，会发现新 Slice 未发生变化\n    fmt.Println(\"New Slice:\", newSlice) \n}\n</code></pre>\n<p>在上述代码中，<code>originalSlice</code> 的初始容量为 2，当使用 <code>append</code> 函数扩容时，所需容量超过了原底层数组的容量，因此会重新分配一个新的底层数组。此时 <code>newSlice</code> 和 <code>originalSlice</code> 不再共享同一个底层数组，当在 <code>originalSlice</code> 上修改数据时，<code>newSlice</code> 不会发生变化。</p>",
    "type": 6,
    "level": 1,
    "freq": 0.001663893,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：在Go语言里，Slice扩容后在原Slice上修改数据，新Slice是否会发生变化。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Go语言Slice底层结构的理解。</li>\n      <li>Slice扩容机制的掌握。</li>\n      <li>扩容前后Slice数据存储和引用关系的认识。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Slice底层结构</h4>\n<p>Go语言的Slice是一个结构体，包含三个字段：指向底层数组的指针、当前Slice的长度和底层数组的容量。</p>\n<h4>（2）Slice扩容机制</h4>\n<p>当向Slice追加元素时，如果容量不足，Go会进行扩容。扩容时会创建一个新的更大的底层数组，将原数组的数据复制到新数组，然后让Slice指向新的底层数组。</p>\n<h3>3. 解析</h3>\n<h4>（1）扩容情况分析</h4>\n<ul>\n  <li><strong>未发生扩容</strong>：如果在追加元素时，原Slice的容量足够，不会创建新的底层数组，原Slice和新Slice（追加元素后的Slice）指向同一个底层数组。此时在原Slice上修改数据，新Slice会发生变化，因为它们共享底层数组。</li>\n  <li><strong>发生扩容</strong>：当追加元素导致原Slice容量不足时，会创建一个新的底层数组，原Slice和新Slice指向不同的底层数组。在这种情况下，在原Slice上修改数据，新Slice不会发生变化。</li>\n</ul>\n<h4>（2）扩容规则</h4>\n<p>Go语言的Slice扩容规则大致如下：</p>\n<ul>\n  <li>如果原Slice容量小于1024，新容量会翻倍。</li>\n  <li>如果原Slice容量大于等于1024，新容量会增加25%。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-go\">package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 未发生扩容的情况\n    s1 := make([]int, 2, 4)\n    s1[0] = 1\n    s1[1] = 2\n    s2 := append(s1, 3)\n    s1[0] = 100\n    fmt.Println(\"未扩容时，新Slice:\", s2)\n\n    // 发生扩容的情况\n    s3 := make([]int, 2, 2)\n    s3[0] = 1\n    s3[1] = 2\n    s4 := append(s3, 3)\n    s3[0] = 100\n    fmt.Println(\"扩容后，新Slice:\", s4)\n}\n</code></pre>\n<ul>\n  <li>在未发生扩容的例子中，<code>s1</code>和<code>s2</code>共享底层数组，修改<code>s1</code>会影响<code>s2</code>。</li>\n  <li>在发生扩容的例子中，<code>s3</code>和<code>s4</code>指向不同的底层数组，修改<code>s3</code>不会影响<code>s4</code>。</li>\n</ul>\n<h3>5. 常见误区</h3>\n<h4>（1）认为扩容后一定不共享底层数组</h4>\n<ul>\n  <li>误区：片面认为只要扩容，原Slice和新Slice就一定不共享底层数组。</li>\n  <li>纠正：要根据具体的扩容情况判断，未扩容时是共享的。</li>\n</ul>\n<h4>（2）忽略扩容规则</h4>\n<ul>\n  <li>误区：不清楚扩容时新容量的计算方式。</li>\n  <li>纠正：了解容量小于1024和大于等于1024时不同的扩容规则。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>\n  在Go语言中，Slice扩容后在原Slice上修改数据，新Slice是否会发生变化取决于是否发生了扩容。\n  如果扩容时没有创建新的底层数组（即原Slice容量足够），原Slice和新Slice共享底层数组，此时在原Slice上修改数据，新Slice会发生变化。\n  如果扩容时创建了新的底层数组（原Slice容量不足），原Slice和新Slice指向不同的底层数组，在原Slice上修改数据，新Slice不会发生变化。\n</p>\n<p>Go语言的Slice扩容规则是：当原Slice容量小于1024时，新容量会翻倍；当原Slice容量大于等于1024时，新容量会增加25%。</p>",
    "more_ask": "<h3>1. 不同扩容倍数下原 Slice 和新 Slice 的数据变化情况</h3>\n<ul>\n  <li><strong>问题</strong>：当 Go 的 Slice 扩容倍数分别为小于 2 倍、2 倍、大于 2 倍时，在原 Slice 上修改数据，新 Slice 的变化情况有什么不同？</li>\n  <li><strong>提示</strong>：回顾 Go 语言 Slice 扩容的规则，考虑不同扩容倍数时内存分配的情况，以及原 Slice 和新 Slice 是否共享底层数组。</li>\n</ul>\n<h3>2. 扩容后底层数组地址变化对数据修改的影响</h3>\n<ul>\n  <li><strong>问题</strong>：如果扩容后新 Slice 的底层数组地址发生了改变，在原 Slice 上修改数据，新 Slice 会怎样？若地址未改变呢？</li>\n  <li><strong>提示</strong>：底层数组地址改变意味着原 Slice 和新 Slice 不再共享同一个底层数组，地址未改变则共享，从这个角度分析数据修改的影响。</li>\n</ul>\n<h3>3. 扩容后对不同数据类型元素修改的情况</h3>\n<ul>\n  <li><strong>问题</strong>：对于包含基本数据类型（如 int）和引用数据类型（如 map）元素的 Slice 扩容后，在原 Slice 上修改元素，新 Slice 会有什么不同表现？</li>\n  <li><strong>提示</strong>：基本数据类型是值传递，引用数据类型传递的是引用，考虑这两种情况对 Slice 数据修改的影响。</li>\n</ul>\n<h3>4. 并发环境下 Slice 扩容及数据修改问题</h3>\n<ul>\n  <li><strong>问题</strong>：在并发环境中，对 Slice 进行扩容后，一个 goroutine 在原 Slice 上修改数据，另一个 goroutine 访问新 Slice，会出现什么问题？如何解决？</li>\n  <li><strong>提示</strong>：并发操作可能会导致数据竞争，思考 Go 语言中解决数据竞争的方法，如使用互斥锁。</li>\n</ul>\n<h3>5. 扩容后 Slice 容量和长度对数据修改的影响</h3>\n<ul>\n  <li><strong>问题</strong>：扩容后新 Slice 的容量和长度不同时，在原 Slice 上修改数据，新 Slice 的变化情况如何？例如新 Slice 长度小于容量、长度等于容量。</li>\n  <li><strong>提示</strong>：Slice 的长度决定了可访问的元素范围，容量影响是否需要再次扩容，从这两个方面分析数据修改的影响。</li>\n</ul>",
    "mindmap": "mindmap\n  root((Go语言Slice扩容后原Slice修改数据对新Slice的影响))\n    取决于底层数组是否重新分配\n      未发生底层数组重新分配\n        所需容量未超原底层数组容量\n        新老Slice共享底层数组\n        原Slice修改数据新Slice变化\n      发生底层数组重新分配\n        所需容量超原底层数组容量\n        分配新底层数组并复制数据\n        新老Slice不共享底层数组\n        原Slice修改数据新Slice不变",
    "keynote": "Go语言Slice扩容\n- 原Slice修改数据，新Slice是否变化取决于底层数组是否重新分配\n- 未重新分配：所需容量未超原容量，新老Slice共享底层数组，原改新变\n- 重新分配：所需容量超原容量，分配新数组复制数据，新老不共享，原改新不变",
    "group_id": 23,
    "kps": [
      "基本语法",
      "变量和类型"
    ],
    "years": [
      2024
    ],
    "corps": [
      "腾讯"
    ]
  }
}