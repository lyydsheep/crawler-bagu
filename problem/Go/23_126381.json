{
  "success": true,
  "data": {
    "id": 126381,
    "name": "<p>请阐述 GMP 原理，若一个 P 上的 G 阻塞了，M 会阻塞吗？P 和 M 是一一对应吗？</p>",
    "options": null,
    "answer": "<h3>GMP 原理</h3>\n<p>GMP 是 Go 语言运行时的调度模型，其中 G、M、P 分别代表不同的概念：</p>\n<ul>\n  <li><strong>G（Goroutine）</strong>：即协程，是 Go 语言中轻量级的执行单元。它由 Go 运行时管理，多个 Goroutine 可以在同一个操作系统线程上并发执行。Goroutine 有自己的栈空间、程序计数器和状态，创建和销毁的开销比操作系统线程小得多，因此可以在一个程序中创建大量的 Goroutine。</li>\n  <li><strong>M（Machine）</strong>：表示操作系统线程，是真正执行计算的实体。每个 M 都对应一个内核线程，M 负责执行 G。M 可以被阻塞，例如在进行系统调用时。</li>\n  <li><strong>P（Processor）</strong>：处理器，它是 G 和 M 之间的桥梁。P 包含了运行 Go 代码所需的资源，如调度器、本地运行队列等。P 的数量可以通过 <code>runtime.GOMAXPROCS</code> 函数进行设置，默认情况下等于 CPU 的核心数。</li>\n</ul>\n<p>调度过程如下：</p>\n<ol>\n  <li>当创建一个新的 Goroutine 时，它会被放入某个 P 的本地运行队列中。</li>\n  <li>M 会从 P 的本地运行队列中获取 G 并执行。如果本地运行队列为空，M 会尝试从全局运行队列中获取 G，或者从其他 P 的本地运行队列中“偷取” G。</li>\n  <li>当一个 G 执行完毕或者被阻塞时，M 会继续从队列中获取下一个 G 执行。</li>\n</ol>\n<h3>若一个 P 上的 G 阻塞了，M 会阻塞吗？</h3>\n<p>这取决于 G 阻塞的类型：</p>\n<ul>\n  <li><strong>系统调用阻塞</strong>：如果 G 进行系统调用（如文件读写、网络 I/O 等）而阻塞，M 会和当前的 P 分离，带着阻塞的 G 一起进入系统调用状态。此时，P 会寻找一个空闲的 M 或者创建一个新的 M 来继续执行本地运行队列中的其他 G。当系统调用完成后，阻塞的 G 会被重新放入某个 P 的运行队列中等待执行。所以，在这种情况下，M 会阻塞，但不会影响 P 继续调度其他 G。</li>\n  <li><strong>非系统调用阻塞</strong>：例如使用 <code>sync.Mutex</code> 进行加锁操作时，如果锁被其他 G 持有，当前 G 会被阻塞。这种情况下，M 不会阻塞，而是会将阻塞的 G 从运行状态移除，放入等待队列，然后继续从 P 的运行队列中获取其他 G 执行。</li>\n</ul>\n<h3>P 和 M 是一一对应吗？</h3>\n<p>P 和 M 不是一一对应的关系：</p>\n<ul>\n  <li>一个 M 同一时间只能绑定一个 P，M 必须绑定 P 才能执行 G。</li>\n  <li>一个 P 可以在不同的 M 之间切换。当 M 因为系统调用阻塞时，P 会和 M 分离，然后绑定到其他空闲的 M 上继续执行 G。</li>\n  <li>P 的数量通常由 <code>runtime.GOMAXPROCS</code> 决定，而 M 的数量是动态变化的，Go 运行时会根据需要创建和销毁 M。一般情况下，M 的数量会大于等于 P 的数量，以保证在某些 M 阻塞时，P 仍然可以有可用的 M 来执行 G。</li>\n</ul>",
    "type": 6,
    "level": 3,
    "freq": 0.001663893,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：阐述GMP原理，判断一个P上的G阻塞时M是否会阻塞，以及P和M是否一一对应。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Go语言GMP调度模型的理解。</li>\n      <li>阻塞情况下M的状态变化。</li>\n      <li>P和M的对应关系。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）GMP模型基本概念</h4>\n<ul>\n  <li><strong>G（Goroutine）</strong>：Go语言中的轻量级线程，是用户级的协程，由Go运行时管理。</li>\n  <li><strong>M（Machine）</strong>：代表操作系统线程，是真正执行计算的实体，每个M都对应一个内核线程。</li>\n  <li><strong>P（Processor）</strong>：处理器，是G和M之间的桥梁，它包含了运行Goroutine的必要资源，如调度器、本地队列等。</li>\n</ul>\n<h4>（2）调度流程</h4>\n<p>Go运行时会将G分配到P的本地队列或全局队列中，M会从P的本地队列或全局队列中获取G并执行。</p>\n<h3>3. 解析</h3>\n<h4>（1）GMP原理</h4>\n<ul>\n  <li><strong>调度器的作用</strong>：Go的调度器负责将G分配给M执行。调度器会根据一定的算法，从P的本地队列或全局队列中选择一个G，然后将其交给一个空闲的M执行。</li>\n  <li><strong>本地队列和全局队列</strong>：每个P都有一个本地队列，用于存放待执行的G。全局队列则用于存放所有P都可以获取的G。当一个M执行完一个G后，会先从P的本地队列中获取下一个G，如果本地队列为空，则会从全局队列中获取G。</li>\n  <li><strong>工作窃取算法</strong>：当一个P的本地队列为空时，它会从其他P的本地队列中“窃取”一半的G到自己的本地队列中，以保证各个P的负载均衡。</li>\n</ul>\n<h4>（2）一个P上的G阻塞时M的状态</h4>\n<ul>\n  <li>当一个P上的G阻塞时，M不一定会阻塞。如果G是因为系统调用而阻塞，M会和当前的P分离，带着阻塞的G进入系统调用状态。此时，P会寻找一个空闲的M或者创建一个新的M来继续执行其他G。当阻塞的G完成系统调用后，它会尝试重新绑定到一个P上继续执行。</li>\n  <li>如果G是因为其他原因（如等待锁）而阻塞，M会继续在P上执行其他G，直到阻塞的G可以继续执行。</li>\n</ul>\n<h4>（3）P和M的对应关系</h4>\n<ul>\n  <li>P和M不是一一对应的。在Go运行时，M的数量通常会比P的数量多，因为可能会有一些M处于空闲状态或者正在执行系统调用。P的数量可以通过<code>runtime.GOMAXPROCS</code>函数来设置，它表示可以同时执行的M的最大数量。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n    \"time\"\n)\n\nfunc main() {\n    runtime.GOMAXPROCS(2) // 设置P的数量为2\n\n    go func() {\n        fmt.Println(\"Goroutine 1 started\")\n        time.Sleep(2 * time.Second) // 模拟阻塞\n        fmt.Println(\"Goroutine 1 finished\")\n    }()\n\n    go func() {\n        fmt.Println(\"Goroutine 2 started\")\n        time.Sleep(1 * time.Second)\n        fmt.Println(\"Goroutine 2 finished\")\n    }()\n\n    time.Sleep(3 * time.Second)\n}\n</code></pre>\n<ul>\n  <li>在这个例子中，设置了P的数量为2，启动了两个Goroutine。其中一个Goroutine会阻塞2秒，另一个Goroutine会阻塞1秒。由于P的数量为2，两个Goroutine可以同时在不同的P上执行。</li>\n</ul>\n<h3>5. 常见误区</h3>\n<h4>（1）认为M和P一一对应</h4>\n<ul>\n  <li>误区：错误地认为每个M都对应一个P，并且它们是固定绑定的。</li>\n  <li>纠正：M和P的对应关系是动态的，M可以和不同的P绑定，并且可能会有多个M处于空闲状态。</li>\n</ul>\n<h4>（2）认为G阻塞时M一定会阻塞</h4>\n<ul>\n  <li>误区：认为当一个G阻塞时，对应的M也会阻塞，导致整个P无法继续执行其他G。</li>\n  <li>纠正：当G因为系统调用而阻塞时，M会和P分离，P会寻找其他M继续执行其他G；当G因为其他原因阻塞时，M会继续执行其他G。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“GMP是Go语言的调度模型，其中G代表Goroutine，是用户级的协程；M代表操作系统线程，是真正执行计算的实体；P代表处理器，是G和M之间的桥梁。调度器会将G分配到P的本地队列或全局队列中，M会从P的本地队列或全局队列中获取G并执行。当一个P的本地队列为空时，会使用工作窃取算法从其他P的本地队列中窃取G。</p>\n<p>当一个P上的G阻塞时，M不一定会阻塞。如果G是因为系统调用而阻塞，M会和当前的P分离，带着阻塞的G进入系统调用状态，P会寻找一个空闲的M或者创建一个新的M来继续执行其他G；如果G是因为其他原因（如等待锁）而阻塞，M会继续在P上执行其他G。</p>\n<p>P和M不是一一对应的。M的数量通常会比P的数量多，P的数量可以通过<code>runtime.GOMAXPROCS</code>函数来设置，它表示可以同时执行的M的最大数量。”</p>",
    "more_ask": "<h3>关于 GMP 原理的深入问题</h3>\n<ol>\n  <li><strong>G 阻塞时 M 的调度细节</strong>\n    <ul>\n      <li><strong>问题</strong>：当一个 P 上的 G 阻塞时，M 若不阻塞，它是如何快速找到新的可运行 G 来执行的？</li>\n      <li><strong>提示</strong>：思考调度器的全局队列和其他 P 的本地队列，以及调度器的工作窃取机制。</li>\n    </ul>\n  </li>\n  <li><strong>GMP 中的内存管理</strong>\n    <ul>\n      <li><strong>问题</strong>：在 GMP 模型下，G、M、P 各自的内存分配和释放是如何管理的，对系统性能有什么影响？</li>\n      <li><strong>提示</strong>：考虑 Go 语言的内存分配器，以及 G、M、P 的生命周期和内存使用特点。</li>\n    </ul>\n  </li>\n  <li><strong>P 和 M 的动态关系</strong>\n    <ul>\n      <li><strong>问题</strong>：在高并发场景下，P 和 M 的数量会动态调整，这种调整是基于什么策略进行的？</li>\n      <li><strong>提示</strong>：关注系统的负载情况，如 CPU 利用率、G 的数量和状态等因素。</li>\n    </ul>\n  </li>\n  <li><strong>G 的状态转换</strong>\n    <ul>\n      <li><strong>问题</strong>：G 在运行过程中会经历多种状态转换，如就绪、运行、阻塞等，这些状态转换是如何触发和管理的？</li>\n      <li><strong>提示</strong>：结合 GMP 模型的调度机制，考虑系统调用、锁操作等情况。</li>\n    </ul>\n  </li>\n  <li><strong>GMP 与多核 CPU 的协同</strong>\n    <ul>\n      <li><strong>问题</strong>：GMP 模型是如何充分利用多核 CPU 的性能的，在多核环境下有哪些优化策略？</li>\n      <li><strong>提示</strong>：思考多个 P 如何在不同的 CPU 核心上并行执行，以及调度器如何平衡负载。</li>\n    </ul>\n  </li>\n  <li><strong>M 的创建和销毁</strong>\n    <ul>\n      <li><strong>问题</strong>：M 的创建和销毁是由什么条件触发的，如何避免频繁创建和销毁 M 带来的性能开销？</li>\n      <li><strong>提示</strong>：考虑系统的并发需求、G 的数量和状态等因素。</li>\n    </ul>\n  </li>\n  <li><strong>P 的空闲处理</strong>\n    <ul>\n      <li><strong>问题</strong>：当一个 P 处于空闲状态时，它会做什么，如何保证资源的有效利用？</li>\n      <li><strong>提示</strong>：思考 P 与调度器的交互，以及是否会将空闲 P 上的资源分配给其他需要的 M。</li>\n    </ul>\n  </li>\n  <li><strong>GMP 中的锁机制</strong>\n    <ul>\n      <li><strong>问题</strong>：在 GMP 模型中，哪些地方会使用锁，锁的使用对系统性能有什么影响，如何优化？</li>\n      <li><strong>提示</strong>：考虑调度器的全局队列、P 的本地队列等共享资源的访问。</li>\n    </ul>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((GMP 原理))\n    GMP 概念\n      G（Goroutine）\n        轻量级执行单元\n        由 Go 运行时管理\n        多个并发于同一线程\n        开销小可大量创建\n      M（Machine）\n        操作系统线程\n        对应内核线程\n        负责执行 G\n        可被阻塞\n      P（Processor）\n        G 和 M 桥梁\n        含调度器等资源\n        数量可设置\n    调度过程\n      新 Goroutine 入 P 本地队列\n      M 从 P 本地队列取 G 执行\n      本地空则从全局或偷取 G\n      G 结束或阻塞 M 取下个 G\n    若 G 阻塞 M 是否阻塞\n      系统调用阻塞\n        M 与 P 分离\n        P 找新 M 继续调度\n        G 完成后重入队列\n      非系统调用阻塞\n        M 不阻塞\n        G 入等待队列\n        M 继续取 G 执行\n    P 和 M 关系\n      非一一对应\n      一个 M 同一时间绑一个 P\n      一个 P 可在不同 M 间切换\n      P 数量由 runtime.GOMAXPROCS 决定\n      M 数量动态变化",
    "keynote": "GMP 概念：G 是协程，轻量级执行单元；M 是操作系统线程；P 是 G 和 M 桥梁\n调度过程：新 G 入 P 本地队列，M 取 G 执行，本地空则从全局或偷取\nG 阻塞情况：系统调用阻塞 M 与 P 分离，P 找新 M；非系统调用阻塞 M 不阻塞\nP 和 M 关系：非一一对应，M 同一时间绑一个 P，P 可在 M 间切换，P 数量可设，M 数量动态变化",
    "group_id": 23,
    "kps": [
      "并发编程",
      "编译和运行时"
    ],
    "years": [
      2024
    ],
    "corps": [
      "快手"
    ]
  }
}