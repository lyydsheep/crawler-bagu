{
  "success": true,
  "data": {
    "id": 45653,
    "name": "<p>channel在什么情况下会发生阻塞，其阻塞是如何实现的</p>",
    "options": null,
    "answer": "<h3>channel发生阻塞的情况</h3>\n<h4>无缓冲channel</h4>\n<ul>\n  <li><strong>发送操作阻塞</strong>：当向一个无缓冲的channel发送数据时，如果没有对应的接收操作在等待接收该数据，发送操作就会阻塞。这是因为无缓冲channel要求发送和接收操作必须同时进行，数据不会在channel中停留。例如：</li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nfunc main() {\n    ch := make(chan int)\n    // 这里会阻塞，因为没有接收者\n    ch &#x3C;- 1 \n}\n</code></pre>\n<ul>\n  <li><strong>接收操作阻塞</strong>：当从一个无缓冲的channel接收数据时，如果没有对应的发送操作在等待发送数据，接收操作就会阻塞。例如：</li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nfunc main() {\n    ch := make(chan int)\n    // 这里会阻塞，因为没有发送者\n    &#x3C;-ch \n}\n</code></pre>\n<h4>有缓冲channel</h4>\n<ul>\n  <li><strong>发送操作阻塞</strong>：当向一个有缓冲的channel发送数据时，如果channel的缓冲区已满，发送操作就会阻塞，直到有数据被从channel中接收，腾出缓冲区空间。例如：</li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nfunc main() {\n    ch := make(chan int, 1)\n    ch &#x3C;- 1\n    // 这里会阻塞，因为缓冲区已满\n    ch &#x3C;- 2 \n}\n</code></pre>\n<ul>\n  <li><strong>接收操作阻塞</strong>：当从一个有缓冲的channel接收数据时，如果channel的缓冲区为空，接收操作就会阻塞，直到有新的数据被发送到channel中。例如：</li>\n</ul>\n<pre><code class=\"language-go\">package main\n\nfunc main() {\n    ch := make(chan int, 1)\n    // 这里会阻塞，因为缓冲区为空\n    &#x3C;-ch \n}\n</code></pre>\n<h4>已关闭的channel</h4>\n<ul>\n  <li>向已关闭的channel发送数据会导致panic，而不是阻塞。但如果尝试从一个已关闭且缓冲区为空的channel接收数据，不会阻塞，而是会立即返回该channel元素类型的零值。</li>\n</ul>\n<h3>channel阻塞的实现原理</h3>\n<p>Go语言的channel阻塞是通过运行时调度器和底层的数据结构来实现的。</p>\n<h4>底层数据结构</h4>\n<p>channel在Go语言的运行时中使用<code>hchan</code>结构体来表示，该结构体包含了缓冲区、发送队列、接收队列等重要信息。例如：</p>\n<pre><code class=\"language-go\">type hchan struct {\n    qcount   uint           // 当前缓冲区中的元素数量\n    dataqsiz uint           // 缓冲区的大小\n    buf      unsafe.Pointer // 缓冲区的指针\n    sendx    uint           // 发送操作的索引\n    recvx    uint           // 接收操作的索引\n    recvq    waitq          // 接收者等待队列\n    sendq    waitq          // 发送者等待队列\n    // 其他字段...\n}\n</code></pre>\n<h4>阻塞过程</h4>\n<ul>\n  <li><strong>发送操作阻塞</strong>：当执行发送操作时，运行时会检查channel的缓冲区是否有空间。如果是无缓冲channel或者缓冲区已满，发送操作对应的goroutine会被封装成一个<code>sudog</code>结构体，并加入到<code>sendq</code>队列中，然后该goroutine会被标记为阻塞状态，调度器会将其从运行队列中移除，让出CPU资源。</li>\n  <li><strong>接收操作阻塞</strong>：当执行接收操作时，运行时会检查channel的缓冲区是否有数据。如果是无缓冲channel或者缓冲区为空，接收操作对应的goroutine会被封装成一个<code>sudog</code>结构体，并加入到<code>recvq</code>队列中，然后该goroutine会被标记为阻塞状态，调度器会将其从运行队列中移除，让出CPU资源。</li>\n</ul>\n<h4>解除阻塞</h4>\n<ul>\n  <li>当有对应的接收操作从无缓冲channel接收数据或者从有缓冲channel中接收数据腾出空间时，<code>sendq</code>队列中的第一个发送者goroutine会被唤醒，继续执行发送操作。</li>\n  <li>当有对应的发送操作向无缓冲channel发送数据或者向有缓冲channel中发送数据时，<code>recvq</code>队列中的第一个接收者goroutine会被唤醒，继续执行接收操作。</li>\n</ul>",
    "type": 6,
    "level": 2,
    "freq": 0.009983361,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：channel在什么情况下会发生阻塞，以及阻塞是如何实现的。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Go语言中channel特性的理解。</li>\n      <li>不同类型channel（无缓冲和有缓冲）的阻塞条件。</li>\n      <li>Go语言运行时对channel阻塞的底层实现机制。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）channel的基本概念</h4>\n<ul>\n  <li>channel是Go语言中用于在不同goroutine之间进行通信和同步的重要机制。它可以看作是一个类型安全的管道，允许数据在不同的goroutine之间传递。</li>\n  <li>分为无缓冲channel和有缓冲channel。无缓冲channel没有容量，有缓冲channel有一定的容量。</li>\n</ul>\n<h4>（2）阻塞的含义</h4>\n<ul>\n  <li>在Go中，当一个操作无法立即完成时，goroutine会被阻塞，即暂停执行，直到条件满足可以继续执行为止。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）channel发生阻塞的情况</h4>\n<ul>\n  <li><strong>无缓冲channel</strong>\n    <ul>\n      <li><strong>发送操作阻塞</strong>：当向无缓冲channel发送数据时，如果没有其他goroutine正在等待从该channel接收数据，发送操作会阻塞当前goroutine，直到有其他goroutine从该channel接收数据。</li>\n      <li><strong>接收操作阻塞</strong>：当从无缓冲channel接收数据时，如果没有其他goroutine正在等待向该channel发送数据，接收操作会阻塞当前goroutine，直到有其他goroutine向该channel发送数据。</li>\n    </ul>\n  </li>\n  <li><strong>有缓冲channel</strong>\n    <ul>\n      <li><strong>发送操作阻塞</strong>：当向有缓冲channel发送数据时，如果channel已满（即缓冲区中的元素数量达到了其容量），发送操作会阻塞当前goroutine，直到有其他goroutine从该channel接收数据，腾出缓冲区空间。</li>\n      <li><strong>接收操作阻塞</strong>：当从有缓冲channel接收数据时，如果channel为空（即缓冲区中没有元素），接收操作会阻塞当前goroutine，直到有其他goroutine向该channel发送数据。</li>\n    </ul>\n  </li>\n</ul>\n<h4>（2）channel阻塞的实现机制</h4>\n<ul>\n  <li>Go语言的运行时系统负责管理channel的阻塞和唤醒操作。</li>\n  <li>当一个goroutine在channel上的操作（发送或接收）无法立即完成时，运行时会将该goroutine从可运行队列中移除，并将其加入到channel的等待队列中。</li>\n  <li>当满足操作条件时（如无缓冲channel有接收方等待、有缓冲channel有空间或有数据），运行时会从等待队列中取出相应的goroutine，并将其重新加入到可运行队列中，使其继续执行。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc sender(ch chan int) {\n    time.Sleep(2 * time.Second)\n    ch &#x3C;- 10\n    fmt.Println(\"Sent data to channel\")\n}\n\nfunc main() {\n    ch := make(chan int)\n    go sender(ch)\n    fmt.Println(\"Waiting to receive data...\")\n    data := &#x3C;-ch\n    fmt.Printf(\"Received data: %d\\n\", data)\n}\n</code></pre>\n<ul>\n  <li>在这个例子中，<code>main</code>函数中的接收操作<code>&#x3C;-ch</code>会阻塞，因为没有数据发送到<code>ch</code>中。<code>sender</code> goroutine在2秒后向<code>ch</code>发送数据，此时<code>main</code>函数中的接收操作会被唤醒，继续执行后续代码。</li>\n</ul>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆无缓冲和有缓冲channel的阻塞条件</h4>\n<ul>\n  <li>误区：认为有缓冲channel和无缓冲channel的阻塞条件相同。</li>\n  <li>纠正：明确无缓冲channel在发送和接收时都需要有对应的操作才能不阻塞，而有缓冲channel在缓冲区满或空时才会阻塞。</li>\n</ul>\n<h4>（2）不理解阻塞的底层实现</h4>\n<ul>\n  <li>误区：只知道channel会阻塞，但不清楚是如何实现的。</li>\n  <li>纠正：了解Go运行时通过管理goroutine的等待队列来实现channel的阻塞和唤醒。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“在Go语言中，channel在以下情况下会发生阻塞：</p>\n<ul>\n  <li>无缓冲channel：发送操作在没有接收方等待时阻塞，接收操作在没有发送方等待时阻塞。</li>\n  <li>有缓冲channel：发送操作在缓冲区已满时阻塞，接收操作在缓冲区为空时阻塞。</li>\n</ul>\n<p>channel阻塞的实现是由Go语言的运行时系统完成的。当一个goroutine在channel上的操作无法立即完成时，运行时会将该goroutine从可运行队列中移除，并将其加入到channel的等待队列中。当满足操作条件时，运行时会从等待队列中取出相应的goroutine，并将其重新加入到可运行队列中，使其继续执行。”</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      当向一个已满的无缓冲channel和有缓冲channel发送数据时，阻塞机制有什么不同的底层实现细节？\n      提示：思考无缓冲和有缓冲channel在数据存储和状态管理上的差异。\n    </p>\n  </li>\n  <li>\n    <p>\n      若在一个goroutine中同时对多个channel进行读写操作，使用<code>select</code>语句时，当所有channel都不满足操作条件，会发生什么？这种阻塞和单个channel阻塞有何联系和区别？\n      提示：考虑<code>select</code>语句的特性以及它与单个channel阻塞的底层逻辑对比。\n    </p>\n  </li>\n  <li>\n    <p>\n      当一个channel被关闭后，再向其发送数据会发生什么？接收数据呢？这两种情况和正常的阻塞情况有什么本质区别？\n      提示：了解channel关闭后的状态变化以及对读写操作的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      在并发场景下，多个goroutine同时尝试向同一个channel发送数据，当channel已满时，这些goroutine的阻塞顺序是怎样的？如何验证这种顺序？\n      提示：思考Go语言对并发阻塞的调度策略和验证方法。\n    </p>\n  </li>\n  <li>\n    <p>\n      对于有缓冲的channel，当缓冲区内数据量达到上限后，若有一个goroutine从该channel接收数据，此时原本因发送数据而阻塞的goroutine是如何被唤醒的？\n      提示：关注channel内部的状态管理和唤醒机制。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((channel发生阻塞的情况及原理))\n    channel发生阻塞的情况\n      无缓冲channel\n        发送操作阻塞\n        接收操作阻塞\n      有缓冲channel\n        发送操作阻塞\n        接收操作阻塞\n      已关闭的channel\n        发送数据导致panic\n        接收空缓冲区返回零值\n    channel阻塞的实现原理\n      底层数据结构\n        hchan结构体\n      阻塞过程\n        发送操作阻塞\n        接收操作阻塞\n      解除阻塞\n        发送者goroutine唤醒\n        接收者goroutine唤醒",
    "keynote": "channel阻塞情况：\n- 无缓冲channel：发送无接收者、接收无发送者时阻塞\n- 有缓冲channel：发送时缓冲区满、接收时缓冲区空阻塞\n- 已关闭channel：发送致panic，接收空缓冲返回零值\n\nchannel阻塞原理：\n- 底层结构：hchan结构体\n- 阻塞过程：发送无空间、接收无数据时goroutine入队阻塞\n- 解除阻塞：对应操作使队列中goroutine唤醒",
    "group_id": 23,
    "kps": [
      "并发编程"
    ],
    "years": [
      2024,
      2023
    ],
    "corps": [
      "快手",
      "腾讯",
      "百度",
      "腾讯互娱"
    ]
  }
}