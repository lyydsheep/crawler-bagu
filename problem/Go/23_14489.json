{
  "success": true,
  "data": {
    "id": 14489,
    "name": "<p>阐述Go协程调度的底层原理</p>",
    "options": null,
    "answer": "<p>Go 协程调度的底层原理基于 GPM 模型，下面详细阐述其各部分及调度过程。</p>\n<h3>GPM 模型基本概念</h3>\n<ul>\n  <li><strong>G（Goroutine）</strong>：即 Go 协程，是用户级的轻量级线程，由 Go 语言运行时管理。每个 G 都有自己的栈空间、指令指针以及其他用于调度和恢复执行的信息。</li>\n  <li><strong>P（Processor）</strong>：处理器，代表执行 Go 代码所需的资源，它是 G 和 M 之间的桥梁。每个 P 都有一个本地的 G 队列，用于存放待执行的 G。P 的数量通常由环境变量 <code>GOMAXPROCS</code> 决定，默认情况下等于 CPU 核心数。</li>\n  <li><strong>M（Machine）</strong>：代表操作系统线程，是真正执行计算的实体。每个 M 都需要绑定一个 P 才能执行 G，M 会从 P 的本地队列或全局队列中获取 G 来执行。</li>\n</ul>\n<h3>调度过程</h3>\n<ol>\n  <li><strong>创建 G</strong>：当使用 <code>go</code> 关键字创建一个新的协程时，会在当前 P 的本地队列中创建一个新的 G 对象，并将其放入本地队列尾部。</li>\n  <li><strong>M 获取 G</strong>：M 会优先从绑定的 P 的本地队列中获取 G 来执行。如果本地队列为空，M 会尝试从全局队列中获取一批 G 到本地队列。若全局队列也为空，M 会随机从其他 P 的本地队列中“偷取”一半的 G 到自己绑定的 P 的本地队列，这种机制称为“工作窃取”。</li>\n  <li><strong>G 执行</strong>：M 从队列中取出一个 G 并执行，在执行过程中，G 可能会因为系统调用、阻塞操作等原因暂停执行。</li>\n  <li><strong>系统调用处理</strong>：当 G 进行系统调用时，如果该系统调用可能会阻塞 M，M 会与当前绑定的 P 解绑，将 P 交给其他空闲的 M 或者放入空闲 P 列表。G 会在系统调用完成后，重新加入到某个 P 的本地队列等待执行。</li>\n  <li><strong>调度器的监控</strong>：Go 运行时系统有一个监控线程，会定期检查是否有长时间运行的 G，以防止某个 G 长时间占用 M，导致其他 G 无法执行。如果发现长时间运行的 G，调度器会将其暂停，放入队列尾部，让其他 G 有机会执行。</li>\n</ol>\n<h3>调度器的优势</h3>\n<ul>\n  <li><strong>高效利用资源</strong>：通过工作窃取机制，能够充分利用多核 CPU 的计算能力，避免某个 P 的本地队列任务过多，而其他 P 空闲的情况。</li>\n  <li><strong>轻量级调度</strong>：G 是用户级线程，创建和销毁的开销远小于操作系统线程，调度也更加灵活，减少了上下文切换的开销。</li>\n  <li><strong>并发处理能力强</strong>：可以轻松创建大量的 G，实现高并发的程序，而不会因为创建过多的操作系统线程导致系统资源耗尽。</li>\n</ul>\n<p>综上所述，Go 协程调度的底层原理基于 GPM 模型，通过合理的调度算法和机制，实现了高效的并发处理和资源利用。</p>",
    "type": 6,
    "level": 3,
    "freq": 0.03826955,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：阐述Go协程调度的底层原理。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Go协程概念的理解。</li>\n      <li>Go协程调度器的组成结构。</li>\n      <li>调度器的工作流程和调度策略。</li>\n      <li>与操作系统线程的关系。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Go协程</h4>\n<ul>\n  <li>Go协程（goroutine）是一种轻量级的线程，由Go运行时管理。与操作系统线程相比，它的创建和销毁开销小，占用内存少，可以在一个Go程序中创建大量的协程。</li>\n</ul>\n<h4>（2）调度器的必要性</h4>\n<ul>\n  <li>由于Go协程数量可能远超操作系统线程数量，需要一个调度器来合理地将协程分配到操作系统线程上执行，以提高并发性能。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）调度器的组成结构</h4>\n<ul>\n  <li><strong>G（Goroutine）</strong>：表示一个协程，包含协程的栈、程序计数器、状态等信息。</li>\n  <li><strong>M（Machine）</strong>：代表一个操作系统线程，每个M都有自己的执行栈。</li>\n  <li><strong>P（Processor）</strong>：处理器，是调度器的上下文，负责将G和M进行匹配。每个P都有一个本地的G队列，还可以从全局G队列中获取G。</li>\n</ul>\n<h4>（2）调度器的工作流程</h4>\n<ul>\n  <li><strong>启动阶段</strong>：程序启动时，会创建一定数量的M和P，M和P会进行绑定。</li>\n  <li><strong>协程创建</strong>：当创建一个新的G时，它会被放入创建它的P的本地G队列中。</li>\n  <li><strong>调度执行</strong>：M会从绑定的P的本地G队列中取出一个G并执行。如果本地G队列为空，M会尝试从全局G队列中获取G，或者从其他P的本地G队列中“偷取”G。</li>\n  <li><strong>阻塞和唤醒</strong>：当一个G发生阻塞（如进行I/O操作）时，M会和当前的P解绑，将G放入阻塞队列，然后M可以去执行其他P的G。当G阻塞结束后，会被重新放入某个P的本地G队列等待执行。</li>\n</ul>\n<h4>（3）调度策略</h4>\n<ul>\n  <li><strong>本地队列优先</strong>：M优先从绑定的P的本地G队列中获取G，减少锁的竞争。</li>\n  <li><strong>工作窃取</strong>：当本地G队列为空时，M会从其他P的本地G队列中“偷取”一半的G，以保证负载均衡。</li>\n  <li><strong>全局队列辅助</strong>：全局G队列用于存储新创建的G和从阻塞状态恢复的G，M在本地队列和其他P的队列都没有G时，会从全局队列中获取G。</li>\n</ul>\n<h4>（4）与操作系统线程的关系</h4>\n<ul>\n  <li>Go协程是在操作系统线程之上的抽象，多个G可以复用一个M，通过P的调度实现高效的并发。这种设计减少了操作系统线程的创建和切换开销，提高了程序的并发性能。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc worker(id int) {\n    fmt.Printf(\"Worker %d starting\\n\", id)\n    time.Sleep(time.Second)\n    fmt.Printf(\"Worker %d done\\n\", id)\n}\n\nfunc main() {\n    for i := 1; i &#x3C;= 5; i++ {\n        go worker(i)\n    }\n    time.Sleep(2 * time.Second)\n}\n</code></pre>\n<ul>\n  <li>在这个例子中，创建了5个协程，调度器会将这些协程分配到操作系统线程上执行。由于协程是轻量级的，程序可以高效地并发执行这些任务。</li>\n</ul>\n<h3>5. 常见误区</h3>\n<h4>（1）将Go协程等同于操作系统线程</h4>\n<ul>\n  <li>误区：认为Go协程就是操作系统线程，忽略了Go调度器的作用。</li>\n  <li>纠正：Go协程是由Go运行时管理的轻量级线程，通过调度器在操作系统线程上复用，减少了线程创建和切换的开销。</li>\n</ul>\n<h4>（2）忽视P的作用</h4>\n<ul>\n  <li>误区：只关注G和M，忽略了P在调度中的重要性。</li>\n  <li>纠正：P是调度器的上下文，负责将G和M进行匹配，本地G队列和工作窃取等调度策略都依赖于P。</li>\n</ul>\n<h4>（3）不理解工作窃取机制</h4>\n<ul>\n  <li>误区：不清楚工作窃取机制的作用和原理。</li>\n  <li>纠正：工作窃取机制是为了实现负载均衡，当某个P的本地G队列空闲时，M会从其他P的本地G队列中“偷取”G，提高系统的并发性能。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“Go协程调度的底层原理基于调度器的三个核心组件：G（Goroutine）、M（Machine）和P（Processor）。G代表协程，M代表操作系统线程，P是调度器的上下文。</p>\n<p>程序启动时会创建一定数量的M和P并进行绑定。新创建的G会被放入创建它的P的本地G队列。M从绑定的P的本地G队列中取出G并执行，若本地队列为空，会尝试从全局G队列或其他P的本地G队列中获取G。</p>\n<p>调度策略上，优先从本地队列获取G以减少锁竞争，采用工作窃取机制实现负载均衡，全局队列辅助存储新创建和恢复的G。</p>\n<p>当G发生阻塞时，M会和当前P解绑，将G放入阻塞队列，阻塞结束后G会被重新放入某个P的本地G队列。</p>\n<p>Go协程是在操作系统线程之上的抽象，通过调度器实现多个G复用一个M，减少了操作系统线程的创建和切换开销，提高了并发性能。</p>\n<p>需要注意的是，不能将Go协程等同于操作系统线程，要重视P在调度中的作用，理解工作窃取机制对负载均衡的意义。”</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      请详细说明Go调度器中G、M、P模型在系统负载过高时的动态调整机制。\n      提示：思考系统负载过高时，G、M、P的数量和状态会如何变化以应对。\n    </p>\n  </li>\n  <li>\n    <p>\n      阐述Go协程调度中工作窃取算法的具体实现和优势。\n      提示：关注工作窃取算法如何在不同P之间转移G，以及这样做带来的好处。\n    </p>\n  </li>\n  <li>\n    <p>\n      当一个Go协程进行系统调用时，调度器是如何处理的？\n      提示：考虑系统调用对G、M、P状态的影响以及调度器的后续操作。\n    </p>\n  </li>\n  <li>\n    <p>\n      解释Go调度器中的自旋线程的作用和使用场景。\n      提示：思考自旋线程在什么情况下会被使用以及它对调度性能的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      如何在Go代码中观察和分析协程调度的性能？\n      提示：可以从Go提供的工具和监控指标方面去思考。\n    </p>\n  </li>\n  <li>\n    <p>\n      对比Go协程调度和传统线程调度，它们在上下文切换上有什么区别？\n      提示：关注上下文切换的开销、速度等方面的差异。\n    </p>\n  </li>\n  <li>\n    <p>\n      说明Go调度器中全局队列和本地队列的作用和交互方式。\n      提示：思考不同队列存储的G的类型以及它们之间如何协同工作。\n    </p>\n  </li>\n  <li>\n    <p>\n      当Go程序运行在多核CPU上时，调度器是如何充分利用多核资源的？\n      提示：考虑G、M、P在多核环境下的分配和调度策略。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Go协程调度的底层原理 - GPM模型))\n    GPM模型基本概念\n      G（Goroutine）\n        用户级轻量级线程\n        有自己的栈空间等信息\n      P（Processor）\n        执行Go代码资源\n        是G和M的桥梁\n        有本地G队列\n        数量由GOMAXPROCS决定\n      M（Machine）\n        操作系统线程\n        需绑定P执行G\n        从P本地或全局队列获取G\n    调度过程\n      创建G\n        在当前P本地队列创建并放尾部\n      M获取G\n        优先从绑定P本地队列获取\n        本地空则从全局队列获取\n        全局空则“工作窃取”\n      G执行\n        可能因系统调用等暂停\n      系统调用处理\n        M与P解绑\n        G完成后重新加入P本地队列\n      调度器的监控\n        检查长时间运行的G\n        暂停并放队列尾部\n    调度器的优势\n      高效利用资源\n        工作窃取机制利用多核\n      轻量级调度\n        创建销毁开销小\n        调度灵活\n      并发处理能力强\n        可创建大量G",
    "keynote": "GPM模型基本概念：\n- G：用户级轻量级线程，有栈空间等信息\n- P：执行资源，G和M桥梁，有本地队列，数量由GOMAXPROCS定\n- M：操作系统线程，绑定P执行G，从队列取G\n\n调度过程：\n- 创建G：在当前P本地队列创建放尾部\n- M获取G：优先本地，本地空取全局，全局空“工作窃取”\n- G执行：可能因系统调用等暂停\n- 系统调用处理：M与P解绑，G完成后重入队列\n- 调度器监控：检查长时运行G，暂停放尾部\n\n调度器优势：\n- 高效利用资源：工作窃取用多核\n- 轻量级调度：创建销毁开销小，调度灵活\n- 并发处理能力强：可创建大量G",
    "group_id": 23,
    "kps": [
      "并发编程",
      "编译和运行时"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "腾讯音乐",
      "小米",
      "字节跳动",
      "阿里云",
      "腾讯云智",
      "腾讯",
      "富途",
      "金山",
      "字节国际",
      "好未来",
      "联想集团",
      "滴滴",
      "深信服",
      "猿辅导",
      "B站",
      "字节飞书"
    ]
  }
}