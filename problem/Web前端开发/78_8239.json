{
  "success": true,
  "data": {
    "id": 8239,
    "name": "<p>宏任务和微任务分别有哪些</p>",
    "options": null,
    "answer": "<p>在 Web 浏览器中，宏任务（macro tasks）和微任务（micro tasks）是两种不同的任务调度机制。它们的主要区分在于任务的优先级和执行的时机。</p>\n<h3>宏任务（Macro Tasks）</h3>\n<p>宏任务是较大的任务单位，它们通常由浏览器的事件循环处理。宏任务一般包括：</p>\n<ul>\n  <li><code>setTimeout</code></li>\n  <li><code>setInterval</code></li>\n  <li>I/O 操作（如文件读取或网络请求）</li>\n  <li>用户的事件（如点击、输入、滚动等）</li>\n  <li><code>requestAnimationFrame</code></li>\n</ul>\n<p>每完成一个宏任务后，浏览器会检查微任务队列，然后执行微任务。</p>\n<h3>微任务（Micro Tasks）</h3>\n<p>微任务是较小的任务单位，执行优先级高于宏任务。微任务一般包括：</p>\n<ul>\n  <li><code>Promise</code> 的 <code>then</code>、<code>catch</code>、<code>finally</code> 回调</li>\n  <li><code>MutationObserver</code> 的回调</li>\n  <li><code>queueMicrotask</code> 中的任务</li>\n</ul>\n<p>微任务在执行完当前宏任务后立即执行，直到微任务队列为空，这些微任务在下一个宏任务开始之前会被处理。</p>\n<h3>调度顺序</h3>\n<ol>\n  <li>执行一个宏任务。</li>\n  <li>执行所有微任务（执行微任务直到队列清空）。</li>\n  <li>再次检查宏任务队列，执行下一个宏任务。</li>\n</ol>\n<p>这样的机制确保了高优先级的任务（微任务）能够在低优先级的任务（宏任务）之前执行，有助于提升性能和响应速度。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.0009569378,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：宏任务和微任务分别包含哪些。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对宏任务和微任务概念的理解。</li>\n      <li>对常见宏任务和微任务类型的掌握。</li>\n      <li>对事件循环机制中宏任务和微任务执行顺序的关联理解。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）事件循环机制</h4>\n<p>JavaScript是单线程执行的，为了处理异步操作，引入了事件循环机制。事件循环主要处理任务队列中的任务，任务队列分为宏任务队列和微任务队列。</p>\n<h4>（2）宏任务和微任务的区别</h4>\n<p>宏任务和微任务在事件循环中的执行顺序不同。每次事件循环开始时，会从宏任务队列中取出一个宏任务执行，执行完宏任务后，会将微任务队列中的所有微任务依次执行完，然后再开始下一次事件循环，继续从宏任务队列中取任务执行。</p>\n<h3>3. 解析</h3>\n<h4>（1）常见的宏任务</h4>\n<ul>\n  <li><strong><code>setTimeout</code></strong>：用于在指定的延迟时间后执行回调函数。例如：</li>\n</ul>\n<pre><code class=\"language-javascript\">setTimeout(() => {\n    console.log('这是一个setTimeout宏任务');\n}, 1000);\n</code></pre>\n<ul>\n  <li><strong><code>setInterval</code></strong>：用于按照指定的时间间隔重复执行回调函数。例如：</li>\n</ul>\n<pre><code class=\"language-javascript\">setInterval(() => {\n    console.log('这是一个setInterval宏任务');\n}, 2000);\n</code></pre>\n<ul>\n  <li><strong><code>setImmediate</code>（Node.js环境）</strong>：在Node.js中，<code>setImmediate</code>用于在当前I/O周期结束后执行回调函数。例如：</li>\n</ul>\n<pre><code class=\"language-javascript\">setImmediate(() => {\n    console.log('这是一个setImmediate宏任务');\n});\n</code></pre>\n<ul>\n  <li><strong><code>requestAnimationFrame</code>（浏览器环境）</strong>：用于在浏览器下一次重绘之前执行回调函数，通常用于实现流畅的动画效果。例如：</li>\n</ul>\n<pre><code class=\"language-javascript\">function animate() {\n    console.log('这是一个requestAnimationFrame宏任务');\n    requestAnimationFrame(animate);\n}\nrequestAnimationFrame(animate);\n</code></pre>\n<ul>\n  <li><strong>I/O操作</strong>：像文件读取、网络请求等I/O操作完成后的回调函数通常也是宏任务。例如使用<code>fetch</code>进行网络请求：</li>\n</ul>\n<pre><code class=\"language-javascript\">fetch('https://example.com')\n .then(response => response.text())\n .then(data => console.log(data));\n</code></pre>\n<h4>（2）常见的微任务</h4>\n<ul>\n  <li><strong><code>Promise.then</code> 和 <code>Promise.catch</code></strong>：当Promise的状态发生改变时，对应的<code>then</code>或<code>catch</code>方法中的回调函数会作为微任务被添加到微任务队列中。例如：</li>\n</ul>\n<pre><code class=\"language-javascript\">const promise = new Promise((resolve, reject) => {\n    resolve('Promise resolved');\n});\npromise.then((value) => {\n    console.log(value);\n});\n</code></pre>\n<ul>\n  <li><strong><code>async/await</code></strong>：<code>async</code>函数中<code>await</code>后面的代码会被作为微任务处理。例如：</li>\n</ul>\n<pre><code class=\"language-javascript\">async function asyncFunc() {\n    const result = await Promise.resolve('Async result');\n    console.log(result);\n}\nasyncFunc();\n</code></pre>\n<ul>\n  <li><strong><code>MutationObserver</code>（浏览器环境）</strong>：用于监听DOM树的变化，当DOM树发生变化时，其回调函数会作为微任务执行。例如：</li>\n</ul>\n<pre><code class=\"language-javascript\">const targetNode = document.getElementById('some-element');\nconst config = { attributes: true, childList: true, subtree: true };\nconst callback = function(mutationsList, observer) {\n    for(const mutation of mutationsList) {\n        console.log('DOM发生变化', mutation);\n    }\n};\nconst observer = new MutationObserver(callback);\nobserver.observe(targetNode, config);\n</code></pre>\n<ul>\n  <li><strong><code>process.nextTick</code>（Node.js环境）</strong>：在Node.js中，<code>process.nextTick</code>会将回调函数添加到微任务队列的最前面，优先于其他微任务执行。例如：</li>\n</ul>\n<pre><code class=\"language-javascript\">process.nextTick(() => {\n    console.log('这是一个process.nextTick微任务');\n});\n</code></pre>\n<h3>4. 常见误区</h3>\n<h4>（1）混淆宏任务和微任务</h4>\n<ul>\n  <li>误区：不能准确区分哪些操作是宏任务，哪些是微任务，导致对事件循环中任务执行顺序判断错误。</li>\n  <li>纠正：牢记常见的宏任务和微任务类型，根据其特性进行判断。</li>\n</ul>\n<h4>（2）忽视不同环境的差异</h4>\n<ul>\n  <li>误区：没有注意到<code>setImmediate</code>、<code>process.nextTick</code>是Node.js环境特有的，而<code>requestAnimationFrame</code>、<code>MutationObserver</code>是浏览器环境特有的。</li>\n  <li>纠正：明确不同运行环境下宏任务和微任务的区别。</li>\n</ul>\n<h3>5. 总结回答</h3>\n<p>宏任务常见的有<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（Node.js环境）、<code>requestAnimationFrame</code>（浏览器环境）、I/O操作等；微任务常见的有<code>Promise.then</code> 和 <code>Promise.catch</code>、<code>async/await</code>、<code>MutationObserver</code>（浏览器环境）、<code>process.nextTick</code>（Node.js环境）。需要注意不同运行环境下宏任务和微任务的类型有所不同，同时要准确区分宏任务和微任务，因为它们在事件循环中的执行顺序不同。</p>",
    "more_ask": "<ol>\n  <li>\n    <p><strong>请解释一下宏任务和微任务的优先级是什么？</strong></p>\n    <ul>\n      <li>提示：讨论事件循环的工作机制。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你能举例说明在实际开发中宏任务和微任务如何影响性能吗？</strong></p>\n    <ul>\n      <li>提示：考虑用户体验和渲染的影响。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>Promise的微任务机制是如何工作的？</strong></p>\n    <ul>\n      <li>提示：分析Promise的.then()和.catch()的调用时机。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>async/await是如何与微任务交互的？</strong></p>\n    <ul>\n      <li>提示：探讨async函数的本质和返回值。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在处理宏任务和微任务时，如何避免潜在的内存泄漏？</strong></p>\n    <ul>\n      <li>提示：关注事件监听器和定时器的清理。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>可以通过哪些方式来优化微任务的合并执行？</strong></p>\n    <ul>\n      <li>提示：考虑使用宏任务来批处理操作。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你如何选择在什么情况下使用宏任务和微任务？</strong></p>\n    <ul>\n      <li>提示：讨论任务的性质和影响。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>能否让微任务阻塞宏任务的执行？请说明原因。</strong></p>\n    <ul>\n      <li>提示：分析事件循环的规则。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>请解释Node.js中的事件循环与浏览器中的事件循环有何不同？</strong></p>\n    <ul>\n      <li>提示：对比两者的任务调度机制。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如果一个微任务抛出异常，会对后续的宏任务执行造成什么影响？</strong></p>\n  </li>\n</ol>\n<ul>\n  <li>提示：讨论错误处理和堆栈的影响。</li>\n</ul>",
    "mindmap": "mindmap\n  root((宏任务和微任务))\n    宏任务（Macro Tasks）\n      较大的任务单位\n      浏览器事件循环处理\n      包括\n        setTimeout\n        setInterval\n        I/O 操作\n        用户事件\n        requestAnimationFrame\n    微任务（Micro Tasks）\n      较小的任务单位\n      执行优先级高于宏任务\n      包括\n        Promise 回调\n        MutationObserver 回调\n        queueMicrotask 任务\n    调度顺序\n      执行一个宏任务\n      执行所有微任务\n      再次检查宏任务队列",
    "keynote": "关键要点：\n- 宏任务包括较大的任务单位，如 `setTimeout`、`setInterval`、I/O 操作、用户事件、`requestAnimationFrame`\n- 微任务包括较小的任务单位，如 `Promise` 回调、`MutationObserver` 回调、`queueMicrotask` 任务\n- 微任务的执行优先级高于宏任务\n- 每完成一个宏任务后会立即执行所有微任务，直到微任务队列为空\n- 调度顺序为：执行一个宏任务 -> 执行所有微任务 -> 再次检查宏任务队列",
    "group_id": 78,
    "kps": [
      "Web API与特性",
      "浏览器架构与渲染引擎"
    ],
    "years": [
      2023,
      2022
    ],
    "corps": [
      "去哪儿网",
      "美团"
    ]
  }
}