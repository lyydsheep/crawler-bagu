{"success":true,"data":{"id":24545,"name":"<p>请详细说明同源策略、跨域及解决方案</p>","options":null,"answer":"<h3>同源策略</h3>\n<h4>定义</h4>\n<p>同源策略（Same-Origin Policy）是一种重要的安全机制，它是浏览器的一个基本安全原则。该策略限制了一个源（origin）的文档或者脚本如何能与另一个源的资源进行交互。所谓“同源”指的是两个 URL 的协议（protocol）、域名（domain）和端口号（port）都相同。</p>\n<h4>示例</h4>\n<p>例如，以下两个 URL：</p>\n<ul>\n  <li><code>http://example.com:8080/page1.html</code></li>\n  <li>\n    <code>http://example.com:8080/page2.html</code>\n    这两个 URL 是同源的，因为它们的协议都是 <code>http</code>，域名都是 <code>example.com</code>，端口号都是 <code>8080</code>。而 <code>https://example.com:8080/page3.html</code> 与上述两个 URL 不同源，因为协议不同（一个是 <code>http</code>，一个是 <code>https</code>）。\n  </li>\n</ul>\n<h4>作用</h4>\n<p>同源策略主要是为了防止不同源的脚本对其他源的敏感数据进行非法访问和操作，从而保护用户信息的安全。比如，若没有同源策略，一个恶意网站可以轻易地访问用户在其他网站的登录信息、银行账户信息等。</p>\n<h3>跨域</h3>\n<h4>定义</h4>\n<p>当浏览器从一个源（协议、域名、端口）的网页去请求另一个源的资源时，由于同源策略的限制，就会产生跨域问题。即只要协议、域名、端口有任何一个不同，就会被视为跨域请求。</p>\n<h4>示例</h4>\n<ul>\n  <li>网页 <code>http://www.siteA.com</code> 中的 JavaScript 代码尝试请求 <code>http://www.siteB.com/api/data</code> 的数据，这就是一个典型的跨域请求，因为域名不同。</li>\n  <li>网页 <code>http://example.com:80</code> 尝试请求 <code>http://example.com:8080/api</code>，由于端口号不同，也会产生跨域问题。</li>\n</ul>\n<h4>影响</h4>\n<p>跨域会导致浏览器对请求进行拦截，使得请求无法正常获取到响应数据，从而影响网页的正常功能，例如无法加载跨域的图片、无法获取跨域的 API 数据等。</p>\n<h3>跨域解决方案</h3>\n<h4>1. JSONP（JSON with Padding）</h4>\n<ul>\n  <li><strong>原理</strong>：JSONP 是一种古老的跨域数据交互技术，它利用了 <code>&#x3C;script></code> 标签的 <code>src</code> 属性不受同源策略限制的特点。服务器将返回的数据包装在一个回调函数中，前端通过动态创建 <code>&#x3C;script></code> 标签来请求服务器资源，服务器返回的响应会作为回调函数的参数被执行。</li>\n  <li><strong>示例代码</strong>\n    <ul>\n      <li><strong>前端代码</strong></li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n    &#x3C;meta charset=\"UTF-8\">\n&#x3C;/head>\n&#x3C;body>\n    &#x3C;script>\n        function handleResponse(data) {\n            console.log(data);\n        }\n        const script = document.createElement('script');\n        script.src = 'http://example.com/api/data?callback=handleResponse';\n        document.body.appendChild(script);\n    &#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<pre><code>- **服务器端代码（以 Node.js 为例）**\n</code></pre>\n<pre><code class=\"language-javascript\">const http = require('http');\n\nconst server = http.createServer((req, res) => {\n    const url = new URL(req.url, `http://${req.headers.host}`);\n    const callback = url.searchParams.get('callback');\n    const data = { message: 'Hello from server!' };\n    const response = `${callback}(${JSON.stringify(data)})`;\n    res.writeHead(200, { 'Content-Type': 'application/javascript' });\n    res.end(response);\n});\n\nserver.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});\n</code></pre>\n<ul>\n  <li><strong>缺点</strong>：只支持 GET 请求，安全性较低，因为它本质上是利用了脚本注入的方式。</li>\n</ul>\n<h4>2. CORS（Cross-Origin Resource Sharing）</h4>\n<ul>\n  <li><strong>原理</strong>：CORS 是一种现代的跨域解决方案，它是 W3C 标准，允许浏览器和服务器进行跨域通信。服务器通过设置响应头来告诉浏览器哪些跨域请求是被允许的。当浏览器发起跨域请求时，会自动在请求头中添加 <code>Origin</code> 字段，服务器根据这个字段判断是否允许该请求。</li>\n  <li><strong>示例代码</strong>\n    <ul>\n      <li><strong>服务器端代码（以 Node.js + Express 为例）</strong></li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-javascript\">const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n    res.setHeader('Access-Control-Allow-Origin', '*'); // 允许所有源的请求\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n    next();\n});\n\napp.get('/api/data', (req, res) => {\n    const data = { message: 'Hello from server!' };\n    res.json(data);\n});\n\nconst port = 3000;\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n</code></pre>\n<ul>\n  <li><strong>优点</strong>：支持各种 HTTP 请求方法，是目前最常用的跨域解决方案。</li>\n</ul>\n<h4>3. 代理服务器</h4>\n<ul>\n  <li><strong>原理</strong>：在同源的服务器上设置一个代理，前端将请求发送到同源的代理服务器，代理服务器再将请求转发到目标服务器，并将目标服务器的响应返回给前端。这样，前端与代理服务器是同源的，不会产生跨域问题。</li>\n  <li><strong>示例</strong>\n    <ul>\n      <li>\n        <strong>开发环境（以 Vue.js 为例）</strong>\n        在 <code>vue.config.js</code> 中配置代理：\n      </li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-javascript\">module.exports = {\n    devServer: {\n        proxy: {\n            '/api': {\n                target: 'http://example.com', // 目标服务器地址\n                changeOrigin: true,\n                pathRewrite: {\n                    '^/api': ''\n                }\n            }\n        }\n    }\n};\n</code></pre>\n<pre><code>- **生产环境**：可以使用 Nginx 等服务器软件来配置反向代理。\n</code></pre>\n<pre><code class=\"language-nginx\">server {\n    listen 80;\n    server_name example.com;\n\n    location /api {\n        proxy_pass http://target-server.com;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>优点</strong>：不需要对目标服务器进行修改，适用于无法修改目标服务器配置的情况。</li>\n</ul>","type":6,"level":2,"freq":0.0215311,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：详细说明同源策略、跨域及解决方案。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对同源策略概念的理解。</li>\n      <li>跨域产生的原因及影响。</li>\n      <li>常见跨域解决方案的原理和应用。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）同源的定义</h4>\n<p>同源是指两个URL的协议、域名和端口都相同。例如，<code>http://example.com:8080/page1.html</code> 和 <code>http://example.com:8080/page2.html</code> 是同源的；而 <code>http://example.com:8080</code> 和 <code>https://example.com:8080</code>（协议不同）、<code>http://sub.example.com:8080</code>（域名不同）、<code>http://example.com:80</code>（端口不同） 是非同源的。</p>\n<h4>（2）浏览器的安全机制</h4>\n<p>浏览器为了保证用户信息的安全，引入了同源策略。它是一种约定，是浏览器最核心也最基本的安全功能。</p>\n<h3>3. 解析</h3>\n<h4>（1）同源策略</h4>\n<ul>\n  <li><strong>概念</strong>：同源策略限制了一个源（origin）的文档或者脚本如何能与另一个源的资源进行交互。它可以防止不同源的脚本访问和操作其他源的敏感数据，比如Cookie、LocalStorage等。例如，在 <code>http://siteA.com</code> 页面中的脚本无法直接访问 <code>http://siteB.com</code> 页面的DOM元素和数据。</li>\n  <li><strong>作用</strong>：主要是为了保证用户信息的安全，防止不同源的恶意脚本通过某种方式获取用户在其他网站的敏感信息。</li>\n</ul>\n<h4>（2）跨域</h4>\n<ul>\n  <li><strong>产生原因</strong>：由于同源策略的限制，当一个请求的源和目标资源的源不同时，就会产生跨域问题。在Web开发中，常见的跨域场景包括前端页面与后端API不在同一个域名下，或者端口不同等。</li>\n  <li><strong>影响</strong>：跨域请求会被浏览器阻止，导致无法正常获取目标资源的数据。例如，在前端使用AJAX请求跨域的API接口时，浏览器会拦截该请求，即使请求在网络层面已经成功发送。</li>\n</ul>\n<h4>（3）解决方案</h4>\n<h5>JSONP（JSON with Padding）</h5>\n<ul>\n  <li><strong>原理</strong>：利用 <code>&#x3C;script></code> 标签的 <code>src</code> 属性不受同源策略限制的特点。服务器将返回的数据包装在一个回调函数中，前端页面预先定义好这个回调函数，然后通过动态创建 <code>&#x3C;script></code> 标签来请求服务器资源。服务器返回的响应会作为回调函数的参数，从而实现跨域数据交互。</li>\n  <li><strong>示例代码</strong>：\n    <ul>\n      <li>前端代码：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n\n&#x3C;head>\n    &#x3C;meta charset=\"UTF-8\">\n&#x3C;/head>\n\n&#x3C;body>\n    &#x3C;script>\n        function handleResponse(data) {\n            console.log(data);\n        }\n        var script = document.createElement('script');\n        script.src = 'http://example.com/api?callback=handleResponse';\n        document.body.appendChild(script);\n    &#x3C;/script>\n&#x3C;/body>\n\n&#x3C;/html>\n</code></pre>\n<ul>\n  <li>后端代码（以Node.js为例）：</li>\n</ul>\n<pre><code class=\"language-javascript\">const http = require('http');\n\nconst server = http.createServer((req, res) => {\n    const url = new URL(req.url, `http://${req.headers.host}`);\n    const callback = url.searchParams.get('callback');\n    const data = { message: 'Hello from server' };\n    const response = `${callback}(${JSON.stringify(data)})`;\n    res.writeHead(200, { 'Content-Type': 'application/javascript' });\n    res.end(response);\n});\n\nserver.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});\n</code></pre>\n<ul>\n  <li><strong>缺点</strong>：只支持GET请求，安全性较低，因为它依赖于动态加载脚本，可能存在脚本注入风险。</li>\n</ul>\n<h5>CORS（Cross - Origin Resource Sharing）</h5>\n<ul>\n  <li><strong>原理</strong>：是一种现代的跨域解决方案，它允许服务器在响应头中设置一些特殊的字段，来告诉浏览器哪些源可以访问该资源。浏览器在发送跨域请求时，会先检查服务器的响应头，如果允许当前源访问，则会正常处理响应。</li>\n  <li><strong>示例代码</strong>：\n    <ul>\n      <li>后端代码（以Node.js和Express框架为例）：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-javascript\">const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n    res.setHeader('Access-Control-Allow-Origin', '*'); // 允许所有源访问\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\n    next();\n});\n\napp.get('/api', (req, res) => {\n    res.json({ message: 'Cross - origin data' });\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});\n</code></pre>\n<ul>\n  <li><strong>优点</strong>：支持各种HTTP请求方法，是W3C标准，安全性高，是目前主流的跨域解决方案。</li>\n</ul>\n<h5>代理服务器</h5>\n<ul>\n  <li><strong>原理</strong>：在同源的服务器上设置一个代理，前端页面将请求发送到同源的代理服务器，代理服务器再将请求转发到目标服务器，并将响应返回给前端。由于前端和代理服务器是同源的，不会受到同源策略的限制。</li>\n  <li><strong>示例</strong>：在开发环境中，使用Webpack Dev Server的代理功能。在 <code>webpack.config.js</code> 中配置：</li>\n</ul>\n<pre><code class=\"language-javascript\">module.exports = {\n    devServer: {\n        proxy: {\n            '/api': {\n                target: 'http://example.com',\n                changeOrigin: true,\n                pathRewrite: { '^/api': '' }\n            }\n        }\n    }\n};\n</code></pre>\n<ul>\n  <li><strong>适用场景</strong>：适用于开发环境和内部网络环境。</li>\n</ul>\n<h3>4. 常见误区</h3>\n<h4>（1）认为同源策略没有必要</h4>\n<ul>\n  <li>误区：觉得同源策略限制了开发的灵活性，应该取消。</li>\n  <li>纠正：同源策略是保障用户信息安全的重要机制，虽然会带来跨域问题，但可以通过合理的解决方案来解决。</li>\n</ul>\n<h4>（2）滥用JSONP</h4>\n<ul>\n  <li>误区：在任何跨域场景都使用JSONP。</li>\n  <li>纠正：JSONP有很多局限性，如只支持GET请求和安全性低，应优先考虑使用CORS。</li>\n</ul>\n<h4>（3）忽视代理服务器的安全性</h4>\n<ul>\n  <li>误区：使用代理服务器时不考虑安全问题。</li>\n  <li>纠正：代理服务器需要做好安全防护，防止被恶意利用来进行中间人攻击等。</li>\n</ul>\n<h3>5. 总结回答</h3>\n<p>同源策略是浏览器的一种安全机制，它限制了一个源的文档或脚本与另一个源的资源进行交互，确保用户信息的安全，防止不同源的恶意脚本获取敏感数据。</p>\n<p>当一个请求的源和目标资源的源不同时，就会产生跨域问题，导致请求被浏览器拦截。</p>\n<p>常见的跨域解决方案有：</p>\n<ul>\n  <li>JSONP：利用 <code>&#x3C;script></code> 标签的 <code>src</code> 属性不受同源策略限制的特点，通过回调函数实现跨域数据交互，但只支持GET请求且安全性较低。</li>\n  <li>CORS：服务器通过设置响应头来允许特定源的访问，支持各种HTTP请求方法，是W3C标准，安全性高，是主流的跨域解决方案。</li>\n  <li>代理服务器：在同源的服务器上设置代理，将请求转发到目标服务器，适用于开发环境和内部网络环境。</li>\n</ul>\n<p>在实际开发中，应根据具体场景选择合适的跨域解决方案，并注意各种方案的优缺点和安全问题。</p>","more_ask":"<ol>\n  <li>\n    <p>\n      同源策略在不同浏览器中的实现差异有哪些？\n      提示：不同浏览器对同源策略的安全级别、具体规则等方面可能有不同处理。\n    </p>\n  </li>\n  <li>\n    <p>\n      跨域解决方案中 JSONP 存在哪些安全风险？\n      提示：考虑 JSONP 实现原理以及数据传输和执行的特点。\n    </p>\n  </li>\n  <li>\n    <p>\n      CORS 跨域中简单请求和预检请求的触发条件分别是什么？\n      提示：从请求方法、请求头字段等方面思考。\n    </p>\n  </li>\n  <li>\n    <p>\n      使用代理服务器解决跨域时，如何保证代理服务器的安全性？\n      提示：可从访问控制、数据加密等方面考虑。\n    </p>\n  </li>\n  <li>\n    <p>\n      WebSocket 不受同源策略限制的原理是什么？\n      提示：结合 WebSocket 协议的通信机制和特点。\n    </p>\n  </li>\n  <li>\n    <p>\n      跨域时如何处理跨域资源的缓存问题？\n      提示：思考缓存策略、缓存控制头在跨域场景下的应用。\n    </p>\n  </li>\n  <li>\n    <p>\n      在 Node.js 中实现跨域请求，和在浏览器环境有什么不同？\n      提示：对比两者的运行环境、API 等方面的差异。\n    </p>\n  </li>\n</ol>","mindmap":"mindmap\n  root((同源策略与跨域相关知识))\n    同源策略\n      定义\n        浏览器基本安全原则\n        限制不同源资源交互\n        同源条件：协议、域名、端口相同\n      示例\n        同源URL示例\n        不同源URL示例\n      作用\n        防止非法访问敏感数据\n        保护用户信息安全\n    跨域\n      定义\n        因同源策略产生的请求问题\n        协议、域名、端口不同视为跨域\n      示例\n        域名不同跨域示例\n        端口不同跨域示例\n      影响\n        浏览器拦截请求\n        影响网页正常功能\n    跨域解决方案\n      JSONP（JSON with Padding）\n        原理\n          利用<script>标签src属性\n          服务器包装数据在回调函数\n        缺点\n          只支持GET请求\n          安全性较低\n      CORS（Cross-Origin Resource Sharing）\n        原理\n          W3C标准，服务器设置响应头\n          浏览器添加Origin字段\n        优点\n          支持各种HTTP请求方法\n          常用解决方案\n      代理服务器\n        原理\n          同源服务器设置代理转发请求\n        示例\n          开发环境（Vue.js）配置\n          生产环境（Nginx）配置\n        优点\n          无需修改目标服务器配置","keynote":"同源策略：安全机制，限制不同源交互，同源条件为协议、域名、端口相同，防非法访问保护用户信息\n跨域：请求不同源资源受限，协议、域名、端口不同即跨域，会被浏览器拦截影响功能\n跨域解决方案：\n- JSONP：利用`<script>`标签，包装数据在回调函数，仅支持GET，安全性低\n- CORS：W3C标准，服务器设响应头，支持各种请求方法\n- 代理服务器：同源设代理转发请求，开发和生产环境有不同配置，无需改目标服务器","group_id":78,"kps":["浏览器安全","Web标准与协议"],"years":[2024,2023,2022],"corps":["数字马力","腾讯","势动科技","小红书","阿里云","小米","滴滴","深信服","顺丰","360","用友","商汤科技","平安科技","酷家乐","知乎","金山","货拉拉","字节跳动","百度","腾讯视频","美团","阿里巴巴","快手","OPPO","科大讯飞","完美世界"]}}