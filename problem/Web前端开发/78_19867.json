{
  "success": true,
  "data": {
    "id": 19867,
    "name": "<p>请说明浏览器怎么识别强缓存和协商缓存，以及如何选择使用强缓存还是协商缓存</p>",
    "options": null,
    "answer": "<h3>浏览器识别强缓存和协商缓存的方式</h3>\n<h4>强缓存</h4>\n<p>强缓存是指浏览器直接从本地缓存中读取资源，而不需要向服务器发送请求。浏览器通过检查响应头中的 <code>Expires</code> 和 <code>Cache-Control</code> 字段来判断是否使用强缓存。</p>\n<ul>\n  <li><strong><code>Expires</code></strong>：这是 HTTP/1.0 中用于控制缓存的字段，它的值是一个具体的日期和时间，表示资源的过期时间。当浏览器再次请求该资源时，会将当前时间与 <code>Expires</code> 中的时间进行比较，如果当前时间早于 <code>Expires</code> 时间，则使用本地缓存；否则，认为缓存已过期，需要重新向服务器请求资源。</li>\n</ul>\n<p>示例响应头：</p>\n<pre><code class=\"language-plaintext\">Expires: Thu, 01 Jan 2025 00:00:00 GMT\n</code></pre>\n<ul>\n  <li><strong><code>Cache-Control</code></strong>：这是 HTTP/1.1 中引入的字段，用于更精确地控制缓存策略。它可以有多个值，常见的有 <code>max-age</code>、<code>no-cache</code>、<code>no-store</code> 等。\n    <ul>\n      <li><code>max-age</code>：指定资源在缓存中的有效时间，单位为秒。例如，<code>max-age=3600</code> 表示资源在 3600 秒（1 小时）内是有效的。当浏览器再次请求该资源时，会检查从第一次请求到现在的时间是否超过了 <code>max-age</code> 指定的时间，如果没有超过，则使用本地缓存；否则，需要重新向服务器请求资源。</li>\n      <li><code>no-cache</code>：表示不使用强缓存，需要进行协商缓存，即每次请求都要向服务器验证资源是否有更新。</li>\n      <li><code>no-store</code>：表示不使用任何缓存，每次请求都要从服务器获取最新资源。</li>\n    </ul>\n  </li>\n</ul>\n<p>示例响应头：</p>\n<pre><code class=\"language-plaintext\">Cache-Control: max-age=3600\n</code></pre>\n<p>浏览器识别强缓存的流程如下：</p>\n<ol>\n  <li>浏览器发起请求，检查请求资源是否有缓存。</li>\n  <li>如果有缓存，先检查 <code>Cache-Control</code> 字段：\n    <ul>\n      <li>如果 <code>Cache-Control</code> 存在且为 <code>no-store</code>，则不使用缓存，直接向服务器请求资源。</li>\n      <li>如果 <code>Cache-Control</code> 存在且为 <code>no-cache</code>，则进入协商缓存流程。</li>\n      <li>如果 <code>Cache-Control</code> 包含 <code>max-age</code>，则计算从第一次请求到现在的时间是否超过 <code>max-age</code> 指定的时间，如果没有超过，则使用本地缓存；否则，进入协商缓存流程。</li>\n    </ul>\n  </li>\n  <li>如果 <code>Cache-Control</code> 不存在，再检查 <code>Expires</code> 字段：\n    <ul>\n      <li>如果当前时间早于 <code>Expires</code> 时间，则使用本地缓存；否则，进入协商缓存流程。</li>\n    </ul>\n  </li>\n</ol>\n<h4>协商缓存</h4>\n<p>协商缓存是指浏览器在使用缓存之前，先向服务器发送一个请求，询问服务器该资源是否有更新。如果服务器返回资源没有更新，则浏览器使用本地缓存；否则，服务器返回最新的资源。浏览器通过检查响应头中的 <code>ETag</code> 和 <code>Last-Modified</code> 字段来判断是否使用协商缓存。</p>\n<ul>\n  <li><strong><code>Last-Modified</code></strong>：该字段表示资源的最后修改时间。当浏览器再次请求该资源时，会在请求头中添加 <code>If-Modified-Since</code> 字段，其值为之前响应头中 <code>Last-Modified</code> 的值。服务器收到请求后，会将该资源的当前最后修改时间与 <code>If-Modified-Since</code> 中的时间进行比较，如果相同，则表示资源没有更新，返回 304 状态码，浏览器使用本地缓存；否则，返回 200 状态码和最新的资源。</li>\n</ul>\n<p>示例响应头：</p>\n<pre><code class=\"language-plaintext\">Last-Modified: Thu, 01 Jan 2024 12:00:00 GMT\n</code></pre>\n<p>示例请求头：</p>\n<pre><code class=\"language-plaintext\">If-Modified-Since: Thu, 01 Jan 2024 12:00:00 GMT\n</code></pre>\n<ul>\n  <li><strong><code>ETag</code></strong>：该字段是资源的唯一标识符，通常是一个哈希值。当浏览器再次请求该资源时，会在请求头中添加 <code>If-None-Match</code> 字段，其值为之前响应头中 <code>ETag</code> 的值。服务器收到请求后，会将该资源的当前 <code>ETag</code> 与 <code>If-None-Match</code> 中的值进行比较，如果相同，则表示资源没有更新，返回 304 状态码，浏览器使用本地缓存；否则，返回 200 状态码和最新的资源。</li>\n</ul>\n<p>示例响应头：</p>\n<pre><code class=\"language-plaintext\">ETag: \"123456789abcdef\"\n</code></pre>\n<p>示例请求头：</p>\n<pre><code class=\"language-plaintext\">If-None-Match: \"123456789abcdef\"\n</code></pre>\n<p>浏览器识别协商缓存的流程如下：</p>\n<ol>\n  <li>当强缓存失效时，浏览器发起请求，在请求头中添加 <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 字段。</li>\n  <li>服务器收到请求后，先比较 <code>ETag</code> 值：\n    <ul>\n      <li>如果 <code>ETag</code> 相同，则再比较 <code>Last-Modified</code> 时间。</li>\n      <li>如果 <code>ETag</code> 不同，则表示资源有更新，返回 200 状态码和最新的资源。</li>\n    </ul>\n  </li>\n  <li>如果 <code>ETag</code> 相同，再比较 <code>Last-Modified</code> 时间：\n    <ul>\n      <li>如果 <code>Last-Modified</code> 时间相同，则表示资源没有更新，返回 304 状态码，浏览器使用本地缓存。</li>\n      <li>如果 <code>Last-Modified</code> 时间不同，则表示资源有更新，返回 200 状态码和最新的资源。</li>\n    </ul>\n  </li>\n</ol>\n<h3>选择使用强缓存还是协商缓存的方法</h3>\n<ul>\n  <li><strong>强缓存的适用场景</strong>\n    <ul>\n      <li><strong>静态资源</strong>：如图片、CSS 文件、JavaScript 文件等，这些资源通常不会频繁更新，可以设置较长的 <code>max-age</code> 值，使用强缓存来提高页面加载速度。</li>\n      <li><strong>不经常变化的内容</strong>：例如网站的 logo、底部导航等，这些内容的更新频率较低，可以使用强缓存。</li>\n    </ul>\n  </li>\n</ul>\n<p>示例代码（使用 Node.js 和 Express 框架设置强缓存）：</p>\n<pre><code class=\"language-javascript\">const express = require('express');\nconst app = express();\n\n// 设置静态资源的强缓存\napp.use(express.static('public', {\n    maxAge: 3600 * 1000 // 缓存 1 小时\n}));\n\nconst port = 3000;\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n</code></pre>\n<ul>\n  <li><strong>协商缓存的适用场景</strong>\n    <ul>\n      <li><strong>动态内容</strong>：如新闻文章、商品信息等，这些内容可能会经常更新，使用协商缓存可以确保用户每次访问时都能获取到最新的内容。</li>\n      <li><strong>对数据实时性要求较高的场景</strong>：例如股票行情、天气预报等，需要及时获取最新的数据，使用协商缓存可以在数据有更新时及时获取。</li>\n    </ul>\n  </li>\n</ul>\n<p>示例代码（使用 Node.js 和 Express 框架设置协商缓存）：</p>\n<pre><code class=\"language-javascript\">const express = require('express');\nconst app = express();\nconst crypto = require('crypto');\n\napp.get('/data', (req, res) => {\n    const data = { message: 'Hello, World!' };\n    const etag = crypto.createHash('md5').update(JSON.stringify(data)).digest('hex');\n\n    if (req.headers['if-none-match'] === etag) {\n        res.status(304).end();\n    } else {\n        res.set('ETag', etag);\n        res.json(data);\n    }\n});\n\nconst port = 3000;\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n</code></pre>\n<p>综上所述，选择使用强缓存还是协商缓存需要根据资源的更新频率和对数据实时性的要求来决定。对于不经常变化的资源，可以使用强缓存；对于经常变化的资源，建议使用协商缓存。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.0009569378,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：一是浏览器识别强缓存和协商缓存的方式，二是选择使用强缓存还是协商缓存的方法。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对浏览器缓存机制中强缓存和协商缓存概念的理解。</li>\n      <li>强缓存和协商缓存相关HTTP头字段的作用。</li>\n      <li>根据不同场景选择缓存策略的能力。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）强缓存</h4>\n<p>强缓存是指浏览器直接从本地缓存中读取资源，无需向服务器发送请求。它通过<code>Expires</code>和<code>Cache - Control</code>这两个HTTP头字段来控制。</p>\n<ul>\n  <li><code>Expires</code>：是HTTP 1.0的产物，它的值是一个绝对时间，表示资源的过期时间。当浏览器再次请求该资源时，会将当前时间与<code>Expires</code>的值进行比较，如果当前时间在<code>Expires</code>之前，则使用缓存，否则重新请求。</li>\n  <li><code>Cache - Control</code>：是HTTP 1.1中用来替代<code>Expires</code>的字段，它可以设置多个指令，如<code>max - age</code>（表示资源的有效时间，单位为秒）、<code>no - cache</code>（不使用强缓存，需要进行协商缓存）、<code>no - store</code>（不使用任何缓存）等。</li>\n</ul>\n<h4>（2）协商缓存</h4>\n<p>协商缓存是指浏览器在使用缓存之前，先向服务器发送一个请求，询问服务器该资源是否有更新。如果资源没有更新，服务器返回304状态码，浏览器使用本地缓存；如果资源有更新，服务器返回200状态码和新的资源。协商缓存通过<code>ETag</code>和<code>Last - Modified</code>这两个HTTP头字段来控制。</p>\n<ul>\n  <li><code>Last - Modified</code>：服务器返回资源时，会在响应头中添加<code>Last - Modified</code>字段，表示该资源最后一次修改的时间。浏览器再次请求该资源时，会在请求头中添加<code>If - Modified - Since</code>字段，其值为之前<code>Last - Modified</code>的值。服务器会比较<code>If - Modified - Since</code>和资源的实际修改时间，如果相同则返回304，否则返回新资源。</li>\n  <li><code>ETag</code>：是资源的唯一标识符，服务器返回资源时，会在响应头中添加<code>ETag</code>字段。浏览器再次请求该资源时，会在请求头中添加<code>If - None - Match</code>字段，其值为之前<code>ETag</code>的值。服务器会比较<code>If - None - Match</code>和当前资源的<code>ETag</code>，如果相同则返回304，否则返回新资源。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）浏览器识别强缓存和协商缓存的方式</h4>\n<ul>\n  <li><strong>强缓存</strong>：浏览器在请求资源时，会先检查响应头中的<code>Cache - Control</code>和<code>Expires</code>字段。如果<code>Cache - Control</code>存在且其值表明可以使用强缓存（如<code>max - age</code>设置了有效时间），则优先使用<code>Cache - Control</code>的规则；如果<code>Cache - Control</code>不存在，则检查<code>Expires</code>字段。如果当前时间在<code>Expires</code>指定的时间之前，就使用本地缓存，即识别为可以使用强缓存。</li>\n  <li><strong>协商缓存</strong>：当<code>Cache - Control</code>的值为<code>no - cache</code>或者没有命中强缓存（如<code>max - age</code>过期）时，浏览器会发起协商缓存。此时浏览器会在请求头中添加<code>If - Modified - Since</code>和<code>If - None - Match</code>字段，根据服务器返回的状态码来判断是否使用缓存。如果服务器返回304状态码，则使用本地缓存；如果返回200状态码，则使用新的资源。</li>\n</ul>\n<h4>（2）选择使用强缓存还是协商缓存的方法</h4>\n<ul>\n  <li><strong>强缓存</strong>：适用于不经常变化的资源，如一些静态资源（图片、CSS、JS文件等）。这些资源的内容在一段时间内基本保持不变，使用强缓存可以减少浏览器与服务器之间的请求次数，提高页面的加载速度。例如，网站的logo图片、全局的CSS样式文件等。</li>\n  <li><strong>协商缓存</strong>：适用于可能会有变化，但变化频率不是特别高的资源。通过协商缓存，可以在资源有更新时及时获取新的资源，同时在资源没有更新时避免重复下载，减少网络带宽的消耗。例如，用户的个人信息页面，可能会隔一段时间更新一次，使用协商缓存可以在每次请求时检查是否有更新。</li>\n</ul>\n<h3>4. 示例代码（以Node.js为例）</h3>\n<pre><code class=\"language-javascript\">const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n    const filePath = path.join(__dirname, 'public', req.url);\n\n    fs.stat(filePath, (err, stats) => {\n        if (err) {\n            res.statusCode = 404;\n            res.end('Not Found');\n            return;\n        }\n\n        // 设置强缓存\n        res.setHeader('Cache - Control', 'max - age=3600');\n        res.setHeader('Expires', new Date(Date.now() + 3600 * 1000).toUTCString());\n\n        // 设置协商缓存\n        const lastModified = stats.mtime.toUTCString();\n        res.setHeader('Last - Modified', lastModified);\n        const etag = `\"${stats.size}-${Date.parse(lastModified)}\"`;\n        res.setHeader('ETag', etag);\n\n        if (req.headers['if - modified - since'] === lastModified || req.headers['if - none - match'] === etag) {\n            res.statusCode = 304;\n            res.end();\n        } else {\n            fs.readFile(filePath, (err, data) => {\n                if (err) {\n                    res.statusCode = 500;\n                    res.end('Internal Server Error');\n                    return;\n                }\n                res.statusCode = 200;\n                res.end(data);\n            });\n        }\n    });\n});\n\nserver.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});\n</code></pre>\n<p>在这个例子中，服务器设置了强缓存（<code>Cache - Control</code>和<code>Expires</code>）和协商缓存（<code>Last - Modified</code>和<code>ETag</code>）。浏览器在请求资源时，会根据这些字段来判断使用哪种缓存策略。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆<code>Expires</code>和<code>Cache - Control</code></h4>\n<ul>\n  <li>误区：认为<code>Expires</code>和<code>Cache - Control</code>的作用完全相同，没有注意到<code>Cache - Control</code>是HTTP 1.1的新标准，并且可以设置更多的指令。</li>\n  <li>纠正：<code>Cache - Control</code>的优先级高于<code>Expires</code>，在实际应用中应优先使用<code>Cache - Control</code>。</li>\n</ul>\n<h4>（2）忽略<code>ETag</code>和<code>Last - Modified</code>的区别</h4>\n<ul>\n  <li>误区：认为<code>ETag</code>和<code>Last - Modified</code>的作用一样，只使用其中一个就可以。</li>\n  <li>纠正：<code>ETag</code>是资源的唯一标识符，比<code>Last - Modified</code>更精确。在一些情况下，即使资源的修改时间没有变化，但内容可能已经改变，此时<code>ETag</code>可以检测到这种变化，而<code>Last - Modified</code>则不能。</li>\n</ul>\n<h4>（3）不根据资源特性选择缓存策略</h4>\n<ul>\n  <li>误区：对所有资源都使用相同的缓存策略，没有考虑资源的变化频率。</li>\n  <li>纠正：应根据资源的特性，如是否经常变化、变化的频率等，合理选择强缓存或协商缓存。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>浏览器识别强缓存和协商缓存主要通过HTTP头字段。对于强缓存，浏览器先检查<code>Cache - Control</code>字段，如果其值表明可以使用强缓存（如设置了<code>max - age</code>），则遵循该规则；若<code>Cache - Control</code>不存在，再检查<code>Expires</code>字段，若当前时间在<code>Expires</code>指定时间之前，就使用本地缓存。当<code>Cache - Control</code>为<code>no - cache</code>或未命中强缓存时，浏览器会发起协商缓存，在请求头中添加<code>If - Modified - Since</code>和<code>If - None - Match</code>字段，根据服务器返回的304或200状态码来决定是否使用本地缓存。</p>\n<p>选择使用强缓存还是协商缓存要根据资源的特性。对于不经常变化的静态资源，如图片、CSS、JS文件等，适合使用强缓存，以减少请求次数，提高页面加载速度。对于可能会有变化但变化频率不是特别高的资源，如用户个人信息页面，使用协商缓存可以在资源更新时及时获取新资源，同时避免重复下载，减少网络带宽消耗。</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      强缓存和协商缓存分别在 HTTP 协议的哪些版本中有不同的实现方式？\n      提示：回顾 HTTP 1.0、HTTP 1.1 等不同版本协议中与缓存相关的头部字段差异。\n    </p>\n  </li>\n  <li>\n    <p>\n      当协商缓存验证资源未修改时，服务器返回的状态码及该状态码在不同场景下的应用有哪些？\n      提示：思考 304 状态码在普通网页、API 请求等不同场景的使用情况。\n    </p>\n  </li>\n  <li>\n    <p>\n      强缓存和协商缓存对动态内容的缓存策略该如何调整？\n      提示：考虑动态内容的更新频率、数据来源等因素。\n    </p>\n  </li>\n  <li>\n    <p>\n      在 CDN 环境下，强缓存和协商缓存的机制会有什么变化？\n      提示：CDN 的分布式特性、缓存节点等对缓存机制的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      如何通过代码（如 JavaScript、Node.js）来手动控制强缓存和协商缓存的使用？\n      提示：从设置 HTTP 响应头、请求头的角度思考。\n    </p>\n  </li>\n  <li>\n    <p>\n      强缓存和协商缓存对搜索引擎爬虫抓取网页有什么影响？\n      提示：考虑爬虫的工作原理和缓存对页面内容获取的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      当缓存策略配置错误时，可能会出现哪些问题，如何排查和解决？\n      提示：从页面显示异常、数据更新不及时等现象去分析排查方法。\n    </p>\n  </li>\n  <li>\n    <p>\n      不同浏览器（如 Chrome、Firefox）在处理强缓存和协商缓存上有细微差别吗，如何处理这些差别？\n      提示：可查阅不同浏览器的缓存处理机制文档。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((浏览器识别强缓存和协商缓存的方式))\n    强缓存\n      定义\n      识别字段\n        Expires\n        Cache-Control\n          max-age\n          no-cache\n          no-store\n      识别流程\n    协商缓存\n      定义\n      识别字段\n        Last-Modified\n        ETag\n      识别流程\n    选择方法\n      强缓存适用场景\n        静态资源\n        不经常变化的内容\n      协商缓存适用场景\n        动态内容\n        对数据实时性要求高的场景",
    "keynote": "强缓存：直接从本地缓存读资源，通过响应头 Expires 和 Cache-Control 判断\n  - Expires：HTTP/1.0 字段，值为过期日期时间\n  - Cache-Control：HTTP/1.1 字段，值有 max-age、no-cache、no-store\n识别流程：先查 Cache-Control，再查 Expires\n协商缓存：用缓存前问服务器资源有无更新，通过响应头 ETag 和 Last-Modified 判断\n  - Last-Modified：资源最后修改时间\n  - ETag：资源唯一标识符\n识别流程：强缓存失效后，请求头加 If-Modified-Since 和 If-None-Match，服务器先比 ETag 再比 Last-Modified\n选择方法：\n  - 强缓存：适用于静态资源、不常变化内容\n  - 协商缓存：适用于动态内容、对数据实时性要求高的场景",
    "group_id": 78,
    "kps": [
      "Web标准与协议",
      "浏览器性能优化"
    ],
    "years": [
      2025,
      2023
    ],
    "corps": [
      "字节跳动",
      "快手"
    ]
  }
}