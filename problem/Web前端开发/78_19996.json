{
  "success": true,
  "data": {
    "id": 19996,
    "name": "<p>项目中是否遇到过跨域问题，如何解决</p>",
    "options": null,
    "answer": "<p>在计算机网络项目开发中，跨域问题是非常常见的，特别是在前后端分离的项目里。以下为你详细介绍跨域问题的概念、产生原因以及常见的解决方法。</p>\n<h3>跨域问题的概念和产生原因</h3>\n<ul>\n  <li><strong>概念</strong>：跨域是指浏览器从一个域名的网页去请求另一个域名的资源时，由于浏览器的同源策略（协议、域名、端口都相同才允许访问），会导致请求被阻止的现象。</li>\n  <li><strong>产生原因</strong>：浏览器的同源策略是为了保证用户信息的安全，防止不同源的脚本访问和操作其他源的敏感数据。当一个网页的请求违反了同源策略时，就会触发跨域问题。</li>\n</ul>\n<h3>常见解决方法</h3>\n<h4>1. JSONP（JSON with Padding）</h4>\n<ul>\n  <li><strong>原理</strong>：JSONP 是一种跨域数据交互的技术，它利用了 <code>&#x3C;script></code> 标签的 <code>src</code> 属性不受同源策略限制的特点。通过动态创建 <code>&#x3C;script></code> 标签，向服务器请求一个 JSON 数据，并在请求的 URL 中添加一个回调函数名作为参数，服务器收到请求后，会将 JSON 数据包装在回调函数中返回给客户端，客户端的 <code>&#x3C;script></code> 标签会执行这个回调函数，从而获取到服务器返回的数据。</li>\n  <li><strong>示例代码</strong>：\n    <ul>\n      <li><strong>前端代码</strong>：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n    &#x3C;meta charset=\"UTF-8\">\n&#x3C;/head>\n&#x3C;body>\n    &#x3C;script>\n        function handleResponse(data) {\n            console.log(data);\n        }\n        var script = document.createElement('script');\n        script.src = 'http://example.com/api?callback=handleResponse';\n        document.body.appendChild(script);\n    &#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<pre><code>- **后端代码（Node.js + Express）**：\n</code></pre>\n<pre><code class=\"language-javascript\">const express = require('express');\nconst app = express();\n\napp.get('/api', (req, res) => {\n    const callback = req.query.callback;\n    const data = { message: 'Hello, JSONP!' };\n    res.send(`${callback}(${JSON.stringify(data)})`);\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});\n</code></pre>\n<h4>2. CORS（Cross-Origin Resource Sharing）</h4>\n<ul>\n  <li><strong>原理</strong>：CORS 是一种现代的跨域解决方案，它通过在服务器端设置响应头来允许跨域请求。当浏览器发送跨域请求时，会先发送一个预检请求（OPTIONS 请求），询问服务器是否允许该跨域请求，服务器根据请求的信息返回相应的响应头，如果允许，则浏览器会发送实际的请求。</li>\n  <li><strong>示例代码</strong>：\n    <ul>\n      <li><strong>后端代码（Node.js + Express）</strong>：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-javascript\">const express = require('express');\nconst app = express();\n\n// 允许所有域名进行跨域调用\napp.use((req, res, next) => {\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n    next();\n});\n\napp.get('/api', (req, res) => {\n    res.json({ message: 'Hello, CORS!' });\n});\n\napp.listen(3000, () => {\n    console.log('Server is running on port 3000');\n});\n</code></pre>\n<h4>3. 代理服务器</h4>\n<ul>\n  <li><strong>原理</strong>：在开发环境中，可以使用代理服务器来解决跨域问题。代理服务器位于客户端和服务器之间，客户端向代理服务器发送请求，代理服务器将请求转发到目标服务器，并将目标服务器的响应返回给客户端。由于代理服务器和客户端处于同源，因此不会触发跨域问题。</li>\n  <li>\n    <strong>示例代码（Vue.js + Vue CLI）</strong>：\n    在 <code>vue.config.js</code> 中配置代理：\n  </li>\n</ul>\n<pre><code class=\"language-javascript\">module.exports = {\n    devServer: {\n        proxy: {\n            '/api': {\n                target: 'http://example.com', // 目标服务器地址\n                changeOrigin: true,\n                pathRewrite: {\n                    '^/api': ''\n                }\n            }\n        }\n    }\n};\n</code></pre>\n<p>以上这些方法都可以有效地解决跨域问题，在实际项目中，需要根据具体的需求和场景选择合适的解决方案。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.002870813,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：项目中是否遇到过跨域问题及解决办法。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对跨域问题概念的理解。</li>\n      <li>跨域问题在实际项目中的表现。</li>\n      <li>解决跨域问题的常见方法及应用场景。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）跨域问题的产生</h4>\n<ul>\n  <li>浏览器的同源策略限制，即浏览器从一个源（协议、域名、端口）加载的资源，默认情况下是不能访问另一个源的资源的。当请求的URL与当前页面的URL在协议、域名或端口上有任何一个不同时，就会触发跨域问题。</li>\n  <li>跨域问题会导致浏览器阻止请求，从而影响项目中数据的正常交互。</li>\n</ul>\n<h4>（2）常见的跨域场景</h4>\n<ul>\n  <li>前后端分离项目中，前端应用和后端服务部署在不同的域名或端口上。</li>\n  <li>调用第三方API，其域名与当前项目的域名不同。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）遇到跨域问题的判断</h4>\n<ul>\n  <li>在项目中，如果在浏览器的开发者工具的控制台看到类似“Access to XMLHttpRequest at 'xxx' from origin 'xxx' has been blocked by CORS policy”的错误提示，或者请求没有正常响应，就可能是遇到了跨域问题。</li>\n</ul>\n<h4>（2）解决跨域问题的常见方法</h4>\n<ul>\n  <li><strong>CORS（跨域资源共享）</strong>\n    <ul>\n      <li>原理：服务器端设置响应头，允许指定的源访问资源。浏览器在跨域请求时，会先发送一个预检请求（OPTIONS请求），询问服务器是否允许该跨域请求，服务器根据配置返回相应的响应头，浏览器再根据响应头决定是否发送真正的请求。</li>\n      <li>应用场景：适用于前后端分离项目，后端可以在代码中设置响应头。例如在Node.js的Express框架中：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-javascript\">const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n    res.setHeader('Access-Control-Allow-Origin', '*'); // 允许所有源访问\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n    next();\n});\n</code></pre>\n<ul>\n  <li><strong>JSONP（JSON with Padding）</strong>\n    <ul>\n      <li>原理：利用<code>&#x3C;script></code>标签的src属性不受同源策略限制的特点，通过动态创建<code>&#x3C;script></code>标签来实现跨域数据请求。服务器返回的数据会被包裹在一个回调函数中，前端通过定义该回调函数来处理返回的数据。</li>\n      <li>应用场景：只支持GET请求，适用于一些简单的跨域数据获取场景。例如：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n    &#x3C;meta charset=\"UTF-8\">\n&#x3C;/head>\n&#x3C;body>\n    &#x3C;script>\n        function handleData(data) {\n            console.log(data);\n        }\n        const script = document.createElement('script');\n        script.src = 'http://example.com/api?callback=handleData';\n        document.body.appendChild(script);\n    &#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<ul>\n  <li><strong>代理服务器</strong>\n    <ul>\n      <li>原理：在同源的服务器上设置一个代理，将前端的请求转发到目标服务器，然后将目标服务器的响应返回给前端。这样前端和代理服务器是同源的，避免了跨域问题。</li>\n      <li>应用场景：适用于开发环境和生产环境，如在Vue项目中可以使用<code>vue.config.js</code>配置代理：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-javascript\">module.exports = {\n    devServer: {\n        proxy: {\n            '/api': {\n                target: 'http://example.com',\n                changeOrigin: true,\n                pathRewrite: {\n                    '^/api': ''\n                }\n            }\n        }\n    }\n};\n</code></pre>\n<h3>4. 常见误区</h3>\n<h4>（1）只依赖单一方法</h4>\n<ul>\n  <li>误区：只使用一种跨域解决方法，而不考虑具体的应用场景和需求。</li>\n  <li>纠正：根据项目的实际情况选择合适的跨域解决方法，或者结合多种方法使用。</li>\n</ul>\n<h4>（2）安全问题</h4>\n<ul>\n  <li>误区：在使用CORS时，将<code>Access-Control-Allow-Origin</code>设置为<code>*</code>，可能会导致安全风险。</li>\n  <li>纠正：应该明确指定允许的源，而不是使用通配符。</li>\n</ul>\n<h4>（3）JSONP使用不当</h4>\n<ul>\n  <li>误区：在需要处理复杂请求（如POST请求）时使用JSONP。</li>\n  <li>纠正：JSONP只支持GET请求，对于复杂请求应选择其他跨域解决方法。</li>\n</ul>\n<h3>5. 总结回答</h3>\n<p>在项目中是可能遇到跨域问题的，当请求的URL与当前页面的URL在协议、域名或端口上不同时，浏览器的同源策略会阻止请求，在控制台会出现相关的CORS错误提示。</p>\n<p>解决跨域问题有多种方法：</p>\n<ul>\n  <li><strong>CORS</strong>：服务器端设置响应头，允许指定的源访问资源，适用于前后端分离项目。</li>\n  <li><strong>JSONP</strong>：利用<code>&#x3C;script></code>标签的src属性不受同源策略限制的特点，只支持GET请求，适用于简单的跨域数据获取。</li>\n  <li><strong>代理服务器</strong>：在同源的服务器上设置代理，将请求转发到目标服务器，适用于开发和生产环境。</li>\n</ul>\n<p>在实际应用中，要根据项目的具体情况选择合适的解决方法，同时要注意安全和性能问题。例如，在使用CORS时不要随意设置<code>Access-Control-Allow-Origin</code>为<code>*</code>，避免安全风险。</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      跨域问题本质上是由浏览器的什么机制导致的，该机制的作用是什么？\n      提示：思考浏览器为保障用户信息安全而设置的一种限制机制。\n    </p>\n  </li>\n  <li>\n    <p>\n      你提到的解决跨域的方法中，JSONP 只能处理 GET 请求，为什么？\n      提示：结合 JSONP 的实现原理，分析其与请求方法的关联。\n    </p>\n  </li>\n  <li>\n    <p>\n      使用 CORS 解决跨域时，简单请求和非简单请求在处理上有什么不同？\n      提示：从请求头、预检请求等方面去考虑差异。\n    </p>\n  </li>\n  <li>\n    <p>\n      在使用代理服务器解决跨域问题时，代理服务器的配置有哪些关键要点？\n      提示：关注代理服务器的转发规则、端口设置等方面。\n    </p>\n  </li>\n  <li>\n    <p>\n      跨域问题是否只存在于浏览器环境中，在 Node.js 服务端之间通信会有跨域问题吗，为什么？\n      提示：对比浏览器和 Node.js 服务端的运行环境特点。\n    </p>\n  </li>\n  <li>\n    <p>\n      若在一个复杂的微服务架构中出现跨域问题，你会如何排查和解决？\n      提示：考虑微服务架构的层次和服务间的调用关系。\n    </p>\n  </li>\n  <li>\n    <p>\n      解决跨域问题后，是否会引入新的安全风险，如何防范？\n      提示：思考跨域解决方法可能对系统安全带来的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      当跨域请求的响应数据量非常大时，之前的解决方法是否会有性能问题，如何优化？\n      提示：从数据传输、处理等方面分析性能瓶颈并思考应对策略。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((计算机网络项目跨域问题))\n    跨域问题的概念和产生原因\n      概念\n      产生原因\n    常见解决方法\n      JSONP（JSON with Padding）\n        原理\n      CORS（Cross-Origin Resource Sharing）\n        原理\n      代理服务器\n        原理",
    "keynote": "跨域问题：计算机网络项目开发常见，尤其前后端分离项目\n概念：浏览器请求不同域名资源，因同源策略请求被阻止\n产生原因：同源策略保证用户信息安全，违反则触发跨域\n解决方法：\n  JSONP：利用 `<script>` 标签 `src` 属性，动态创建标签请求数据，服务器包装数据在回调函数返回\n  CORS：服务器端设置响应头允许跨域，先预检请求\n  代理服务器：开发环境使用，转发请求，与客户端同源不触发跨域 \n根据需求场景选合适方案",
    "group_id": 78,
    "kps": [
      "Web标准与协议",
      "前端安全最佳实践"
    ],
    "years": [
      2025,
      2024,
      2022
    ],
    "corps": [
      "Momenta",
      "滴滴",
      "携程",
      "B站",
      "腾讯"
    ]
  }
}