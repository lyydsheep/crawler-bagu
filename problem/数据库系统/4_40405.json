{
  "success": true,
  "data": {
    "id": 40405,
    "name": "<p>请讲一讲可重复读是怎么实现的</p>",
    "options": null,
    "answer": "<p>可重复读（Repeatable Read）是数据库事务的一种隔离级别，它保证在同一个事务中多次读取同一数据时，得到的结果是一致的，即不会出现不可重复读的问题（在一个事务内多次读取同一数据时，由于其他事务对该数据进行了修改并提交，导致每次读取的结果不同）。下面以常见的关系型数据库 MySQL 的 InnoDB 存储引擎为例，详细介绍可重复读是如何实现的。</p>\n<h3>实现原理</h3>\n<p>InnoDB 存储引擎通过多版本并发控制（MVCC，Multi-Version Concurrency Control）和间隙锁（Gap Lock）来实现可重复读隔离级别。</p>\n<h4>1. 多版本并发控制（MVCC）</h4>\n<p>MVCC 是一种在数据库中实现并发控制的技术，它通过为数据的每个版本维护一个时间戳或事务 ID，使得不同事务可以在不同版本的数据上进行操作，从而避免了读写冲突。在可重复读隔离级别下，MVCC 的实现主要依赖于以下几个关键机制：</p>\n<ul>\n  <li>\n    <p><strong>隐藏列</strong>：InnoDB 为表中的每一行记录添加了三个隐藏列：</p>\n    <ul>\n      <li><strong>DB_TRX_ID</strong>：记录最近一次对该记录进行修改的事务 ID。</li>\n      <li><strong>DB_ROLL_PTR</strong>：指向该记录的回滚段中的undo日志，用于在需要时恢复到之前的版本。</li>\n      <li><strong>DB_ROW_ID</strong>：如果表中没有主键或唯一非空索引，InnoDB 会自动生成一个行 ID。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>事务 ID</strong>：每个事务在启动时会被分配一个唯一的事务 ID，该 ID 是递增的。</p>\n  </li>\n  <li>\n    <p><strong>Read View</strong>：每个事务在启动时会生成一个 Read View，它包含了当前活跃事务的列表。Read View 用于判断一个记录的版本是否对当前事务可见。具体判断规则如下：</p>\n    <ul>\n      <li>如果记录的 DB_TRX_ID 小于 Read View 中最小的事务 ID，说明该记录在当前事务启动之前就已经被提交，对当前事务可见。</li>\n      <li>如果记录的 DB_TRX_ID 大于 Read View 中最大的事务 ID，说明该记录是在当前事务启动之后才开始的事务修改的，对当前事务不可见。</li>\n      <li>如果记录的 DB_TRX_ID 在 Read View 中最小和最大事务 ID 之间，需要检查该事务 ID 是否在 Read View 的活跃事务列表中。如果在列表中，说明该事务还未提交，对当前事务不可见；否则，说明该事务已经提交，对当前事务可见。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>Undo 日志</strong>：当一个事务对记录进行修改时，InnoDB 会将修改前的记录版本保存到 undo 日志中。如果当前事务在读取记录时发现某个版本对自己不可见，会通过 DB_ROLL_PTR 指针从 undo 日志中查找上一个可见的版本。</p>\n  </li>\n</ul>\n<p><strong>示例代码</strong>：</p>\n<pre><code class=\"language-sql\">-- 开启事务\nSTART TRANSACTION;\n-- 第一次读取数据\nSELECT * FROM users WHERE id = 1;\n-- 其他操作...\n-- 第二次读取数据\nSELECT * FROM users WHERE id = 1;\n-- 提交事务\nCOMMIT;\n</code></pre>\n<p>在这个示例中，由于 MVCC 的存在，两次读取的数据是一致的，即使在两次读取之间有其他事务修改了 <code>id = 1</code> 的记录。</p>\n<h4>2. 间隙锁（Gap Lock）</h4>\n<p>除了 MVCC 之外，InnoDB 在可重复读隔离级别下还会使用间隙锁来防止幻读（在一个事务内多次查询某个范围的数据时，由于其他事务插入了符合该范围的新记录，导致每次查询的结果不同）。</p>\n<ul>\n  <li>\n    <p><strong>间隙锁的作用</strong>：间隙锁是一种锁定索引记录之间间隙的锁，它可以防止其他事务在该间隙内插入新记录。当一个事务执行范围查询时，InnoDB 会对查询范围的间隙加锁，从而保证在该事务提交之前，不会有其他事务插入符合该范围的新记录。</p>\n  </li>\n  <li>\n    <p><strong>示例代码</strong>：</p>\n  </li>\n</ul>\n<pre><code class=\"language-sql\">-- 开启事务\nSTART TRANSACTION;\n-- 执行范围查询，会对查询范围的间隙加锁\nSELECT * FROM users WHERE age BETWEEN 20 AND 30 FOR UPDATE;\n-- 其他操作...\n-- 提交事务\nCOMMIT;\n</code></pre>\n<p>在这个示例中，<code>SELECT ... FOR UPDATE</code> 语句会对 <code>age</code> 字段在 20 到 30 之间的间隙加锁，防止其他事务在该间隙内插入新记录，从而避免了幻读的问题。</p>\n<h3>总结</h3>\n<p>通过多版本并发控制（MVCC）和间隙锁（Gap Lock），InnoDB 存储引擎在可重复读隔离级别下实现了事务的一致性和并发控制。MVCC 保证了在同一个事务中多次读取同一数据时，得到的结果是一致的，避免了不可重复读的问题；间隙锁则防止了幻读的发生，保证了事务的隔离性。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.002492522,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：可重复读是如何实现的。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对数据库事务隔离级别的理解，特别是可重复读。</li>\n      <li>多版本并发控制（MVCC）和锁机制的原理。</li>\n      <li>MVCC和锁机制在实现可重复读中的应用。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）可重复读隔离级别</h4>\n<p>可重复读是数据库事务的一种隔离级别，它保证在同一个事务中多次读取同一数据时，得到的结果是一致的，即不会出现不可重复读的问题（在一个事务内多次读取同一数据时，由于其他事务对该数据进行了修改，导致每次读取的结果不同）。</p>\n<h4>（2）多版本并发控制（MVCC）</h4>\n<p>MVCC是一种并发控制的方法，它通过为数据的每个版本维护一个时间戳或版本号，允许多个事务同时访问数据的不同版本，从而提高并发性能。</p>\n<h4>（3）锁机制</h4>\n<p>锁机制是数据库中用于控制并发访问的一种手段，通过对数据加锁，保证同一时间只有一个事务可以对数据进行修改，从而避免数据的不一致性。</p>\n<h3>3. 解析</h3>\n<h4>（1）MVCC实现可重复读</h4>\n<ul>\n  <li><strong>版本链</strong>：数据库为每行数据维护一个版本链，每个版本包含数据的内容以及创建和删除该版本的事务ID。当一个事务对数据进行修改时，会创建一个新的数据版本，并将其添加到版本链中。</li>\n  <li><strong>读视图</strong>：每个事务在启动时会生成一个读视图，该视图包含了当前活跃事务的ID列表。当事务读取数据时，会根据读视图和版本链来选择合适的数据版本。具体规则如下：\n    <ul>\n      <li>如果数据版本的创建事务ID小于读视图中最小的活跃事务ID，说明该版本在事务启动之前就已经提交，事务可以读取该版本。</li>\n      <li>如果数据版本的创建事务ID大于读视图中最大的活跃事务ID，说明该版本是在事务启动之后创建的，事务不能读取该版本。</li>\n      <li>如果数据版本的创建事务ID在读视图的活跃事务ID列表中，说明该版本是由一个还未提交的事务创建的，事务不能读取该版本。</li>\n    </ul>\n  </li>\n  <li><strong>实现原理</strong>：在可重复读隔离级别下，事务在整个生命周期内使用同一个读视图。因此，无论其他事务对数据进行了多少次修改，该事务每次读取到的数据版本都是一致的，从而实现了可重复读。</li>\n</ul>\n<h4>（2）锁机制实现可重复读</h4>\n<ul>\n  <li><strong>共享锁和排他锁</strong>：数据库使用共享锁（S锁）和排他锁（X锁）来控制并发访问。共享锁允许多个事务同时读取数据，但不允许其他事务修改数据；排他锁则只允许一个事务对数据进行读写操作。</li>\n  <li><strong>实现原理</strong>：在可重复读隔离级别下，当一个事务读取数据时，会对该数据加共享锁；当一个事务修改数据时，会对该数据加排他锁。由于共享锁和排他锁的互斥性，其他事务在该事务提交之前无法修改被锁定的数据，从而保证了在同一个事务中多次读取同一数据时结果的一致性。</li>\n</ul>\n<h4>（3）MVCC和锁机制的结合</h4>\n<p>大多数数据库系统会结合MVCC和锁机制来实现可重复读。MVCC用于提高并发性能，允许事务在不阻塞的情况下读取数据的不同版本；锁机制用于保证数据的一致性，防止其他事务在当前事务提交之前修改数据。</p>\n<h3>4. 示例代码（以MySQL为例）</h3>\n<pre><code class=\"language-sql\">-- 开启一个事务\nSTART TRANSACTION;\n\n-- 设置隔离级别为可重复读\nSET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n\n-- 第一次读取数据\nSELECT * FROM table_name WHERE condition;\n\n-- 模拟其他事务对数据进行修改\n-- 这里可以在另一个会话中执行修改操作\n\n-- 第二次读取数据\nSELECT * FROM table_name WHERE condition;\n\n-- 提交事务\nCOMMIT;\n</code></pre>\n<p>在这个例子中，由于设置了可重复读隔离级别，无论在第一次和第二次读取数据之间其他事务对数据进行了多少次修改，第二次读取到的数据结果都和第一次相同。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）认为MVCC可以完全替代锁机制</h4>\n<p>\n  误区：认为MVCC可以解决所有并发问题，不需要使用锁机制。\n  纠正：MVCC主要用于提高并发读的性能，但在处理写操作时，仍然需要使用锁机制来保证数据的一致性。\n</p>\n<h4>（2）混淆不同隔离级别下MVCC的实现</h4>\n<p>\n  误区：认为所有隔离级别下MVCC的实现都是相同的。\n  纠正：不同隔离级别下，事务生成读视图的时机和规则不同，从而导致MVCC的实现也有所不同。例如，在可重复读隔离级别下，事务在整个生命周期内使用同一个读视图；而在读已提交隔离级别下，事务在每次读取数据时都会生成一个新的读视图。\n</p>\n<h4>（3）忽视锁机制的性能影响</h4>\n<p>\n  误区：只关注MVCC的性能优势，忽视了锁机制可能带来的性能问题。\n  纠正：锁机制会导致事务之间的阻塞，从而影响并发性能。在设计数据库应用时，需要根据实际情况合理使用锁机制，避免过度加锁。\n</p>\n<h3>6. 总结回答</h3>\n<p>可重复读是数据库事务的一种隔离级别，它保证在同一个事务中多次读取同一数据时，得到的结果是一致的。可重复读通常通过多版本并发控制（MVCC）和锁机制来实现。</p>\n<p>MVCC通过为数据的每个版本维护一个时间戳或版本号，允许多个事务同时访问数据的不同版本。在可重复读隔离级别下，事务在启动时会生成一个读视图，该视图包含了当前活跃事务的ID列表。事务在读取数据时，会根据读视图和版本链来选择合适的数据版本。由于事务在整个生命周期内使用同一个读视图，因此无论其他事务对数据进行了多少次修改，该事务每次读取到的数据版本都是一致的。</p>\n<p>锁机制通过对数据加共享锁和排他锁来控制并发访问。在可重复读隔离级别下，当一个事务读取数据时，会对该数据加共享锁；当一个事务修改数据时，会对该数据加排他锁。由于共享锁和排他锁的互斥性，其他事务在该事务提交之前无法修改被锁定的数据，从而保证了在同一个事务中多次读取同一数据时结果的一致性。</p>\n<p>大多数数据库系统会结合MVCC和锁机制来实现可重复读，以提高并发性能并保证数据的一致性。需要注意的是，锁机制可能会导致事务之间的阻塞，影响并发性能，因此在设计数据库应用时，需要根据实际情况合理使用锁机制。</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      可重复读在不同数据库（如 MySQL、Oracle）中的实现细节有什么差异？\n      提示：考虑不同数据库的存储引擎、事务处理机制等方面。\n    </p>\n  </li>\n  <li>\n    <p>\n      可重复读隔离级别下，如何处理幻读问题？\n      提示：思考数据库为解决幻读采用的特殊技术或策略。\n    </p>\n  </li>\n  <li>\n    <p>\n      可重复读实现中 MVCC（多版本并发控制）的版本链和 ReadView 是如何协同工作的？\n      提示：关注版本链的生成和 ReadView 的判断逻辑。\n    </p>\n  </li>\n  <li>\n    <p>\n      可重复读对数据库性能有哪些影响，如何优化？\n      提示：从锁的使用、资源占用等方面考虑性能影响及优化方法。\n    </p>\n  </li>\n  <li>\n    <p>\n      在可重复读隔离级别下，事务回滚时对 MVCC 版本链有什么操作？\n      提示：结合事务回滚的原理和 MVCC 版本链的特点。\n    </p>\n  </li>\n  <li>\n    <p>\n      可重复读实现中，锁机制和 MVCC 是如何相互配合的？\n      提示：分析锁在不同场景下的作用以及与 MVCC 的互补关系。\n    </p>\n  </li>\n  <li>\n    <p>\n      可重复读隔离级别下，如何判断一个事务是否可以读取某个版本的数据？\n      提示：参考 ReadView 的判断规则。\n    </p>\n  </li>\n  <li>\n    <p>\n      当数据库并发事务较多时，可重复读的实现会面临哪些挑战？\n      提示：考虑资源竞争、性能瓶颈等方面。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((可重复读隔离级别在InnoDB中的实现))\n    定义\n      保证同一事务多次读同一数据结果一致\n      避免不可重复读问题\n    实现原理\n      多版本并发控制（MVCC）\n        关键机制\n          隐藏列\n            DB_TRX_ID\n            DB_ROLL_PTR\n            DB_ROW_ID\n          事务ID\n          Read View\n            判断记录版本可见规则\n          Undo日志\n      间隙锁（Gap Lock）\n        作用\n          防止幻读\n          锁定索引记录间隙\n    总结\n      MVCC保证数据读取一致性\n      间隙锁防止幻读",
    "keynote": "可重复读定义：同一事务多次读同一数据结果一致，避免不可重复读\n实现原理：\n  - MVCC：\n    - 隐藏列：DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID\n    - 事务ID：启动时分配，递增\n    - Read View：启动时生成，含活跃事务列表，判断记录版本可见性\n    - Undo日志：保存修改前记录版本\n  - 间隙锁：\n    - 作用：防止幻读，锁定索引记录间隙\n总结：MVCC保证读取一致，间隙锁防止幻读",
    "group_id": 4,
    "kps": [
      "事务与并发控制"
    ],
    "years": [
      2024,
      2023,
      2022
    ],
    "corps": [
      "小米",
      "阿里菜鸟",
      "腾讯",
      "美团",
      "快手",
      "满帮集团",
      "蚂蚁集团",
      "B站",
      "用友",
      "百度"
    ]
  }
}