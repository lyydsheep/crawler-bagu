{
  "success": true,
  "data": {
    "id": 16439,
    "name": "<p>事务有哪几种隔离级别</p>",
    "options": null,
    "answer": "<p>在数据库系统中，事务的隔离级别用于控制一个事务对数据的读写操作与其他事务之间的相互影响程度，主要有以下四种隔离级别：</p>\n<h3>1. 读未提交（Read Uncommitted）</h3>\n<ul>\n  <li><strong>定义</strong>：这是最低的隔离级别，允许一个事务读取另一个事务尚未提交的数据。</li>\n  <li><strong>特点</strong>\n    <ul>\n      <li><strong>并发性能高</strong>：由于不限制事务读取未提交的数据，所以在并发操作时，事务之间的等待时间较少，能提高系统的并发处理能力。</li>\n      <li><strong>存在脏读问题</strong>：一个事务读取到另一个事务未提交的数据，如果另一个事务回滚，那么读取到的数据就是无效的，这种情况称为脏读。</li>\n    </ul>\n  </li>\n  <li><strong>示例</strong></li>\n</ul>\n<pre><code class=\"language-sql\">-- 事务A\nBEGIN;\nUPDATE accounts SET balance = balance - 100 WHERE account_id = 1;\n-- 此时事务B可以读取到账户余额已经减少100的未提交数据\nROLLBACK;\n\n-- 事务B\nBEGIN;\nSELECT balance FROM accounts WHERE account_id = 1;\nCOMMIT;\n</code></pre>\n<h3>2. 读已提交（Read Committed）</h3>\n<ul>\n  <li><strong>定义</strong>：一个事务只能读取另一个事务已经提交的数据。</li>\n  <li><strong>特点</strong>\n    <ul>\n      <li><strong>避免脏读</strong>：由于只能读取已提交的数据，所以不会出现脏读的问题。</li>\n      <li><strong>存在不可重复读问题</strong>：在一个事务内，多次读取同一数据可能会得到不同的结果，因为在两次读取之间，其他事务可能已经对该数据进行了修改并提交。</li>\n    </ul>\n  </li>\n  <li><strong>示例</strong></li>\n</ul>\n<pre><code class=\"language-sql\">-- 事务A\nBEGIN;\nUPDATE accounts SET balance = balance - 100 WHERE account_id = 1;\nCOMMIT;\n\n-- 事务B\nBEGIN;\nSELECT balance FROM accounts WHERE account_id = 1; -- 第一次读取\n-- 此时事务A提交了修改\nSELECT balance FROM accounts WHERE account_id = 1; -- 第二次读取，可能得到不同的结果\nCOMMIT;\n</code></pre>\n<h3>3. 可重复读（Repeatable Read）</h3>\n<ul>\n  <li><strong>定义</strong>：在一个事务内，多次读取同一数据始终保持一致，即使其他事务对该数据进行了修改并提交。</li>\n  <li><strong>特点</strong>\n    <ul>\n      <li><strong>避免不可重复读</strong>：通过锁定读取的数据，保证在事务期间不会被其他事务修改，从而避免了不可重复读的问题。</li>\n      <li><strong>存在幻读问题</strong>：当一个事务在读取某个范围内的数据时，另一个事务在该范围内插入了新的数据，当前事务再次读取该范围的数据时，会发现多了一些数据，就好像出现了幻觉一样。</li>\n    </ul>\n  </li>\n  <li><strong>示例</strong></li>\n</ul>\n<pre><code class=\"language-sql\">-- 事务A\nBEGIN;\nSELECT * FROM orders WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31'; -- 第一次读取\n-- 此时事务B插入了一条新的订单记录，订单日期在该范围内\nSELECT * FROM orders WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31'; -- 第二次读取，可能会多一条记录\nCOMMIT;\n\n-- 事务B\nBEGIN;\nINSERT INTO orders (order_date, amount) VALUES ('2024-01-15', 100);\nCOMMIT;\n</code></pre>\n<h3>4. 串行化（Serializable）</h3>\n<ul>\n  <li><strong>定义</strong>：这是最高的隔离级别，事务串行执行，即一个事务执行完后才会执行下一个事务，相当于事务之间是完全隔离的。</li>\n  <li><strong>特点</strong>\n    <ul>\n      <li><strong>避免所有并发问题</strong>：由于事务是串行执行的，所以不会出现脏读、不可重复读和幻读的问题。</li>\n      <li><strong>并发性能低</strong>：因为事务需要依次执行，所以系统的并发处理能力会受到很大限制，性能较低。</li>\n    </ul>\n  </li>\n  <li><strong>示例</strong>：在串行化隔离级别下，事务会依次执行，不会出现并发冲突。</li>\n</ul>\n<pre><code class=\"language-sql\">-- 事务A\nBEGIN;\nUPDATE accounts SET balance = balance - 100 WHERE account_id = 1;\nCOMMIT;\n\n-- 事务B\nBEGIN;\nSELECT balance FROM accounts WHERE account_id = 1;\nCOMMIT;\n</code></pre>\n<p>不同的数据库系统对这些隔离级别的支持可能会有所不同，例如 MySQL 默认的隔离级别是可重复读，而 Oracle 默认的隔离级别是读已提交。</p>",
    "type": 6,
    "level": 1,
    "freq": 0.02143569,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：事务有哪几种隔离级别。</li>\n  <li><strong>考察点</strong>：对数据库事务隔离级别的了解，包括各隔离级别定义、特点及可能出现的问题。</li>\n</ul>\n<h3>2. 背景知识</h3>\n<ul>\n  <li><strong>事务</strong>：是数据库管理系统执行过程中的一个逻辑单位，由一组不可再分的操作序列构成，这些操作要么全部执行成功，要么全部不执行。</li>\n  <li><strong>隔离性</strong>：是事务的四大特性（ACID）之一，指多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别决定了事务之间的隔离程度。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）读未提交（Read Uncommitted）</h4>\n<ul>\n  <li><strong>定义</strong>：一个事务可以读取另一个未提交事务的数据。</li>\n  <li><strong>特点</strong>：是最低的隔离级别，并发性能最高，但会产生脏读问题。</li>\n  <li><strong>脏读</strong>：一个事务读取到了另一个未提交事务修改的数据，如果另一个事务回滚，那么读取到的数据就是无效的。</li>\n</ul>\n<h4>（2）读已提交（Read Committed）</h4>\n<ul>\n  <li><strong>定义</strong>：一个事务只能读取另一个已经提交事务的数据。</li>\n  <li><strong>特点</strong>：避免了脏读问题，但可能会出现不可重复读问题。</li>\n  <li><strong>不可重复读</strong>：在一个事务内，多次读取同一数据，由于其他事务对该数据进行了修改并提交，导致每次读取的结果不一致。</li>\n</ul>\n<h4>（3）可重复读（Repeatable Read）</h4>\n<ul>\n  <li><strong>定义</strong>：在一个事务内，多次读取同一数据的结果是一致的，即使其他事务对该数据进行了修改并提交。</li>\n  <li><strong>特点</strong>：避免了不可重复读问题，但可能会出现幻读问题。</li>\n  <li><strong>幻读</strong>：在一个事务内，按照一定条件进行范围查询时，由于其他事务插入或删除了符合条件的数据，导致两次查询的结果集不一致。</li>\n</ul>\n<h4>（4）串行化（Serializable）</h4>\n<ul>\n  <li><strong>定义</strong>：所有事务依次逐个执行，事务之间完全隔离，不存在并发问题。</li>\n  <li><strong>特点</strong>：是最高的隔离级别，避免了脏读、不可重复读和幻读问题，但并发性能最低。</li>\n</ul>\n<h3>4. 示例说明</h3>\n<p>假设数据库中有一个表<code>orders</code>，包含<code>order_id</code>和<code>amount</code>字段。有两个事务<code>T1</code>和<code>T2</code>并发执行。</p>\n<ul>\n  <li><strong>读未提交</strong>：\n    <ul>\n      <li><code>T1</code>开始事务，修改<code>order_id = 1</code>的<code>amount</code>为 200，但未提交。</li>\n      <li><code>T2</code>开始事务，读取<code>order_id = 1</code>的<code>amount</code>，此时<code>T2</code>能读到<code>amount</code>为 200。如果<code>T1</code>回滚，<code>T2</code>读到的就是脏数据。</li>\n    </ul>\n  </li>\n  <li><strong>读已提交</strong>：\n    <ul>\n      <li><code>T1</code>开始事务，修改<code>order_id = 1</code>的<code>amount</code>为 200，但未提交。</li>\n      <li><code>T2</code>开始事务，读取<code>order_id = 1</code>的<code>amount</code>，此时<code>T2</code>读不到<code>T1</code>未提交的修改。当<code>T1</code>提交后，<code>T2</code>再次读取<code>order_id = 1</code>的<code>amount</code>，会发现结果与第一次不同，出现不可重复读。</li>\n    </ul>\n  </li>\n  <li><strong>可重复读</strong>：\n    <ul>\n      <li><code>T1</code>开始事务，查询<code>amount > 100</code>的订单数量。</li>\n      <li><code>T2</code>开始事务，插入一条<code>amount = 150</code>的订单并提交。</li>\n      <li><code>T1</code>再次查询<code>amount > 100</code>的订单数量，结果与第一次相同，但实际上数据库中已经有了新的符合条件的记录，出现幻读。</li>\n    </ul>\n  </li>\n  <li><strong>串行化</strong>：\n    <ul>\n      <li><code>T1</code>和<code>T2</code>依次执行，不会出现上述的脏读、不可重复读和幻读问题，但并发性能最差。</li>\n    </ul>\n  </li>\n</ul>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆各隔离级别特点</h4>\n<ul>\n  <li>误区：不能准确区分不同隔离级别会出现的问题，如认为读已提交会出现脏读。</li>\n  <li>纠正：明确各隔离级别定义和可能出现的问题，读未提交会出现脏读，读已提交避免脏读但有不可重复读，可重复读避免不可重复读但有幻读，串行化避免所有问题。</li>\n</ul>\n<h4>（2）忽视隔离级别与并发性能关系</h4>\n<ul>\n  <li>误区：只关注隔离级别对数据一致性的影响，忽略了不同隔离级别对并发性能的影响。</li>\n  <li>纠正：理解隔离级别越高，并发性能越低，在实际应用中需要根据业务需求平衡数据一致性和并发性能。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>事务有四种隔离级别，分别是读未提交、读已提交、可重复读和串行化。</p>\n<ul>\n  <li>读未提交：一个事务可以读取另一个未提交事务的数据，会产生脏读问题，是最低的隔离级别，并发性能最高。</li>\n  <li>读已提交：一个事务只能读取另一个已经提交事务的数据，避免了脏读，但可能出现不可重复读问题。</li>\n  <li>可重复读：在一个事务内多次读取同一数据结果一致，避免了不可重复读，但可能出现幻读问题。</li>\n  <li>串行化：所有事务依次逐个执行，事务之间完全隔离，避免了脏读、不可重复读和幻读问题，但并发性能最低。</li>\n</ul>\n<p>在实际应用中，需要根据业务对数据一致性和并发性能的要求来选择合适的隔离级别。</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      不同隔离级别下，数据库如何处理读写冲突？\n      提示：思考在每个隔离级别中，当一个事务进行读操作，另一个事务进行写操作时，数据库采取的具体策略。\n    </p>\n  </li>\n  <li>\n    <p>\n      可串行化隔离级别在实际应用中有什么优缺点？\n      提示：从数据一致性和性能两方面去分析可串行化隔离级别在实际场景中的表现。\n    </p>\n  </li>\n  <li>\n    <p>\n      请举例说明在可重复读隔离级别下可能出现的问题。\n      提示：考虑在一个事务执行过程中，其他事务的操作对当前事务读取数据的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      数据库是如何实现读未提交隔离级别的？\n      提示：关注数据库在该隔离级别下对锁的使用或者其他并发控制机制。\n    </p>\n  </li>\n  <li>\n    <p>\n      若要在不同隔离级别间进行切换，会对数据库性能和数据一致性产生怎样的影响？\n      提示：分别从性能（如响应时间、吞吐量）和数据一致性（如脏读、幻读等情况）两方面分析。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((数据库事务隔离级别))\n    读未提交（Read Uncommitted）\n      定义：允许读未提交数据\n      特点\n        并发性能高\n        存在脏读问题\n    读已提交（Read Committed）\n      定义：只能读已提交数据\n      特点\n        避免脏读\n        存在不可重复读问题\n    可重复读（Repeatable Read）\n      定义：事务内多次读同一数据一致\n      特点\n        避免不可重复读\n        存在幻读问题\n    串行化（Serializable）\n      定义：事务串行执行\n      特点\n        避免所有并发问题\n        并发性能低\n    不同数据库支持差异\n      MySQL默认：可重复读\n      Oracle默认：读已提交",
    "keynote": "事务隔离级别控制事务读写操作相互影响程度，有四种：\n- 读未提交：允许读未提交数据，并发高，有脏读问题\n- 读已提交：只能读已提交数据，避免脏读，有不可重复读问题\n- 可重复读：事务内读数据一致，避免不可重复读，有幻读问题\n- 串行化：事务串行执行，避免并发问题，并发性能低\n不同数据库支持有差异，MySQL默认可重复读，Oracle默认读已提交",
    "group_id": 4,
    "kps": [
      "事务与并发控制"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "微企信息",
      "百考丝信息科技",
      "合思",
      "字节跳动",
      "北京小厂",
      "京天威",
      "阿里巴巴",
      "王牌互娱",
      "网易",
      "美团",
      "长亭科技",
      "联想集团",
      "字节抖音",
      "字节飞书",
      "松鼠AI",
      "腾讯",
      "美团优选",
      "钉钉",
      "银泰集团",
      "百度",
      "京东",
      "快手",
      "度小满",
      "满帮集团",
      "小米",
      "滴滴",
      "拼多多",
      "携程",
      "蚂蚁集团",
      "360",
      "贝壳",
      "大华",
      "用友",
      "远景科技",
      "小红书",
      "同程旅行",
      "货拉拉",
      "饿了么",
      "酷家乐",
      "星环科技",
      "58同城",
      "腾讯PCG",
      "腾讯微信"
    ]
  }
}