{
  "success": true,
  "data": {
    "id": 26595,
    "name": "<p>请解释悲观锁和乐观锁，并说明它们的区别</p>",
    "options": null,
    "answer": "<h3>悲观锁</h3>\n<h4>定义</h4>\n<p>悲观锁（Pessimistic Locking）是一种基于悲观思想的并发控制机制。它认为在并发环境下，不同事务对同一资源的访问很可能会发生冲突，所以在对数据进行操作之前，就会先对该数据进行加锁，防止其他事务对其进行修改，直到当前事务完成操作并释放锁。</p>\n<h4>实现方式</h4>\n<ul>\n  <li><strong>数据库层面</strong>：在数据库中，悲观锁通常通过数据库的锁机制来实现，例如行级锁、表级锁等。以 MySQL 为例，在使用 <code>SELECT</code> 语句时可以使用 <code>FOR UPDATE</code> 关键字来对查询的行加排他锁。</li>\n</ul>\n<pre><code class=\"language-sql\">-- 开启事务\nSTART TRANSACTION;\n-- 对 id 为 1 的记录加排他锁\nSELECT * FROM table_name WHERE id = 1 FOR UPDATE;\n-- 进行数据修改操作\nUPDATE table_name SET column_name = 'new_value' WHERE id = 1;\n-- 提交事务，释放锁\nCOMMIT;\n</code></pre>\n<ul>\n  <li><strong>代码层面</strong>：在编程语言中，也可以使用锁机制来实现悲观锁，例如 Java 中的 <code>synchronized</code> 关键字和 <code>ReentrantLock</code> 类。</li>\n</ul>\n<h4>适用场景</h4>\n<p>适用于并发冲突概率较高的场景，例如金融系统中的账户余额修改、库存管理等，这些场景对数据的一致性要求非常高，一旦出现数据冲突可能会导致严重的后果。</p>\n<h3>乐观锁</h3>\n<h4>定义</h4>\n<p>乐观锁（Optimistic Locking）是一种基于乐观思想的并发控制机制。它认为在大多数情况下，不同事务对同一资源的访问不会发生冲突，所以在对数据进行操作时，不会先对数据加锁，而是在更新数据时检查数据是否被其他事务修改过。如果没有被修改过，则进行更新操作；如果被修改过，则放弃本次操作或者进行重试。</p>\n<h4>实现方式</h4>\n<ul>\n  <li><strong>版本号机制</strong>：在数据库表中添加一个 <code>version</code> 字段，用于记录数据的版本号。每次更新数据时，会先查询数据的版本号，然后在更新语句中添加版本号的条件。如果更新成功，则表示数据没有被其他事务修改过；如果更新失败，则表示数据已经被其他事务修改过。</li>\n</ul>\n<pre><code class=\"language-sql\">-- 假设表中有 id、column_name 和 version 字段\n-- 查询数据及其版本号\nSELECT id, column_name, version FROM table_name WHERE id = 1;\n-- 更新数据并更新版本号\nUPDATE table_name \nSET column_name = 'new_value', version = version + 1 \nWHERE id = 1 AND version = [查询到的版本号];\n</code></pre>\n<ul>\n  <li><strong>时间戳机制</strong>：与版本号机制类似，只是使用时间戳来记录数据的修改时间。在更新数据时，检查时间戳是否与查询时一致。</li>\n</ul>\n<h4>适用场景</h4>\n<p>适用于并发冲突概率较低的场景，例如论坛的帖子浏览量统计、文章点赞数统计等，这些场景对数据的一致性要求相对较低，偶尔出现数据冲突也不会对系统造成严重影响。</p>\n<h3>区别</h3>\n<h4>锁的获取时机</h4>\n<ul>\n  <li><strong>悲观锁</strong>：在操作数据之前就会获取锁，确保在自己操作数据的过程中，其他事务无法对该数据进行修改。</li>\n  <li><strong>乐观锁</strong>：在操作数据时不会获取锁，只有在更新数据时才会检查数据是否被其他事务修改过。</li>\n</ul>\n<h4>性能开销</h4>\n<ul>\n  <li><strong>悲观锁</strong>：由于在操作数据之前就加锁，会导致其他事务需要等待锁的释放，从而增加了系统的等待时间，降低了并发性能。特别是在高并发场景下，锁的竞争会非常激烈，性能开销较大。</li>\n  <li><strong>乐观锁</strong>：不需要加锁，不会产生锁的竞争，因此在并发性能上相对较高。但是，如果数据冲突频繁发生，会导致大量的更新操作失败，需要进行重试，也会增加一定的性能开销。</li>\n</ul>\n<h4>数据一致性</h4>\n<ul>\n  <li><strong>悲观锁</strong>：通过加锁的方式，确保在同一时间只有一个事务可以对数据进行修改，从而保证了数据的强一致性。</li>\n  <li><strong>乐观锁</strong>：在数据冲突较少的情况下，可以保证数据的最终一致性；但在数据冲突频繁的情况下，可能会出现数据不一致的情况，需要进行额外的处理。</li>\n</ul>\n<h4>应用场景</h4>\n<ul>\n  <li><strong>悲观锁</strong>：适用于对数据一致性要求较高、并发冲突概率较大的场景。</li>\n  <li><strong>乐观锁</strong>：适用于对数据一致性要求相对较低、并发冲突概率较小的场景。</li>\n</ul>",
    "type": 6,
    "level": 1,
    "freq": 0.03215354,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：解释悲观锁和乐观锁，并说明它们的区别。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对悲观锁和乐观锁概念的理解。</li>\n      <li>掌握悲观锁和乐观锁的使用场景。</li>\n      <li>明确两者在实现方式、性能、并发处理等方面的区别。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）数据库并发问题</h4>\n<p>在多用户同时访问数据库时，可能会出现数据不一致的问题，如脏读、不可重复读、幻读等。为了解决这些问题，需要使用锁机制来保证数据的一致性和完整性。</p>\n<h4>（2）锁的基本概念</h4>\n<p>锁是一种并发控制机制，用于限制对共享资源的访问，确保在同一时间只有一个或多个特定的操作可以访问该资源。</p>\n<h3>3. 解析</h3>\n<h4>（1）悲观锁</h4>\n<ul>\n  <li><strong>概念</strong>：悲观锁认为在并发环境下，数据随时可能被其他事务修改，因此在对数据进行操作之前，先对数据加锁，防止其他事务对其进行修改。只有当持有锁的事务完成操作并释放锁后，其他事务才能继续操作该数据。</li>\n  <li><strong>实现方式</strong>：在数据库中，悲观锁通常通过数据库的锁机制来实现，如行级锁、表级锁等。例如，在MySQL中，可以使用<code>SELECT ... FOR UPDATE</code>语句来对查询的行加排他锁。</li>\n  <li><strong>使用场景</strong>：适用于对数据一致性要求较高，且并发冲突可能性较大的场景，如金融交易、库存管理等。</li>\n</ul>\n<h4>（2）乐观锁</h4>\n<ul>\n  <li><strong>概念</strong>：乐观锁认为在大多数情况下，数据不会发生冲突，因此在操作数据时不会加锁。而是在更新数据时，检查数据是否被其他事务修改过。如果数据没有被修改，则进行更新操作；如果数据已经被修改，则放弃本次操作或进行重试。</li>\n  <li><strong>实现方式</strong>：乐观锁通常通过版本号机制或时间戳机制来实现。在表中添加一个版本号字段或时间戳字段，每次更新数据时，先读取数据的版本号或时间戳，在更新时检查该版本号或时间戳是否与读取时一致。如果一致，则更新数据并将版本号加1；如果不一致，则表示数据已被其他事务修改，放弃本次更新。</li>\n  <li><strong>使用场景</strong>：适用于并发冲突较少，对性能要求较高的场景，如社交网络的点赞、评论等。</li>\n</ul>\n<h4>（3）两者区别</h4>\n<ul>\n  <li><strong>加锁时机</strong>：悲观锁在操作数据之前加锁，而乐观锁在操作数据时不加锁，在更新数据时进行检查。</li>\n  <li><strong>性能影响</strong>：悲观锁由于在操作数据时加锁，会阻塞其他事务对该数据的访问，可能会导致性能下降，尤其是在高并发场景下。乐观锁在操作数据时不加锁，不会阻塞其他事务，因此性能相对较高。</li>\n  <li><strong>并发处理能力</strong>：悲观锁通过加锁来保证数据的一致性，同一时间只有一个事务可以操作数据，并发处理能力较低。乐观锁允许多个事务同时操作数据，只有在更新数据时才进行冲突检查，并发处理能力较高。</li>\n  <li><strong>冲突处理方式</strong>：悲观锁在发生冲突时，其他事务会被阻塞，直到持有锁的事务释放锁。乐观锁在发生冲突时，通常会放弃本次操作或进行重试。</li>\n</ul>\n<h3>4. 示例代码（以MySQL为例）</h3>\n<h4>（1）悲观锁示例</h4>\n<pre><code class=\"language-sql\">-- 开启事务\nSTART TRANSACTION;\n-- 对id为1的记录加排他锁\nSELECT * FROM products WHERE id = 1 FOR UPDATE;\n-- 进行业务操作，如更新库存\nUPDATE products SET stock = stock - 1 WHERE id = 1;\n-- 提交事务\nCOMMIT;\n</code></pre>\n<h4>（2）乐观锁示例</h4>\n<pre><code class=\"language-sql\">-- 表结构，包含版本号字段\nCREATE TABLE products (\n    id INT PRIMARY KEY,\n    name VARCHAR(100),\n    stock INT,\n    version INT\n);\n\n-- 开启事务\nSTART TRANSACTION;\n-- 读取数据和版本号\nSELECT id, stock, version FROM products WHERE id = 1;\n-- 假设读取到的版本号为1\n-- 进行业务操作，如更新库存\nUPDATE products SET stock = stock - 1, version = version + 1 WHERE id = 1 AND version = 1;\n-- 检查更新行数\nSELECT ROW_COUNT();\n-- 如果更新行数为1，表示更新成功，提交事务\n-- 如果更新行数为0，表示数据已被其他事务修改，回滚事务\nCOMMIT;\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆概念</h4>\n<ul>\n  <li>误区：将悲观锁和乐观锁的概念混淆，不清楚它们的区别和使用场景。</li>\n  <li>纠正：明确悲观锁和乐观锁的定义、实现方式和适用场景，根据具体业务需求选择合适的锁机制。</li>\n</ul>\n<h4>（2）过度使用悲观锁</h4>\n<ul>\n  <li>误区：在所有场景下都使用悲观锁，忽略了乐观锁的优势。</li>\n  <li>纠正：在并发冲突较少的场景下，优先考虑使用乐观锁，以提高系统的性能和并发处理能力。</li>\n</ul>\n<h4>（3）忽略冲突处理</h4>\n<ul>\n  <li>误区：使用乐观锁时，没有考虑到数据冲突的情况，导致数据不一致。</li>\n  <li>纠正：在使用乐观锁时，需要在更新数据时进行冲突检查，并根据检查结果进行相应的处理，如放弃操作或进行重试。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“悲观锁和乐观锁是数据库中用于解决并发问题的两种锁机制。</p>\n<p>悲观锁认为数据随时可能被其他事务修改，因此在操作数据之前先对数据加锁，防止其他事务对其进行修改。它通常通过数据库的锁机制实现，如行级锁、表级锁等。适用于对数据一致性要求较高，且并发冲突可能性较大的场景。</p>\n<p>乐观锁认为在大多数情况下数据不会发生冲突，因此在操作数据时不加锁，而是在更新数据时检查数据是否被其他事务修改过。它通常通过版本号机制或时间戳机制实现。适用于并发冲突较少，对性能要求较高的场景。</p>\n<p>两者的区别主要体现在加锁时机、性能影响、并发处理能力和冲突处理方式上。悲观锁在操作数据之前加锁，会阻塞其他事务，性能相对较低，并发处理能力较差，冲突时其他事务会被阻塞。乐观锁在操作数据时不加锁，不会阻塞其他事务，性能相对较高，并发处理能力较强，冲突时通常会放弃操作或进行重试。”</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      在实际项目中，什么场景下适合使用悲观锁，什么场景适合使用乐观锁？\n      提示：从数据冲突频率、业务并发程度等方面思考不同场景特点。\n    </p>\n  </li>\n  <li>\n    <p>\n      悲观锁在数据库中通常是如何实现的，以 MySQL 为例说明。\n      提示：考虑 MySQL 不同存储引擎下的锁机制，如行锁、表锁等。\n    </p>\n  </li>\n  <li>\n    <p>\n      乐观锁实现时，版本号机制和时间戳机制各有什么优缺点？\n      提示：从数据一致性、性能开销、并发处理能力等角度分析。\n    </p>\n  </li>\n  <li>\n    <p>\n      当使用乐观锁时，如果出现大量的更新冲突，应该如何解决？\n      提示：可以从业务逻辑调整、重试策略、锁机制转换等方面考虑。\n    </p>\n  </li>\n  <li>\n    <p>\n      悲观锁会对数据库性能产生哪些影响，如何优化？\n      提示：分析锁的粒度、持有时间等因素对性能的影响及优化方法。\n    </p>\n  </li>\n  <li>\n    <p>\n      请说明乐观锁在分布式系统中可能会遇到的问题及解决方案。\n      提示：考虑分布式环境下的数据一致性、网络延迟等问题。\n    </p>\n  </li>\n  <li>\n    <p>\n      若一个业务系统中既有读操作又有写操作，如何合理搭配使用悲观锁和乐观锁？\n      提示：根据读写操作的特点、并发情况等进行搭配。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((并发控制机制))\n    悲观锁\n      定义\n        基于悲观思想\n        操作前加锁防冲突\n      实现方式\n        数据库层面\n          行级锁、表级锁\n          MySQL的FOR UPDATE\n        代码层面\n          Java的synchronized\n          Java的ReentrantLock\n      适用场景\n        并发冲突概率高\n        金融账户、库存管理\n    乐观锁\n      定义\n        基于乐观思想\n        更新时检查是否修改\n      实现方式\n        版本号机制\n          表中添加version字段\n          更新时检查版本号\n        时间戳机制\n          用时间戳记录修改时间\n          更新时检查时间戳\n      适用场景\n        并发冲突概率低\n        论坛浏览量、点赞数统计\n    区别\n      锁的获取时机\n        悲观锁：操作前获取\n        乐观锁：更新时检查\n      性能开销\n        悲观锁：增加等待时间\n        乐观锁：冲突频繁需重试\n      数据一致性\n        悲观锁：强一致性\n        乐观锁：最终一致性\n      应用场景\n        悲观锁：一致性要求高\n        乐观锁：一致性要求低",
    "keynote": "悲观锁：基于悲观思想，操作前加锁，数据库用行/表级锁、MySQL的FOR UPDATE，代码用Java的synchronized和ReentrantLock，适用于并发冲突高场景\n乐观锁：基于乐观思想，更新时检查，有版本号和时间戳机制，适用于并发冲突低场景\n区别：获取时机（操作前/更新时）、性能开销（等待/重试）、数据一致性（强/最终）、应用场景（高要求/低要求）",
    "group_id": 4,
    "kps": [
      "事务与并发控制"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "字节跳动",
      "美团",
      "高德地图",
      "华为",
      "拼多多",
      "百度",
      "快手",
      "合思",
      "顽岩资产",
      "网易",
      "Shopee虾皮",
      "携程",
      "京东",
      "友塔",
      "麦当劳",
      "牧原集团",
      "厦门用友烟草",
      "京天威",
      "游卡",
      "多益网络",
      "王牌互娱",
      "腾讯",
      "KN GROUP",
      "阿里菜鸟",
      "西安思科特",
      "影石",
      "小红书",
      "米哈游",
      "阿里国际",
      "爱奇艺",
      "作业帮",
      "云深网络",
      "美团优选",
      "淘天集团",
      "阿里巴巴",
      "好未来",
      "腾讯音乐",
      "途虎养车",
      "满帮集团",
      "滴滴",
      "CVTE视源股份",
      "蚂蚁集团",
      "大华",
      "B站",
      "用友",
      "微众银行",
      "中国联通",
      "知乎",
      "帆软",
      "同盾",
      "小米",
      "猿辅导",
      "顺丰",
      "饿了么",
      "字节飞书",
      "美团骑行",
      "腾讯云",
      "度小满",
      "字节懂车帝"
    ]
  }
}