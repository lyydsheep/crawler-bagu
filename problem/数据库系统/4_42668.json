{
  "success": true,
  "data": {
    "id": 42668,
    "name": "<p>在SQL语句select * from table where a=1 and b=2 order by c中，索引(a,b,c)是否生效？</p>",
    "options": null,
    "answer": "<p>在 <code>select * from table where a=1 and b=2 order by c</code> 这条 SQL 语句中，索引 <code>(a,b,c)</code> 是可以生效的，下面从索引的原理和该语句的执行情况来详细分析：</p>\n<h3>索引生效原理</h3>\n<p>数据库的复合索引遵循最左前缀原则，即索引会优先匹配复合索引中最左边的列，然后依次向右匹配。对于复合索引 <code>(a,b,c)</code>，它可以用于以下几种情况：</p>\n<ul>\n  <li>仅使用 <code>a</code> 列进行查询，例如 <code>where a = 1</code>。</li>\n  <li>使用 <code>a</code> 和 <code>b</code> 列进行查询，例如 <code>where a = 1 and b = 2</code>。</li>\n  <li>使用 <code>a</code>、<code>b</code> 和 <code>c</code> 列进行查询，例如 <code>where a = 1 and b = 2 and c = 3</code>。</li>\n</ul>\n<h3>该 SQL 语句中索引的生效情况</h3>\n<ul>\n  <li><strong><code>where</code> 子句部分</strong>：\n    <ul>\n      <li>语句中的 <code>where a = 1 and b = 2</code> 满足最左前缀原则。数据库可以利用索引 <code>(a,b,c)</code> 快速定位到 <code>a</code> 列值为 1 且 <code>b</code> 列值为 2 的记录，因为索引是按照 <code>a</code>、<code>b</code>、<code>c</code> 的顺序存储的，所以可以高效地过滤出符合条件的记录。</li>\n    </ul>\n  </li>\n  <li><strong><code>order by</code> 子句部分</strong>：\n    <ul>\n      <li>在 <code>where</code> 子句过滤出 <code>a = 1 and b = 2</code> 的记录后，这些记录在索引中已经是按照 <code>c</code> 列有序排列的（因为索引是 <code>(a,b,c)</code>）。所以数据库可以直接利用索引的有序性来完成 <code>order by c</code> 的排序操作，而不需要额外的排序步骤，从而提高了排序的效率。</li>\n    </ul>\n  </li>\n</ul>\n<h3>示例代码验证（以 MySQL 为例）</h3>\n<pre><code class=\"language-sql\">-- 创建测试表\nCREATE TABLE test_table (\n    a INT,\n    b INT,\n    c INT\n);\n\n-- 创建复合索引\nCREATE INDEX idx_a_b_c ON test_table (a, b, c);\n\n-- 插入一些测试数据\nINSERT INTO test_table (a, b, c) VALUES (1, 2, 3), (1, 2, 1), (1, 2, 2);\n\n-- 使用 EXPLAIN 分析查询语句\nEXPLAIN SELECT * FROM test_table WHERE a = 1 AND b = 2 ORDER BY c;\n</code></pre>\n<p>在执行 <code>EXPLAIN</code> 语句后，可以查看结果中的 <code>key</code> 列，如果显示为 <code>idx_a_b_c</code>，则表示该索引被使用了。</p>\n<p>综上所述，索引 <code>(a,b,c)</code> 在 <code>select * from table where a=1 and b=2 order by c</code> 语句中是生效的。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.001744766,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：在SQL语句<code>select * from table where a=1 and b=2 order by c</code>中，索引<code>(a,b,c)</code>是否生效。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对数据库索引原理的理解。</li>\n      <li>复合索引的使用规则。</li>\n      <li>SQL查询语句中索引的匹配和优化。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）复合索引</h4>\n<p>复合索引是指在多个列上创建的索引。在数据库中，复合索引的使用遵循最左前缀原则，即查询时从索引的最左边列开始匹配，只有当最左边的列被使用时，后续的列才有可能被使用。</p>\n<h4>（2）索引生效条件</h4>\n<p>索引生效需要满足查询条件与索引列的匹配规则，同时数据库查询优化器会根据查询语句和表的统计信息来决定是否使用索引。</p>\n<h3>3. 解析</h3>\n<h4>（1）索引<code>(a,b,c)</code>的匹配情况</h4>\n<p>在SQL语句<code>select * from table where a=1 and b=2 order by c</code>中，查询条件<code>a=1</code>和<code>b=2</code>满足最左前缀原则，因为索引<code>(a,b,c)</code>是从最左边的列<code>a</code>开始匹配，接着是<code>b</code>。所以，对于<code>where</code>子句中的<code>a=1 and b=2</code>，索引<code>(a,b)</code>部分会生效。</p>\n<h4>（2）<code>order by c</code>对索引的影响</h4>\n<p>由于前面<code>where</code>子句已经使用了索引的前两列<code>a</code>和<code>b</code>，而<code>order by c</code>使用的是索引的第三列。在满足最左前缀原则的基础上，<code>order by c</code>可以直接利用索引<code>(a,b,c)</code>中的<code>c</code>列进行排序，避免了额外的排序操作。因此，索引的第三列<code>c</code>也会生效。</p>\n<h4>（3）整体索引生效情况</h4>\n<p>综合来看，索引<code>(a,b,c)</code>在这个SQL语句中是生效的。数据库可以利用该索引快速定位满足<code>a=1 and b=2</code>条件的记录，并且利用索引中的<code>c</code>列进行排序。</p>\n<h3>4. 示例说明</h3>\n<p>假设存在一个表<code>test_table</code>，包含列<code>a</code>、<code>b</code>、<code>c</code>，并且在这三列上创建了复合索引<code>(a,b,c)</code>。执行以下SQL语句：</p>\n<pre><code class=\"language-sql\">select * from test_table where a=1 and b=2 order by c;\n</code></pre>\n<p>数据库会首先根据索引<code>(a,b,c)</code>中的<code>a</code>和<code>b</code>列定位满足<code>a=1 and b=2</code>的记录，然后直接利用索引中的<code>c</code>列对这些记录进行排序，而不需要对结果集进行额外的排序操作。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）忽略最左前缀原则</h4>\n<p>\n  误区：认为只要索引包含了查询条件和排序字段，就一定能生效，而不考虑最左前缀原则。\n  纠正：必须从索引的最左边列开始匹配，只有满足最左前缀原则，后续的列才有可能被使用。\n</p>\n<h4>（2）错误判断排序字段对索引的影响</h4>\n<p>\n  误区：认为<code>order by</code>子句中的字段与索引列的顺序不一致时，索引就不会生效。\n  纠正：在满足最左前缀原则的基础上，<code>order by</code>子句中的字段如果是索引的后续列，仍然可以利用索引进行排序。\n</p>\n<h3>6. 总结回答</h3>\n<p>在SQL语句<code>select * from table where a=1 and b=2 order by c</code>中，索引<code>(a,b,c)</code>是生效的。因为查询条件<code>a=1 and b=2</code>满足复合索引的最左前缀原则，数据库可以利用索引的前两列<code>a</code>和<code>b</code>快速定位满足条件的记录。同时，<code>order by c</code>可以直接利用索引中的第三列<code>c</code>进行排序，避免了额外的排序操作。</p>\n<p>不过，索引的实际使用情况还可能受到数据库查询优化器、表的统计信息等因素的影响。在实际应用中，可以通过数据库的执行计划来查看索引的具体使用情况。</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      若将查询条件改为 <code>select * from table where a > 1 and b = 2 order by c</code>，索引(a,b,c)是否还能完全生效？\n      提示：考虑范围查询对索引使用的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      在索引(a,b,c)存在的情况下，<code>select * from table where a = 1 order by b, c</code> 语句中索引是如何生效的？\n      提示：分析查询条件和排序条件与索引列的匹配情况。\n    </p>\n  </li>\n  <li>\n    <p>\n      对于 <code>select * from table where a = 1 and b = 2 order by c</code> 语句，如果表中数据量非常大，使用索引(a,b,c)一定能提高查询性能吗？为什么？\n      提示：思考索引使用的代价和场景。\n    </p>\n  </li>\n  <li>\n    <p>\n      若索引顺序改为(b,a,c)，<code>select * from table where a = 1 and b = 2 order by c</code> 语句的索引生效情况会有什么变化？\n      提示：关注索引列顺序对查询的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      当执行 <code>select * from table where a = 1 and b = 2 order by c</code> 时，数据库是如何利用索引(a,b,c)进行排序的？\n      提示：了解数据库排序的底层原理和索引的作用。\n    </p>\n  </li>\n  <li>\n    <p>\n      如果在表中新增一个字段d，并创建索引(a,b,c,d)，原查询 <code>select * from table where a = 1 and b = 2 order by c</code> 的索引生效情况会改变吗？\n      提示：分析新增索引列对原有查询的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      对于 <code>select * from table where a = 1 and b = 2 order by c</code>，如果索引(a,b,c)是组合索引且为非聚集索引，查询过程和性能与聚集索引有何不同？\n      提示：区分聚集索引和非聚集索引的特点。\n    </p>\n  </li>\n  <li>\n    <p>\n      若查询语句变为 <code>select c from table where a = 1 and b = 2 order by c</code>，索引(a,b,c)的使用情况有什么不同？\n      提示：考虑查询投影列对索引使用的影响。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((SQL语句索引(a,b,c)生效分析))\n    索引生效原理\n      最左前缀原则\n      适用情况\n        仅用a列查询\n        用a和b列查询\n        用a、b和c列查询\n    该SQL语句中索引生效情况\n      where子句部分\n        满足最左前缀原则\n        高效过滤记录\n      order by子句部分\n        利用索引有序性排序\n        提高排序效率\n    示例代码验证\n      创建测试表\n      创建复合索引\n      插入测试数据\n      使用EXPLAIN分析\n      查看key列判断索引使用",
    "keynote": "索引生效原理：复合索引遵循最左前缀原则，优先匹配最左列，依次向右匹配；适用情况有仅用a列、用a和b列、用a、b和c列查询\n该SQL语句索引生效情况：where子句满足最左前缀原则，可高效过滤记录；order by子句利用索引有序性排序，提高效率\n示例代码验证：创建测试表、复合索引，插入数据，用EXPLAIN分析，查看key列判断索引使用",
    "group_id": 4,
    "kps": [
      "索引与查询优化"
    ],
    "years": [
      2024,
      2023
    ],
    "corps": [
      "某二次元大厂",
      "米哈游",
      "美团",
      "滴滴",
      "携程"
    ]
  }
}