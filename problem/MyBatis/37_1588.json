{
  "success": true,
  "data": {
    "id": 1588,
    "name": "<p>#{}和${}的区别是什么？</p>",
    "options": null,
    "answer": "<p>在 MyBatis 中，<code>#{}</code> 和 <code>${}</code> 有着不同的作用和用法，主要体现在参数的传递方式以及 SQL 语句的构建上。</p>\n<h3><code>#{}</code></h3>\n<ul>\n  <li><strong>用途</strong>：用于安全地传递参数。</li>\n  <li><strong>作用</strong>：将参数替换为占位符，并会进行类型转换和参数的预防 SQL 注入。</li>\n  <li><strong>使用场景</strong>：主要用于传递值，例如在 <code>WHERE</code> 子句中。</li>\n  <li><strong>示例</strong>：\n    <pre><code class=\"language-xml\">&#x3C;select id=\"findUserById\" parameterType=\"int\" resultType=\"User\">\n    SELECT * FROM users WHERE id = #{id}\n&#x3C;/select>\n</code></pre>\n  </li>\n</ul>\n<h3><code>${}</code></h3>\n<ul>\n  <li><strong>用途</strong>：用于动态 SQL，直接将参数值替换到 SQL 语句中。</li>\n  <li><strong>作用</strong>：不会进行 SQL 注入的预防，参数会直接替换，因此使用时需要小心。</li>\n  <li><strong>使用场景</strong>：适用于动态表名、列名等情况。</li>\n  <li><strong>示例</strong>：\n    <pre><code class=\"language-xml\">&#x3C;select id=\"findUserByField\" parameterType=\"String\" resultType=\"User\">\n    SELECT * FROM users WHERE ${fieldName} = #{value}\n&#x3C;/select>\n</code></pre>\n  </li>\n</ul>\n<h3>小结</h3>\n<ul>\n  <li>使用 <code>#{}</code> 能够有效防止 SQL 注入，并且在 SQL 执行前会进行参数处理。</li>\n  <li>使用 <code>${}</code> 则会直接将参数拼接到 SQL 中，适合动态构建 SQL 语句，但要谨慎使用以避免 SQL 注入的风险。</li>\n</ul>\n<p>通常情况下，建议优先使用 <code>#{}</code>，仅在必要时使用 <code>${}</code>。</p>",
    "type": 6,
    "level": 1,
    "freq": 0.007272727,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：MyBatis中#{}和${}的区别是什么？</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对MyBatis中#{}和${}用法的理解。</li>\n      <li>两者在SQL语句生成、安全性、性能等方面的差异。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<ul>\n  <li><strong>MyBatis</strong>：是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。在 MyBatis 的 SQL 映射文件中，经常使用#{}和${}来传递参数。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）SQL 语句生成方式</h4>\n<ul>\n  <li><strong>#{}</strong>：是占位符，MyBatis 会将#{}替换为<code>?</code>，在执行 SQL 语句时通过预编译的方式将参数传递给数据库。例如：</li>\n</ul>\n<pre><code class=\"language-xml\">&#x3C;select id=\"selectUserById\" resultType=\"User\">\n    SELECT * FROM users WHERE id = #{id}\n&#x3C;/select>\n</code></pre>\n<p>MyBatis 实际执行的 SQL 可能是：<code>SELECT * FROM users WHERE id =?</code>，然后将具体的<code>id</code>值作为参数传递。</p>\n<ul>\n  <li>**<span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n        <semantics>\n          <mrow>\n            <mrow></mrow>\n            <mo>∗</mo>\n            <mo>∗</mo>\n            <mtext>：是字符串替换，</mtext>\n            <mi>M</mi>\n            <mi>y</mi>\n            <mi>B</mi>\n            <mi>a</mi>\n            <mi>t</mi>\n            <mi>i</mi>\n            <mi>s</mi>\n            <mtext>会直接将</mtext>\n          </mrow>\n          <annotation encoding=\"application/x-tex\">{}**：是字符串替换，MyBatis 会直接将</annotation>\n        </semantics>\n      </math></span>{}替换为传入的参数值。例如：</li>\n</ul>\n<pre><code class=\"language-xml\">&#x3C;select id=\"selectUserByTableName\" resultType=\"User\">\n    SELECT * FROM ${tableName}\n&#x3C;/select>\n</code></pre>\n<p>如果传入的<code>tableName</code>是<code>users</code>，MyBatis 实际执行的 SQL 就是：<code>SELECT * FROM users</code>。</p>\n<h4>（2）安全性</h4>\n<ul>\n  <li><strong>#{}</strong>：使用预编译语句，能有效防止 SQL 注入攻击。因为参数是通过预编译的方式传递的，数据库会将参数当作普通值处理，不会解析其中的 SQL 语句。</li>\n  <li><strong>${}</strong>：由于是直接进行字符串替换，如果传入的参数包含恶意的 SQL 代码，就会导致 SQL 注入攻击。例如，传入<code>tableName</code>为<code>users; DROP TABLE users; --</code>，就可能会删除<code>users</code>表。</li>\n</ul>\n<h4>（3）性能</h4>\n<ul>\n  <li><strong>#{}</strong>：预编译语句在第一次执行时会进行编译，之后可以重复使用编译好的语句，只需要传入不同的参数值，性能较高。</li>\n  <li><strong>${}</strong>：每次执行时都会生成新的 SQL 语句，需要重新编译，性能相对较低。</li>\n</ul>\n<h4>（4）使用场景</h4>\n<ul>\n  <li><strong>#{}</strong>：适用于大部分需要传递参数的场景，尤其是涉及用户输入的参数，如查询条件、插入值等。</li>\n  <li><strong>${}</strong>：主要用于一些特殊场景，如动态表名、动态列名等，因为预编译语句无法处理表名和列名的占位符。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-xml\">&#x3C;!-- 使用#{} -->\n&#x3C;select id=\"selectUserById\" resultType=\"User\">\n    SELECT * FROM users WHERE id = #{id}\n&#x3C;/select>\n\n&#x3C;!-- 使用${} -->\n&#x3C;select id=\"selectUserByTableName\" resultType=\"User\">\n    SELECT * FROM ${tableName}\n&#x3C;/select>\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）随意使用${}</h4>\n<ul>\n  <li>误区：在任何需要传递参数的地方都使用${}，忽略了其安全性问题。</li>\n  <li>纠正：优先使用#{}，只有在需要动态表名、列名等特殊场景下才使用${}，并且要确保传入的参数是安全的。</li>\n</ul>\n<h4>（2）认为#{}和${}可以随意替换</h4>\n<ul>\n  <li>误区：没有理解两者在 SQL 语句生成方式上的差异，认为可以随意替换使用。</li>\n  <li>纠正：要根据具体的需求选择合适的方式，#{}适用于普通参数传递，${}适用于动态表名、列名等场景。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“在 MyBatis 中，#{}和${}有以下区别：</p>\n<ul>\n  <li><strong>SQL 语句生成方式</strong>：#{}是占位符，MyBatis 会将其替换为<code>?</code>，通过预编译方式传递参数；${}是字符串替换，会直接将其替换为传入的参数值。</li>\n  <li><strong>安全性</strong>：#{}使用预编译语句，能有效防止 SQL 注入攻击；${}由于直接进行字符串替换，存在 SQL 注入风险。</li>\n  <li><strong>性能</strong>：#{}预编译后可重复使用，性能较高；${}每次执行都生成新的 SQL 语句，性能相对较低。</li>\n  <li><strong>使用场景</strong>：#{}适用于大部分需要传递参数的场景；${}主要用于动态表名、动态列名等特殊场景。</li>\n</ul>\n<p>在实际开发中，应优先使用#{}，只有在必要时才使用${}，并确保传入的参数安全。”</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>MyBatis的动态SQL是如何工作的？</strong></p>\n    <ul>\n      <li>提示：可以谈谈使用 <code>&#x3C;if></code>、<code>&#x3C;choose></code> 和 <code>&#x3C;foreach></code> 标签的场景。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你在项目中使用MyBatis时遇到的常见性能问题有哪些？</strong></p>\n    <ul>\n      <li>提示：可以提到N+1查询和如何解决它们。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在MyBatis中如何实现缓存？</strong></p>\n    <ul>\n      <li>提示：区分一级缓存和二级缓存的机制与配置。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你如何配置MyBatis与Spring的整合？</strong></p>\n    <ul>\n      <li>提示：可以涉及到SqlSessionFactoryBean和MapperScan配置。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何处理MyBatis中的参数映射？</strong></p>\n    <ul>\n      <li>提示：可以探讨Map、POJO以及List类型参数的使用。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>MyBatis的事务管理是如何执行的？</strong></p>\n    <ul>\n      <li>提示：讨论使用Spring管理事务的好处和配置方法。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>能否解释一下MyBatis的映射文件与注解的优缺点？</strong></p>\n    <ul>\n      <li>提示：讨论可读性、灵活性和维护性方面的差异。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你有使用MyBatis的代码生成器吗？如果有，谈谈经验。</strong></p>\n    <ul>\n      <li>提示：可以提到使用MyBatis Generator的便利性。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>MyBatis如何处理SQL注入问题？</strong></p>\n    <ul>\n      <li>提示：讨论parameterized statements和使用#{ }的好处。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何优化MyBatis查询性能？</strong></p>\n    <ul>\n      <li>提示：可以提到使用分页、合理的SQL语句和数据库索引。</li>\n    </ul>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  MyBatis参数传递\n    #{}\n      用途: 安全地传递参数\n      作用: 替换为占位符, 进行类型转换和预防SQL注入\n      使用场景: 主要用于传递值, 如WHERE子句\n    ${}\n      用途: 用于动态SQL\n      作用: 直接替换参数值, 不进行SQL注入预防\n      使用场景: 适用于动态表名、列名等\n    小结\n      #{}防止SQL注入, 执行前处理参数\n      ${}直接拼接SQL, 谨慎使用避免风险\n      建议优先使用#{}, 必要时用${}",
    "keynote": "- `#{}` 用于安全传递参数，会自动转义防止 SQL 注入。\n- `${}` 用于构建动态 SQL，直接替换参数，不防 SQL 注入。\n- `#{}` 适合大多数需要传参的情况，尤其是 WHERE 子句。\n- `${}` 适合需要动态指定表名或列名的场合。\n- 通常建议优先使用 `#{}`，仅在必要时采用 `${}`。",
    "group_id": 37,
    "kps": [
      "基本概念",
      "SQL映射与动态SQL"
    ],
    "years": [
      2023
    ],
    "corps": [
      "京东",
      "快手"
    ]
  }
}