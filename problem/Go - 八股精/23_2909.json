{
  "id": 2909,
  "name": "\u003cp\u003e说明一下Golang 中 make 和 new 的区别？\u003c/p\u003e",
  "options": null,
  "answer": "\u003cp\u003e在 Go 语言中，\u003ccode\u003emake\u003c/code\u003e 和 \u003ccode\u003enew\u003c/code\u003e 是两个用于分配内存的内置函数，它们有着不同的用途和返回类型。\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003enew\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e用途\u003c/strong\u003e: \u003ccode\u003enew\u003c/code\u003e 用于为一个类型分配内存，并返回指向这个类型的指针。它不会初始化内存中的内容，只会将其置为该类型的零值。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e语法\u003c/strong\u003e: \u003ccode\u003enew(Type)\u003c/code\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e返回值\u003c/strong\u003e: 返回一个指向分配到的类型零值的指针。例如：\u003c/p\u003e\n    \u003cpre\u003e\u003ccode class=\"language-go\"\u003ep := new(int) // p 是 *int 类型，指向一个 int 类型的零值 (0)\n\u003c/code\u003e\u003c/pre\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003emake\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e用途\u003c/strong\u003e: \u003ccode\u003emake\u003c/code\u003e 只适用于 slices、maps 和 channels。这是因为这些类型在内部包含了某些初始化逻辑，\u003ccode\u003emake\u003c/code\u003e 会返回一个已经初始化好的值，而不是指针。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e语法\u003c/strong\u003e: \u003ccode\u003emake(Type, size, capacity)\u003c/code\u003e，其中 size 和 capacity 是可选的。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e返回值\u003c/strong\u003e: 返回一个被初始化的（非指针）对象。例如：\u003c/p\u003e\n    \u003cpre\u003e\u003ccode class=\"language-go\"\u003es := make([]int, 5) // s 是一个长度为 5 的 int slice\nm := make(map[string]int) // m 是一个初始化好的 map\nch := make(chan int) // ch 是一个初始化好的 channel\n\u003c/code\u003e\u003c/pre\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e总结\u003c/h3\u003e\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e适用类型\u003c/strong\u003e:\u003c/p\u003e\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode\u003enew\u003c/code\u003e 适用于任何类型并返回指向类型的指针。\u003c/li\u003e\n      \u003cli\u003e\u003ccode\u003emake\u003c/code\u003e 只适用于 slices、maps 和 channels，返回这些类型的已初始化实例。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e初始化\u003c/strong\u003e:\u003c/p\u003e\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode\u003enew\u003c/code\u003e 返回的指针指向的是零值，不会初始化。\u003c/li\u003e\n      \u003cli\u003e\u003ccode\u003emake\u003c/code\u003e 返回的是可以直接使用的 type 实例，且已经初始化。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e示例\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// 使用 new\np := new(int) // p 是 *int，指向零值\nfmt.Println(*p) // 输出 0\n\n// 使用 make\ns := make([]int, 5) // s 是长度为 5 的 slice\nfmt.Println(s) // 输出 [0 0 0 0 0]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过这些差异，可以更好地理解在 Go 中如何正确地分配和初始化内存。\u003c/p\u003e",
  "type": 6,
  "level": 2,
  "freq": 0.06821963,
  "analysis": "\u003ch3\u003e\u003cstrong\u003e1. 题目核心\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e问题\u003c/strong\u003e：说明Golang中make和new的区别。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e考察点\u003c/strong\u003e：\n    \u003cul\u003e\n      \u003cli\u003e对make和new函数功能的理解。\u003c/li\u003e\n      \u003cli\u003e两者适用的数据类型。\u003c/li\u003e\n      \u003cli\u003e内存分配和初始化的差异。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003e2. 背景知识\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e（1）内存分配与初始化\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e在Go语言里，变量使用前需要分配内存并可能需要初始化。内存分配涉及到为变量在内存中开辟空间，初始化则是给变量赋予初始值。\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e（2）不同数据类型的特点\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003eGo语言中有多种数据类型，如基本数据类型（int、float等）、引用类型（slice、map、channel）等，不同类型在内存分配和使用上有不同要求。\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e3. 解析\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e（1）功能用途\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003enew\u003c/strong\u003e：主要用于为值类型（如int、struct等）分配内存，它返回一个指向该类型零值的指针。零值是该类型的默认初始值，例如int的零值是0，struct的零值是其所有字段都为零值的结构体。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003emake\u003c/strong\u003e：专门用于创建和初始化引用类型（slice、map、channel），它返回的是类型本身，而不是指针。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cstrong\u003e（2）适用数据类型\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003enew\u003c/strong\u003e：可以用于任何类型，不过在处理引用类型时，它只是分配了内存，并没有对引用类型进行初始化，所以得到的指针指向的对象无法直接使用。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003emake\u003c/strong\u003e：只能用于slice、map、channel这三种引用类型。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cstrong\u003e（3）内存分配和初始化细节\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003enew\u003c/strong\u003e：仅分配内存，将内存初始化为对应类型的零值。例如\u003ccode\u003evar p *int = new(int)\u003c/code\u003e，这里p指向的int值为0。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003emake\u003c/strong\u003e：不仅分配内存，还会进行必要的初始化操作，使其可以立即使用。比如\u003ccode\u003em := make(map[string]int)\u003c/code\u003e，创建了一个可以直接使用的空map。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cstrong\u003e（4）返回值\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003enew\u003c/strong\u003e：返回指向分配内存的指针。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003emake\u003c/strong\u003e：返回初始化后的引用类型实例。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003e4. 示例代码\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 使用new\n    numPtr := new(int)\n    fmt.Println(*numPtr) // 输出: 0\n\n    // 使用make创建slice\n    slice := make([]int, 3, 5)\n    fmt.Println(slice) // 输出: [0 0 0]\n\n    // 使用make创建map\n    m := make(map[string]int)\n    m[\"key\"] = 1\n    fmt.Println(m[\"key\"]) // 输出: 1\n\n    // 使用make创建channel\n    ch := make(chan int)\n    go func() {\n        ch \u0026#x3C;- 1\n    }()\n    fmt.Println(\u0026#x3C;-ch) // 输出: 1\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在上述代码中，\u003ccode\u003enew(int)\u003c/code\u003e返回一个指向int零值的指针；\u003ccode\u003emake([]int, 3, 5)\u003c/code\u003e创建了一个长度为3、容量为5的slice并初始化；\u003ccode\u003emake(map[string]int)\u003c/code\u003e创建并初始化了一个map；\u003ccode\u003emake(chan int)\u003c/code\u003e创建并初始化了一个channel。\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e5. 常见误区\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e（1）用new初始化引用类型后直接使用\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n  \u003cli\u003e误区：使用\u003ccode\u003enew\u003c/code\u003e创建引用类型（如\u003ccode\u003enew(map[string]int)\u003c/code\u003e）后，直接对其进行操作，会导致运行时错误。\u003c/li\u003e\n  \u003cli\u003e纠正：\u003ccode\u003enew\u003c/code\u003e创建的引用类型只是分配了内存，未初始化，需要使用\u003ccode\u003emake\u003c/code\u003e来初始化。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cstrong\u003e（2）混淆make和new的返回值\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n  \u003cli\u003e误区：认为\u003ccode\u003emake\u003c/code\u003e和\u003ccode\u003enew\u003c/code\u003e返回值相同。\u003c/li\u003e\n  \u003cli\u003e纠正：\u003ccode\u003enew\u003c/code\u003e返回指针，\u003ccode\u003emake\u003c/code\u003e返回引用类型实例。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cstrong\u003e（3）用make处理值类型\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n  \u003cli\u003e误区：尝试使用\u003ccode\u003emake\u003c/code\u003e处理值类型（如\u003ccode\u003emake(int)\u003c/code\u003e）。\u003c/li\u003e\n  \u003cli\u003e纠正：\u003ccode\u003emake\u003c/code\u003e只能用于slice、map、channel。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003e6. 总结回答\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e“在Golang中，make和new的区别如下：\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e功能用途\u003c/strong\u003e：new用于为值类型分配内存，返回指向该类型零值的指针；make用于创建和初始化slice、map、channel这三种引用类型，返回类型本身。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e适用数据类型\u003c/strong\u003e：new可用于任何类型，make仅适用于slice、map、channel。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e内存分配和初始化\u003c/strong\u003e：new只分配内存并初始化为零值；make不仅分配内存，还进行必要的初始化，使对象可立即使用。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e返回值\u003c/strong\u003e：new返回指针，make返回引用类型实例。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e需要注意的是，不能用new初始化引用类型后直接使用，要避免混淆两者的返回值，也不能用make处理值类型。”\u003c/p\u003e",
  "more_ask": "\u003cp\u003e面试官可能会进一步问：\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e在 Go 中，切片和数组的区别是什么？\u003c/strong\u003e\u003c/p\u003e\n    \u003cul\u003e\n      \u003cli\u003e提示：关注大小、灵活性和内存管理。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e解释一下 goroutine 的工作原理。\u003c/strong\u003e\u003c/p\u003e\n    \u003cul\u003e\n      \u003cli\u003e提示：考虑调度、栈的管理和并发。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e如何处理 Go 中的错误？\u003c/strong\u003e\u003c/p\u003e\n    \u003cul\u003e\n      \u003cli\u003e提示：讨论错误返回值与 panic/recover 的机制。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e在 Go 中，接口和具体类型之间的关系是什么？\u003c/strong\u003e\u003c/p\u003e\n    \u003cul\u003e\n      \u003cli\u003e提示：思考隐式实现与显式转换。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e在 Go 中使用 channel 的主要优势是什么？\u003c/strong\u003e\u003c/p\u003e\n    \u003cul\u003e\n      \u003cli\u003e提示：涉及数据传递的同步与异步特性。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e你如何理解 Go 的内存管理机制？\u003c/strong\u003e\u003c/p\u003e\n    \u003cul\u003e\n      \u003cli\u003e提示：可以提及垃圾回收与内存分配。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e如何防止 Go 程序中的死锁？\u003c/strong\u003e\u003c/p\u003e\n    \u003cul\u003e\n      \u003cli\u003e提示：考虑锁的使用与设计模式。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eGo 的并发模型和其他语言（如 Java）的比较如何？\u003c/strong\u003e\u003c/p\u003e\n    \u003cul\u003e\n      \u003cli\u003e提示：对比线程、协程与同步机制。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e描述 Go 中的反射及其用途。\u003c/strong\u003e\u003c/p\u003e\n    \u003cul\u003e\n      \u003cli\u003e提示：讨论使用场景及性能考虑。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e如何优化 Go 应用程序的性能？\u003c/strong\u003e\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n  \u003cli\u003e提示：覆盖算法、内存使用和并发设计。\u003c/li\u003e\n\u003c/ul\u003e",
  "mindmap": "mindmap\n  Go内存分配\n    new\n      用途: 分配类型内存并返回指针\n      语法: new(Type)\n      返回值: 指向零值的指针\n    make\n      用途: 初始化slices、maps和channels\n      语法: make(Type, size, capacity)\n      返回值: 已初始化的对象\n    总结\n      适用类型\n        new: 适用于任何类型，返回指针\n        make: 仅用于slices、maps、channels\n      初始化\n        new: 返回指向零值的指针\n        make: 返回已初始化实例",
  "keynote": "- `new` 为任意类型分配内存，返回其零值的指针。\n- `make` 专门用于初始化 slices、maps 和 channels，返回非指针类型的实例。\n- `new` 不进行额外初始化，只设置为零值。\n- `make` 创建的对象是初始化好的，可以直接使用。",
  "group_id": 23,
  "kps": [
    "基本语法",
    "变量和类型"
  ],
  "years": [
    2025,
    2024,
    2023,
    2022
  ],
  "corps": [
    "百度",
    "某上海ai初创",
    "明智慧远",
    "Shopee虾皮",
    "得物",
    "度小满",
    "松鼠AI",
    "CmsTop",
    "小鹅通",
    "华顺信安",
    "快手",
    "字节跳动",
    "万声音乐",
    "腾讯",
    "杭州端点科技",
    "京东",
    "好未来",
    "联想集团",
    "小米",
    "滴滴",
    "杭州默安",
    "大华",
    "美图",
    "闪送科技",
    "腾讯云智",
    "华为",
    "鑫火信息"
  ],
  "emptyReason": ""
}