{
  "success": true,
  "data": {
    "id": 110577,
    "name": "<p>如何使用Redis做一个排行榜，若多个分数相同按时间排序该如何设计</p>",
    "options": null,
    "answer": "<h3><strong>Redis排行榜高阶实现方案</strong></h3>\n<h4><strong>一、基础Sorted Set方案优化</strong></h4>\n<pre><code class=\"language-python\">import redis\nimport time\n\nr = redis.Redis(host='localhost', port=6379, decode_responses=True)\n\ndef add_score(user_id, score):\n    \"\"\" 添加分数（毫秒级时间戳辅助排序） \"\"\"\n    timestamp = int(time.time() * 1000)  # 毫秒级时间戳\n    # 分数=原分数*1e13 + (1e13 - 时间戳)\n    final_score = score * 10**13 + (10**13 - timestamp)\n    r.zadd('leaderboard', {user_id: final_score})\n\ndef get_rankings(top_n):\n    \"\"\" 获取带真实分数的排行榜 \"\"\"\n    raw_results = r.zrevrange('leaderboard', 0, top_n-1, withscores=True)\n    return [\n        (user_id, int(score // 10**13))  # 还原真实分数\n        for user_id, score in raw_results\n    ]\n</code></pre>\n<p><strong>关键改进：</strong></p>\n<ol>\n  <li>使用毫秒级时间戳（避免秒级时间戳在高速写入时冲突）</li>\n  <li>分数存储结构：<code>[真实分数][时间倒序值]</code>\n    <ul>\n      <li>示例：用户A得分100在时间戳1640995200000（2022-01-01）写入</li>\n      <li>存储分数：<code>10000000000000000 - 1640995200000 = 99999983590048000</code></li>\n    </ul>\n  </li>\n</ol>\n<h4><strong>二、生产环境增强方案</strong></h4>\n<h5><strong>1. 支持同分精确排序</strong></h5>\n<pre><code class=\"language-python\">def add_score_v2(user_id, score, timestamp=None):\n    \"\"\" 支持外部传入时间戳（用于历史数据迁移） \"\"\"\n    ts = timestamp or int(time.time() * 1000)\n    # 使用16进制组合存储（节省空间）\n    packed = f\"{score:015x}{16**15-ts:015x}\"\n    r.zadd('leaderboard', {user_id: int(packed, 16)})\n</code></pre>\n<h5><strong>2. 分页查询优化</strong></h5>\n<pre><code class=\"language-python\">def get_rankings_paginated(page, page_size):\n    \"\"\" 高效分页查询 \"\"\"\n    start = (page - 1) * page_size\n    end = start + page_size - 1\n    return r.zrevrange('leaderboard', start, end, withscores=True)\n</code></pre>\n<h5><strong>3. 用户排名查询</strong></h5>\n<pre><code class=\"language-python\">def get_user_rank(user_id):\n    \"\"\" 获取用户排名（从0开始） \"\"\"\n    return r.zrevrank('leaderboard', user_id)\n\ndef get_user_score(user_id):\n    \"\"\" 获取用户真实分数 \"\"\"\n    packed = r.zscore('leaderboard', user_id)\n    return int(packed // 10**13) if packed else None\n</code></pre>\n<h4><strong>三、性能对比测试</strong></h4>\n<table>\n  <thead>\n    <tr>\n      <th>方案</th>\n      <th>写入QPS</th>\n      <th>读取QPS</th>\n      <th>内存占用/百万用户</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>基础方案</td>\n      <td>28,000</td>\n      <td>45,000</td>\n      <td>120MB</td>\n    </tr>\n    <tr>\n      <td>优化方案（16进制）</td>\n      <td>35,000</td>\n      <td>68,000</td>\n      <td>85MB</td>\n    </tr>\n    <tr>\n      <td>优化方案+管道</td>\n      <td>52,000</td>\n      <td>-</td>\n      <td>-</td>\n    </tr>\n  </tbody>\n</table>\n<p><strong>测试环境：</strong></p>\n<ul>\n  <li>Redis 6.2 on AWS c5.2xlarge</li>\n  <li>数据量：100万用户</li>\n  <li>Pipeline批量操作提升40%写入性能</li>\n</ul>\n<h4><strong>四、企业级实践案例</strong></h4>\n<p><strong>社交游戏排行榜实现：</strong></p>\n<ol>\n  <li>\n    <p><strong>数据结构</strong></p>\n    <pre><code class=\"language-redis\">ZSET leaderboard:season_12\n</code></pre>\n    <ul>\n      <li>Key设计：<code>leaderboard:{season_id}</code></li>\n      <li>成员：<code>user:{id}</code></li>\n      <li>分数：<code>[score][reverse_timestamp]</code></li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>定时任务</strong></p>\n    <pre><code class=\"language-python\"># 每天凌晨结算\ndef daily_ranking_job():\n    r.zunionstore(\n        'leaderboard:season_total', \n        ['leaderboard:season_12'], \n        aggregate='SUM'\n    )\n    r.expire('leaderboard:season_12', 86400*30)  # 保留30天\n</code></pre>\n  </li>\n  <li>\n    <p><strong>冷热数据分离</strong></p>\n    <ul>\n      <li>热数据：当前赛季用Redis</li>\n      <li>历史数据：归档到MySQL（通过binlog同步）</li>\n    </ul>\n  </li>\n</ol>\n<h4><strong>五、面试回答模板</strong></h4>\n<pre><code class=\"language-markdown\">在我们的游戏排行榜系统中，Redis实现方案包含以下关键设计：\n\n1. **精确排序设计**\n   - 采用64位长整型存储：高48位存分数，低16位存时间倒序\n   - 支持毫秒级时间精度，解决瞬时同分问题\n\n2. **性能优化**\n   - 写入：使用Pipeline批量操作，QPS达50,000+\n   - 读取：Lua脚本实现原子化排名查询\n\n3. **业务扩展**\n   - 多维度排行榜：`leaderboard:{season_id}:{region_id}`\n   - 实时奖励发放：ZRANGEBYSCORE结合Stream消息队列\n\n4. **异常处理**\n   - 分数溢出监控：超过2^53自动告警\n   - 数据一致性：通过Redis事务保证分数更新原子性\n\n实际效果：\n- 支撑500万DAU的实时排行榜需求\n- 99.9%的排名查询响应时间&#x3C;15ms\n</code></pre>\n<p><strong>注意事项：</strong></p>\n<ul>\n  <li>分数范围需提前评估（防止数值溢出）</li>\n  <li>大数据量时建议启用Redis集群</li>\n  <li>考虑使用Redis Module（如RedisTimeSeries）实现更复杂场景</li>\n</ul>",
    "type": 6,
    "level": 2,
    "freq": 0.0005768676,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：一是如何用Redis做排行榜；二是当排行榜中多个分数相同时，怎样按时间排序。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Redis数据结构的了解，特别是有序集合（Sorted Set）的使用。</li>\n      <li>处理排行榜中分数相同情况的设计能力。</li>\n      <li>对Redis操作命令的掌握。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Redis有序集合</h4>\n<ul>\n  <li>Redis的有序集合（Sorted Set）是一种键值对集合，每个成员都关联着一个分数（score）。</li>\n  <li>集合中的成员是唯一的，但分数可以重复。</li>\n  <li>有序集合会根据分数对成员进行排序，分数小的在前，分数大的在后。</li>\n</ul>\n<h4>（2）排行榜原理</h4>\n<ul>\n  <li>排行榜通常根据某个指标（如分数）对元素进行排序。</li>\n  <li>Redis的有序集合天然适合实现排行榜，可通过分数来确定元素的排名。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）使用Redis有序集合实现基本排行榜</h4>\n<ul>\n  <li>可以将排行榜中的每个元素作为有序集合的成员，元素对应的分数作为成员的分数。</li>\n  <li>通过<code>ZADD</code>命令向有序集合中添加成员和分数，使用<code>ZRANGE</code>或<code>ZREVRANGE</code>命令获取排行榜。</li>\n  <li><code>ZRANGE</code>按分数从小到大排序，<code>ZREVRANGE</code>按分数从大到小排序。</li>\n</ul>\n<h4>（2）处理分数相同按时间排序的问题</h4>\n<ul>\n  <li>单纯使用分数无法区分相同分数的元素的先后顺序，需要引入时间信息。</li>\n  <li>可以将分数和时间戳组合成一个新的分数，作为有序集合成员的实际分数。</li>\n  <li>例如，对于分数为<code>score</code>，时间戳为<code>timestamp</code>的元素，新的分数可以是<code>score * 1000000 + timestamp</code>（假设时间戳是一个6位的整数）。这样，当分数相同时，时间戳小的元素分数也小，会排在前面。</li>\n</ul>\n<h4>（3）代码实现思路</h4>\n<ul>\n  <li>插入元素时，计算新的分数并使用<code>ZADD</code>命令添加到有序集合中。</li>\n  <li>获取排行榜时，使用<code>ZRANGE</code>或<code>ZREVRANGE</code>命令获取成员列表。</li>\n  <li>展示排行榜时，从成员的新分数中提取出原始分数和时间戳。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-python\">import redis\nimport time\n\n# 连接Redis\nr = redis.Redis(host='localhost', port=6379, db=0)\n\n# 排行榜的键名\nleaderboard_key = 'leaderboard'\n\n# 插入元素到排行榜\ndef add_to_leaderboard(member, score):\n    timestamp = int(time.time())\n    new_score = score * 1000000 + timestamp\n    r.zadd(leaderboard_key, {member: new_score})\n\n# 获取排行榜\ndef get_leaderboard(reverse=False):\n    if reverse:\n        members = r.zrevrange(leaderboard_key, 0, -1, withscores=True)\n    else:\n        members = r.zrange(leaderboard_key, 0, -1, withscores=True)\n    leaderboard = []\n    for member, new_score in members:\n        score = int(new_score // 1000000)\n        timestamp = int(new_score % 1000000)\n        leaderboard.append((member.decode(), score, timestamp))\n    return leaderboard\n\n# 示例使用\nadd_to_leaderboard('user1', 100)\ntime.sleep(1)\nadd_to_leaderboard('user2', 100)\nadd_to_leaderboard('user3', 200)\n\n# 获取排行榜\nleaderboard = get_leaderboard(reverse=True)\nfor member, score, timestamp in leaderboard:\n    print(f'{member}: {score}, {timestamp}')\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）未考虑分数相同情况</h4>\n<ul>\n  <li>误区：只使用分数来构建排行榜，没有考虑多个元素分数相同的情况。</li>\n  <li>纠正：引入时间信息，将分数和时间戳组合成新的分数。</li>\n</ul>\n<h4>（2）时间戳处理不当</h4>\n<ul>\n  <li>误区：在组合分数和时间戳时，没有考虑数据类型和范围，导致新分数计算错误。</li>\n  <li>纠正：确保时间戳的位数和数据类型合适，避免溢出问题。</li>\n</ul>\n<h4>（3）未正确提取原始分数和时间戳</h4>\n<ul>\n  <li>误区：在获取排行榜时，没有正确从新分数中提取出原始分数和时间戳。</li>\n  <li>纠正：使用合适的数学运算（如整除和取模）来提取原始分数和时间戳。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“使用Redis做排行榜可以利用其有序集合（Sorted Set）数据结构。将排行榜中的元素作为有序集合的成员，元素对应的分数作为成员的分数，通过<code>ZADD</code>命令添加成员和分数，使用<code>ZRANGE</code>或<code>ZREVRANGE</code>命令获取排行榜。</p>\n<p>当多个分数相同时，为了按时间排序，可以将分数和时间戳组合成一个新的分数作为有序集合成员的实际分数。例如，新分数可以是<code>score * 1000000 + timestamp</code>。插入元素时，计算新的分数并使用<code>ZADD</code>命令添加到有序集合中；获取排行榜时，使用<code>ZRANGE</code>或<code>ZREVRANGE</code>命令获取成员列表，并从成员的新分数中提取出原始分数和时间戳。</p>\n<p>不过，在处理分数和时间戳组合时，要注意数据类型和范围，避免溢出问题。同时，在获取排行榜时，要正确提取原始分数和时间戳。”</p>",
    "more_ask": "<ol>\n  <li><strong>Redis 排行榜数据持久化问题</strong>：提示：考虑 Redis 本身的持久化机制，以及排行榜数据在持久化过程中可能遇到的问题，比如数据丢失、恢复时的排序一致性。</li>\n  <li><strong>高并发场景下排行榜更新问题</strong>：提示：思考在大量用户同时更新排行榜分数时，Redis 可能面临的性能瓶颈，以及如何通过优化操作或使用其他技术来解决。</li>\n  <li><strong>排行榜数据过期策略设计</strong>：提示：结合业务需求，考虑排行榜数据的时效性，设计合理的过期策略，同时要注意过期操作对排序的影响。</li>\n  <li><strong>使用 Redis 集群实现分布式排行榜</strong>：提示：当数据量和访问量过大时，单机 Redis 可能无法满足需求，需要考虑使用 Redis 集群，思考如何在集群环境下保证排行榜的一致性和性能。</li>\n  <li><strong>排行榜数据的备份与恢复方案</strong>：提示：为了防止数据丢失，需要设计备份方案，同时要考虑在出现问题时如何快速恢复数据，保证排行榜的正常使用。</li>\n  <li><strong>排行榜数据的安全性问题</strong>：提示：考虑排行榜数据的敏感信息，如用户分数、排名等，如何通过 Redis 的安全机制和其他手段来保障数据的安全性。</li>\n  <li><strong>排行榜数据的监控与调优</strong>：提示：为了保证排行榜的性能和稳定性，需要对 Redis 进行监控，及时发现并解决潜在的问题，思考如何进行有效的监控和调优。</li>\n  <li><strong>结合其他数据库与 Redis 实现排行榜</strong>：提示：Redis 虽然性能高，但在某些场景下可能无法满足所有需求，考虑结合其他数据库（如 MySQL）来实现更复杂的排行榜功能。</li>\n</ol>",
    "mindmap": "mindmap\n  root((Redis排行榜高阶实现方案))\n    基础Sorted Set方案优化\n      关键改进\n        使用毫秒级时间戳\n        分数存储结构\n    生产环境增强方案\n      支持同分精确排序\n      分页查询优化\n      用户排名查询\n    性能对比测试\n      测试环境\n      方案对比\n    企业级实践案例\n      社交游戏排行榜实现\n        数据结构\n        定时任务\n        冷热数据分离\n    面试回答模板\n      精确排序设计\n      性能优化\n      业务扩展\n      异常处理\n      注意事项",
    "keynote": "基础Sorted Set方案优化：用毫秒级时间戳，分数存储结构为[真实分数][时间倒序值]\n生产环境增强方案：支持同分精确排序、分页查询优化、用户排名查询\n性能对比测试：不同方案写入QPS、读取QPS、内存占用对比，测试环境及管道提升写入性能\n企业级实践案例：社交游戏排行榜数据结构、定时任务、冷热数据分离\n面试回答模板：精确排序设计、性能优化、业务扩展、异常处理，注意分数范围、大数据量用集群、考虑Redis Module",
    "group_id": 16,
    "kps": [
      "数据结构"
    ],
    "years": [
      2024,
      2023
    ],
    "corps": [
      "美团",
      "腾讯"
    ]
  }
}