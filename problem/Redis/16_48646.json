{
  "success": true,
  "data": {
    "id": 48646,
    "name": "<p>在缓存穿透时，若缓存穿透线程访问数据库（数据库中存在该记录）超时并抛出异常，且已将空值写入缓存，导致用户下次访问拿到空值，该如何解决</p>",
    "options": null,
    "answer": "<h4><strong>一、问题本质分析</strong></h4>\n<p>当出现以下情况时会导致该问题：</p>\n<ol>\n  <li>线程A查询缓存未命中</li>\n  <li>线程A查询数据库超时（实际数据存在）</li>\n  <li>线程A将空值（如<code>NULL</code>）写入缓存</li>\n  <li>后续请求直接获取到错误空值</li>\n</ol>\n<h4><strong>二、完整解决方案（生产级）</strong></h4>\n<h5><strong>1. 双重检查锁 + 异常熔断（推荐方案）</strong></h5>\n<pre><code class=\"language-java\">public Object getData(String key) {\n    // 第一次缓存检查\n    Object value = redis.get(key);\n    if (value != null) {\n        return \"NULL\".equals(value) ? null : value; // 处理正常空值\n    }\n    \n    // 获取分布式锁\n    RLock lock = redisson.getLock(key + \":lock\");\n    try {\n        if (lock.tryLock(3, 30, TimeUnit.SECONDS)) {\n            // 第二次缓存检查（防止重复查询）\n            value = redis.get(key);\n            if (value != null) {\n                return \"NULL\".equals(value) ? null : value;\n            }\n            \n            try {\n                // 数据库查询\n                value = database.query(key);\n                if (value == null) {\n                    // 真实空值设置短过期时间\n                    redis.setex(key, 60, \"NULL\");\n                } else {\n                    redis.setex(key, 3600, value);\n                }\n            } catch (TimeoutException e) {\n                // 数据库超时异常特殊处理\n                redis.setex(key, 5, \"DB_ERROR\"); // 设置错误标记\n                throw new ServiceException(\"系统繁忙，请重试\");\n            }\n            return value;\n        }\n    } finally {\n        lock.unlock();\n    }\n    // 锁竞争失败时直接返回旧值或降级值\n    return getFallbackData(key);\n}\n</code></pre>\n<p><strong>关键改进点：</strong></p>\n<ul>\n  <li>使用<code>DB_ERROR</code>标记区分真实空值和异常状态</li>\n  <li>错误标记设置极短TTL（5秒），避免长期影响</li>\n  <li>结合熔断机制（如Hystrix）防止雪崩</li>\n</ul>\n<h5><strong>2. 异步修复机制</strong></h5>\n<pre><code class=\"language-python\">def get_data(key):\n    data = redis.get(key)\n    if data == \"DB_ERROR\":\n        # 触发异步修复\n        celery.send_task(\"repair_cache\", args=[key])\n        return get_fallback_data(key)\n    # 其他逻辑...\n\n@celery.task\ndef repair_cache(key):\n    try:\n        data = db.query(key)\n        if data:\n            redis.setex(key, 3600, data)\n        else:\n            redis.setex(key, 60, \"NULL\")\n    except Exception:\n        redis.setex(key, 10, \"DB_ERROR\")  # 重试间隔\n</code></pre>\n<h5><strong>3. 多级缓存降级</strong></h5>\n<pre><code class=\"language-text\">请求流程：\n1. 检查本地缓存（Caffeine） → 2. 检查Redis → 3. 检查持久层\n当检测到DB_ERROR标记时：\n- 返回本地缓存历史数据\n- 或调用预置的降级接口\n</code></pre>\n<h4><strong>三、架构级解决方案</strong></h4>\n<ol>\n  <li>\n    <p><strong>布隆过滤器前置</strong></p>\n    <pre><code class=\"language-java\">// 初始化时加载所有有效key\nBloomFilter&#x3C;String> filter = BloomFilter.create(\n    Funnels.stringFunnel(), \n    1000000, \n    0.01);\n\npublic Object getData(String key) {\n    if (!filter.mightContain(key)) {\n        return null; // 直接拦截非法请求\n    }\n    // 正常流程...\n}\n</code></pre>\n  </li>\n  <li>\n    <p><strong>缓存版本控制</strong></p>\n    <pre><code class=\"language-redis\"># 存储结构\n{\n  \"data\": real_value,\n  \"version\": 123,\n  \"status\": \"NORMAL\" // NORMAL|NULL|ERROR\n}\n</code></pre>\n    <ul>\n      <li>通过版本号强制失效错误缓存</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>监控告警系统</strong></p>\n    <ul>\n      <li>对<code>DB_ERROR</code>标记进行监控</li>\n      <li>超过阈值时触发告警</li>\n      <li>自动触发缓存重建任务</li>\n    </ul>\n  </li>\n</ol>\n<h4><strong>四、不同场景的选型建议</strong></h4>\n<table>\n  <thead>\n    <tr>\n      <th>场景</th>\n      <th>推荐方案</th>\n      <th>优点</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>高并发秒杀系统</td>\n      <td>布隆过滤器+本地缓存降级</td>\n      <td>最大程度保护数据库</td>\n    </tr>\n    <tr>\n      <td>电商商品详情页</td>\n      <td>异步修复+版本控制</td>\n      <td>保证最终一致性</td>\n    </tr>\n    <tr>\n      <td>金融交易系统</td>\n      <td>双重检查锁+同步告警</td>\n      <td>强一致性要求</td>\n    </tr>\n  </tbody>\n</table>\n<h4><strong>五、面试回答模板</strong></h4>\n<pre><code class=\"language-markdown\">在我们的社交平台项目中，针对缓存穿透异常处理采用以下方案：\n\n1. **分级处理机制**\n   - 一级拦截：布隆过滤器过滤99%非法请求\n   - 二级防护：对数据库超时设置`DB_ERROR`标记（TTL 5秒）\n   - 三级修复：Kafka消息触发异步缓存重建\n\n2. **数据一致性保障**\n   - 通过Redisson分布式锁保证单线程重建\n   - 采用[时间戳+版本号]的缓存键设计\n\n3. **监控体系**\n   - 实时监控异常标记数量\n   - 自动触发补偿任务（平均修复时间&#x3C;30秒）\n\n实际效果：将因超时导致的缓存污染问题减少99.7%，数据库QPS下降40%。\n</code></pre>\n<p><strong>注</strong>：根据实际项目数据补充具体指标（如QPS、错误率变化等）</p>",
    "type": 6,
    "level": 2,
    "freq": 0.001153735,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：缓存穿透时，缓存穿透线程访问数据库（数据库存在记录）超时抛异常，且已将空值写入缓存，用户下次访问拿到空值，如何解决。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对缓存穿透概念的理解。</li>\n      <li>对缓存和数据库交互流程的熟悉程度。</li>\n      <li>解决缓存和数据库数据不一致问题的能力。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）缓存穿透</h4>\n<p>指查询一个一定不存在的数据，由于缓存不命中，接着查询数据库也无法命中，导致每次请求都会访问数据库，给数据库带来很大压力。本题中虽数据库存在记录，但因超时异常导致空值写入缓存，也造成类似缓存穿透的效果。</p>\n<h4>（2）缓存和数据库交互流程</h4>\n<p>一般是先查缓存，缓存命中则返回结果；缓存未命中则查询数据库，将数据库结果存入缓存再返回。</p>\n<h3>3. 解析</h3>\n<h4>（1）问题原因分析</h4>\n<p>缓存穿透线程访问数据库超时抛异常，程序可能将空值写入缓存，后续用户访问该缓存时就会拿到空值，即使数据库中有对应记录。</p>\n<h4>（2）解决思路</h4>\n<ul>\n  <li><strong>设置短时间缓存</strong>：写入空值缓存时，设置较短的过期时间，让空值缓存尽快失效，减少用户拿到空值的时间。</li>\n  <li><strong>异步更新缓存</strong>：当数据库查询超时异常后，启动异步任务重新查询数据库，若查到数据则更新缓存。</li>\n  <li><strong>使用布隆过滤器</strong>：在查询缓存前，先通过布隆过滤器判断数据是否可能存在，减少不必要的数据库查询。</li>\n</ul>\n<h3>4. 具体解决方案</h3>\n<h4>（1）设置短时间缓存</h4>\n<pre><code class=\"language-python\">import redis\nimport time\n\n# 连接Redis\nr = redis.Redis(host='localhost', port=6379, db=0)\n\ndef get_data(key):\n    # 先从缓存获取数据\n    data = r.get(key)\n    if data is not None:\n        return data\n    try:\n        # 模拟数据库查询\n        # 这里应该是实际的数据库查询代码\n        time.sleep(2)  # 模拟查询耗时\n        db_data = \"real data from database\"\n        r.set(key, db_data)\n        return db_data\n    except Exception as e:\n        # 数据库查询超时异常，写入短时间空值缓存\n        r.setex(key, 10, \"\")  # 设置10秒过期时间\n        return None\n</code></pre>\n<h4>（2）异步更新缓存</h4>\n<pre><code class=\"language-python\">import redis\nimport time\nimport threading\n\n# 连接Redis\nr = redis.Redis(host='localhost', port=6379, db=0)\n\ndef update_cache(key):\n    try:\n        # 模拟数据库查询\n        time.sleep(2)  # 模拟查询耗时\n        db_data = \"real data from database\"\n        r.set(key, db_data)\n    except Exception as e:\n        pass\n\ndef get_data(key):\n    # 先从缓存获取数据\n    data = r.get(key)\n    if data is not None:\n        return data\n    try:\n        # 模拟数据库查询\n        time.sleep(2)  # 模拟查询耗时\n        db_data = \"real data from database\"\n        r.set(key, db_data)\n        return db_data\n    except Exception as e:\n        # 数据库查询超时异常，写入空值缓存\n        r.set(key, \"\")\n        # 启动异步任务更新缓存\n        threading.Thread(target=update_cache, args=(key,)).start()\n        return None\n</code></pre>\n<h4>（3）使用布隆过滤器</h4>\n<pre><code class=\"language-python\">from bloom_filter2 import BloomFilter\nimport redis\nimport time\n\n# 连接Redis\nr = redis.Redis(host='localhost', port=6379, db=0)\n# 初始化布隆过滤器\nbloom = BloomFilter(max_elements=10000, error_rate=0.1)\n\n# 假设这里将数据库中存在的键加入布隆过滤器\nbloom.add(\"example_key\")\n\ndef get_data(key):\n    if key not in bloom:\n        return None\n    # 先从缓存获取数据\n    data = r.get(key)\n    if data is not None:\n        return data\n    try:\n        # 模拟数据库查询\n        time.sleep(2)  # 模拟查询耗时\n        db_data = \"real data from database\"\n        r.set(key, db_data)\n        return db_data\n    except Exception as e:\n        # 数据库查询超时异常，写入空值缓存\n        r.set(key, \"\")\n        return None\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）不设置空值缓存过期时间</h4>\n<p>若不设置空值缓存过期时间，用户会长期拿到空值，影响系统正常使用。</p>\n<h4>（2）不进行异步更新</h4>\n<p>仅写入空值缓存，不进行异步更新，缓存中的空值不会自动更新为正确数据。</p>\n<h4>（3）滥用布隆过滤器</h4>\n<p>布隆过滤器有一定误判率，若使用不当，可能会过滤掉本应查询的数据。</p>\n<h3>6. 总结回答</h3>\n<p>可以采用以下几种方法解决该问题：</p>\n<ul>\n  <li><strong>设置短时间缓存</strong>：在数据库查询超时异常写入空值缓存时，设置较短的过期时间，如10秒，让空值缓存尽快失效，减少用户拿到空值的时间。</li>\n  <li><strong>异步更新缓存</strong>：当数据库查询超时异常后，启动异步任务重新查询数据库，若查到数据则更新缓存，保证缓存数据的及时性。</li>\n  <li><strong>使用布隆过滤器</strong>：在查询缓存前，先通过布隆过滤器判断数据是否可能存在，减少不必要的数据库查询，避免因异常导致的空值缓存问题。</li>\n</ul>\n<p>同时，要避免不设置空值缓存过期时间、不进行异步更新和滥用布隆过滤器等常见误区。</p>",
    "more_ask": "<h3>1. 对于空值缓存的有效期设置问题</h3>\n<ul>\n  <li><strong>问题</strong>：在解决缓存穿透时写入空值到缓存，你认为空值缓存的有效期应该如何合理设置？</li>\n  <li><strong>提示</strong>：考虑业务数据的更新频率、数据库查询的成本、用户对数据实时性的要求等因素。</li>\n</ul>\n<h3>2. 并发场景下的空值缓存处理</h3>\n<ul>\n  <li><strong>问题</strong>：在高并发场景下，多个线程同时遇到缓存穿透，都将空值写入缓存，可能会造成什么问题，怎么解决？</li>\n  <li><strong>提示</strong>：思考多个线程同时操作缓存的一致性问题，以及如何避免大量无效的空值缓存写入。</li>\n</ul>\n<h3>3. 结合其他缓存策略解决问题</h3>\n<ul>\n  <li><strong>问题</strong>：除了设置空值缓存，还可以结合哪些Redis缓存策略来更好地解决缓存穿透后空值缓存的问题？</li>\n  <li><strong>提示</strong>：联想Redis的布隆过滤器、热点数据缓存等策略，考虑它们与空值缓存的结合使用。</li>\n</ul>\n<h3>4. 空值缓存对业务系统的影响评估</h3>\n<ul>\n  <li><strong>问题</strong>：空值缓存写入后会对业务系统产生哪些潜在影响，如何评估这些影响？</li>\n  <li><strong>提示</strong>：从业务功能、系统性能、数据准确性等方面去分析空值缓存带来的影响。</li>\n</ul>\n<h3>5. 异常处理和重试机制</h3>\n<ul>\n  <li><strong>问题</strong>：当数据库查询超时抛出异常时，你会设计怎样的异常处理和重试机制来避免空值缓存的问题？</li>\n  <li><strong>提示</strong>：考虑异常的分类处理、重试的次数和间隔时间等因素。</li>\n</ul>",
    "mindmap": "mindmap\n  root((缓存穿透问题解决方案))\n    问题本质分析\n      线程A查询缓存未命中\n      线程A查询数据库超时\n      线程A将空值写入缓存\n      后续请求获取错误空值\n    完整解决方案（生产级）\n      双重检查锁 + 异常熔断\n        关键改进点\n          使用DB_ERROR标记\n          错误标记短TTL\n          结合熔断机制\n      异步修复机制\n      多级缓存降级\n    架构级解决方案\n      布隆过滤器前置\n      缓存版本控制\n      监控告警系统\n    不同场景的选型建议\n      高并发秒杀系统\n      电商商品详情页\n      金融交易系统\n    面试回答模板\n      分级处理机制\n      数据一致性保障\n      监控体系",
    "keynote": "问题本质：线程A查缓存未命中、查数据库超时后写空值到缓存，后续请求获错误空值\n完整解决方案：\n  - 双重检查锁+异常熔断：用DB_ERROR标记，短TTL，结合熔断\n  - 异步修复机制\n  - 多级缓存降级\n架构级解决方案：布隆过滤器前置、缓存版本控制、监控告警系统\n不同场景选型：高并发秒杀用布隆过滤器+本地缓存降级；电商商品详情用异步修复+版本控制；金融交易用双重检查锁+同步告警\n面试回答：分级处理、数据一致性保障、监控体系",
    "group_id": 16,
    "kps": [
      "常见问题与解决方案"
    ],
    "years": [
      2024,
      2023
    ],
    "corps": [
      "携程",
      "网易",
      "饿了么",
      "小米"
    ]
  }
}