{
  "success": true,
  "data": {
    "id": 129686,
    "name": "<p>在主从模式/哨兵模式下，若主节点挂了，key没有同步到主节点，查询不到key就又可以获取锁，如何解决</p>",
    "options": null,
    "answer": "<p>在主从模式和哨兵模式下，当主节点挂了且部分 key 未同步到从节点，会出现查询不到 key 从而又能获取锁的问题，以下是几种解决办法：</p>\n<h3>Redlock 算法</h3>\n<ul>\n  <li><strong>原理</strong>：Redlock 算法是 Redis 官方提出的分布式锁算法，它不依赖于主从复制或哨兵机制。该算法需要多个独立的 Redis 实例（通常建议至少 5 个），客户端在获取锁时，会依次尝试在每个实例上获取锁，只有当在大多数（N/2 + 1）实例上都成功获取到锁，才认为获取锁成功。</li>\n  <li><strong>实现步骤</strong>\n    <ol>\n      <li>获取当前时间（以毫秒为单位）。</li>\n      <li>依次尝试在 N 个实例上获取锁，每个实例的获取锁操作都有一个超时时间，防止客户端长时间阻塞在某个不可用的实例上。</li>\n      <li>如果在大多数实例上都成功获取到锁，并且获取锁的总时间小于锁的有效时间，则认为获取锁成功。</li>\n      <li>如果获取锁失败，客户端需要在所有实例上释放已经获取到的锁。</li>\n    </ol>\n  </li>\n  <li><strong>代码示例（Python 伪代码）</strong></li>\n</ul>\n<pre><code class=\"language-python\">import redis\nimport time\n\n# 初始化多个 Redis 实例\nredis_instances = [\n    redis.Redis(host='redis1', port=6379),\n    redis.Redis(host='redis2', port=6379),\n    # ... 其他实例\n]\n\ndef acquire_redlock(key, value, expiration):\n    start_time = int(time.time() * 1000)\n    acquired_count = 0\n    for instance in redis_instances:\n        if instance.set(key, value, nx=True, ex=expiration):\n            acquired_count += 1\n    end_time = int(time.time() * 1000)\n    elapsed_time = end_time - start_time\n    if acquired_count >= len(redis_instances) // 2 + 1 and elapsed_time &#x3C; expiration:\n        return True\n    else:\n        # 释放已经获取的锁\n        for instance in redis_instances:\n            if instance.get(key) == value:\n                instance.delete(key)\n        return False\n\n</code></pre>\n<h3>延迟释放锁</h3>\n<ul>\n  <li><strong>原理</strong>：当主节点挂掉，从节点被提升为新的主节点后，在一段时间内，即使查询不到 key，也不允许再次获取锁。这段延迟时间要大于主从同步可能需要的最大时间，确保在延迟时间内，数据有足够的时间完成同步。</li>\n  <li><strong>实现步骤</strong>\n    <ol>\n      <li>当主节点挂掉，哨兵检测到并将从节点提升为新的主节点后，记录当前时间。</li>\n      <li>在新的主节点上设置一个全局的延迟标识，标识在一段时间内不允许获取某些关键锁。</li>\n      <li>客户端在尝试获取锁时，先检查这个延迟标识，如果处于延迟时间内，则拒绝获取锁请求。</li>\n    </ol>\n  </li>\n  <li><strong>代码示例（Python 伪代码）</strong></li>\n</ul>\n<pre><code class=\"language-python\">import redis\nimport time\n\nredis_client = redis.Redis(host='localhost', port=6379)\nDELAY_TIME = 10  # 延迟时间，单位：秒\n\ndef acquire_lock(key, value, expiration):\n    # 检查延迟标识\n    delay_end_time = redis_client.get('lock_delay_end_time')\n    if delay_end_time and int(time.time()) &#x3C; int(delay_end_time):\n        return False\n    return redis_client.set(key, value, nx=True, ex=expiration)\n\n# 当主节点挂掉，从节点提升为主节点时，设置延迟标识\ndef set_lock_delay():\n    delay_end_time = int(time.time()) + DELAY_TIME\n    redis_client.set('lock_delay_end_time', delay_end_time)\n\n</code></pre>\n<h3>持久化和快速恢复</h3>\n<ul>\n  <li><strong>原理</strong>：通过配置 Redis 的持久化机制（如 RDB 和 AOF），确保数据能够及时持久化到磁盘。当主节点挂掉后，新的主节点可以快速从磁盘恢复数据，减少数据丢失的可能性。</li>\n  <li><strong>实现步骤</strong>\n    <ol>\n      <li>配置 Redis 的 RDB 持久化，设置合理的快照保存时间间隔和条件。例如，在 redis.conf 中设置 <code>save 900 1</code> 表示在 900 秒内有 1 个 key 发生变化时，进行一次快照保存。</li>\n      <li>开启 AOF 持久化，选择合适的同步策略，如 <code>appendfsync everysec</code> 表示每秒将数据同步到磁盘。</li>\n      <li>当主节点挂掉，从节点被提升为新的主节点后，新的主节点会自动从磁盘加载持久化的数据，尽快恢复到挂掉前的状态。</li>\n    </ol>\n  </li>\n</ul>",
    "type": 6,
    "level": 2,
    "freq": 0.0005768676,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：在Redis主从模式/哨兵模式下，主节点挂了且部分key未同步到从节点，导致查询不到key从而又能获取锁，如何解决该问题。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Redis主从模式和哨兵模式原理的理解。</li>\n      <li>对Redis锁机制的掌握。</li>\n      <li>解决Redis数据同步延迟导致锁问题的能力。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Redis主从模式和哨兵模式</h4>\n<ul>\n  <li><strong>主从模式</strong>：主节点负责写操作，从节点负责读操作，主节点将数据同步到从节点。但同步存在一定延迟。</li>\n  <li><strong>哨兵模式</strong>：在主从模式基础上增加了哨兵节点，用于监控主节点状态，当主节点故障时，自动将从节点提升为主节点。</li>\n</ul>\n<h4>（2）Redis锁机制</h4>\n<ul>\n  <li>通常使用<code>SETNX</code>（SET if Not eXists）命令来实现分布式锁，当key不存在时设置成功，返回1表示获取锁；若key已存在，返回0表示获取锁失败。</li>\n</ul>\n<h4>（3）数据同步延迟问题</h4>\n<ul>\n  <li>在主从模式和哨兵模式中，主节点挂掉时，部分数据可能还未同步到从节点，导致新的主节点（原从节点）中缺少这些数据。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）使用Redlock算法</h4>\n<ul>\n  <li><strong>原理</strong>：Redlock算法是一种分布式锁算法，它需要多个独立的Redis实例（通常是奇数个，如5个）。获取锁时，客户端依次向多个Redis实例发送获取锁的请求，只有当在大多数（超过半数）实例上都成功获取到锁时，才认为获取锁成功。</li>\n  <li><strong>解决思路</strong>：当主节点挂掉时，由于多个实例上都有锁信息，即使部分实例数据同步不及时，也能保证在大多数实例上能正确判断锁的状态，避免因数据同步问题导致重复获取锁。</li>\n  <li><strong>示例代码（Python伪代码）</strong>：</li>\n</ul>\n<pre><code class=\"language-python\">import redis\n\n# 连接多个Redis实例\nredis_instances = [\n    redis.Redis(host='redis1', port=6379),\n    redis.Redis(host='redis2', port=6379),\n    redis.Redis(host='redis3', port=6379),\n    redis.Redis(host='redis4', port=6379),\n    redis.Redis(host='redis5', port=6379)\n]\n\ndef acquire_redlock(key, value, expiration):\n    success_count = 0\n    for instance in redis_instances:\n        if instance.set(key, value, nx=True, ex=expiration):\n            success_count += 1\n    if success_count > len(redis_instances) // 2:\n        return True\n    return False\n\ndef release_redlock(key):\n    for instance in redis_instances:\n        instance.delete(key)\n</code></pre>\n<h4>（2）延迟故障转移</h4>\n<ul>\n  <li><strong>原理</strong>：在哨兵检测到主节点故障后，不立即进行故障转移，而是等待一段时间，让主从节点有足够的时间完成数据同步。</li>\n  <li><strong>解决思路</strong>：通过设置合理的延迟时间，确保大部分数据都能同步到从节点，减少因数据同步不及时导致的问题。</li>\n  <li><strong>配置示例</strong>：在哨兵配置文件中设置<code>down-after-milliseconds</code>和<code>failover-timeout</code>参数，适当增大这些参数的值，延长故障检测和故障转移的时间。</li>\n</ul>\n<h4>（3）使用Redis Cluster</h4>\n<ul>\n  <li><strong>原理</strong>：Redis Cluster是Redis的分布式解决方案，它将数据分散存储在多个节点上，每个节点负责一部分数据的读写操作。</li>\n  <li><strong>解决思路</strong>：由于数据分散在多个节点上，即使某个节点出现故障，其他节点仍然可以正常提供服务，减少了因主从同步问题导致的锁获取异常。</li>\n</ul>\n<h3>4. 常见误区</h3>\n<h4>（1）忽视数据同步延迟</h4>\n<ul>\n  <li>误区：只关注锁的获取和释放，忽略了主从同步延迟可能导致的问题。</li>\n  <li>纠正：在设计分布式锁时，要充分考虑Redis主从模式和哨兵模式下的数据同步延迟，采取相应的措施来解决。</li>\n</ul>\n<h4>（2）过度依赖单一解决方案</h4>\n<ul>\n  <li>误区：只使用一种方法来解决问题，没有考虑到不同方法的优缺点和适用场景。</li>\n  <li>纠正：可以结合多种方法，如同时使用Redlock算法和延迟故障转移，提高系统的可靠性。</li>\n</ul>\n<h4>（3）未考虑性能影响</h4>\n<ul>\n  <li>误区：在解决问题时，没有考虑到所采用的方法对系统性能的影响。</li>\n  <li>纠正：在选择解决方案时，要综合考虑性能和可靠性，避免因过度追求可靠性而导致性能下降。</li>\n</ul>\n<h3>5. 总结回答</h3>\n<p>在Redis主从模式/哨兵模式下，若主节点挂了且key未同步到从节点，导致查询不到key又能获取锁的问题，可以通过以下几种方法解决：</p>\n<ul>\n  <li><strong>使用Redlock算法</strong>：该算法需要多个独立的Redis实例，客户端在获取锁时，需要在大多数实例上都成功获取到锁才认为获取成功。这样即使部分实例数据同步不及时，也能保证锁的正确性。</li>\n  <li><strong>延迟故障转移</strong>：在哨兵检测到主节点故障后，不立即进行故障转移，而是等待一段时间，让主从节点有足够的时间完成数据同步，减少因数据同步不及时导致的问题。</li>\n  <li><strong>使用Redis Cluster</strong>：Redis Cluster将数据分散存储在多个节点上，即使某个节点出现故障，其他节点仍然可以正常提供服务，降低了因主从同步问题导致的锁获取异常的风险。</li>\n</ul>\n<p>同时，在解决问题时要避免忽视数据同步延迟、过度依赖单一解决方案以及未考虑性能影响等误区，综合考虑各种因素，选择合适的解决方案。</p>",
    "more_ask": "<h3>1. 在解决主从模式下 key 未同步导致锁问题时，使用延迟删除策略，如何确定合适的延迟时间？</h3>\n<p>提示：考虑 Redis 主从复制的平均延迟、网络波动情况以及业务对锁的使用频率和时长等因素。</p>\n<h3>2. 若采用 Redlock 算法解决该问题，Redlock 算法在实际应用中有哪些局限性？</h3>\n<p>提示：从网络分区、时钟漂移、节点故障等方面思考对 Redlock 算法正确性和性能的影响。</p>\n<h3>3. 对于解决该问题提出的多节点确认机制，如何优化多节点之间的通信开销？</h3>\n<p>提示：可以从通信协议、批量请求、减少不必要的确认信息等角度去考虑。</p>\n<h3>4. 当使用分布式锁解决该问题时，如何处理锁的可重入性？</h3>\n<p>提示：结合 Redis 的数据结构和锁的实现逻辑，思考如何记录锁的持有次数和持有者信息。</p>\n<h3>5. 若在解决该问题的方案中使用了 Lua 脚本，Lua 脚本在 Redis 中执行有什么优势和风险？</h3>\n<p>提示：优势可从原子性、减少网络开销等方面考虑，风险可关注脚本执行时间过长、脚本错误处理等问题。</p>",
    "mindmap": "mindmap\n  root((主从和哨兵模式主节点挂掉 key 未同步问题解决办法))\n    Redlock 算法\n      原理\n        不依赖主从复制或哨兵机制\n        需要多个独立 Redis 实例\n        多数实例获取锁成功才认为获取成功\n      实现步骤\n        获取当前时间\n        依次在 N 个实例获取锁，有超时时间\n        多数实例成功且总时间小于有效时间则成功\n        失败则在所有实例释放已获取的锁\n    延迟释放锁\n      原理\n        主节点挂掉从节点提升后一段时间内不允许获取锁\n        延迟时间大于主从同步最大时间\n      实现步骤\n        主节点挂掉记录时间\n        新主节点设置全局延迟标识\n        客户端获取锁先检查延迟标识\n    持久化和快速恢复\n      原理\n        配置持久化机制确保数据持久化到磁盘\n        新主节点可快速从磁盘恢复数据\n      实现步骤\n        配置 RDB 持久化，设置快照保存条件\n        开启 AOF 持久化，选择同步策略\n        新主节点自动加载持久化数据恢复状态",
    "keynote": "Redlock 算法：不依赖主从和哨兵，需多个实例，多数实例获取成功才成功；获取时先计时，依次获取，判断多数成功且总时间小于有效时间，失败则释放\n延迟释放锁：主节点挂掉从节点提升后一段时间内禁获取锁，延迟时间大于主从同步最大时间；记录时间，设延迟标识，客户端检查标识\n持久化和快速恢复：配置 RDB 和 AOF 持久化，新主节点从磁盘恢复数据；配 RDB 快照条件，开 AOF 选同步策略，新主节点自动加载数据",
    "group_id": 16,
    "kps": [
      "集群与部署",
      "常见问题与解决方案"
    ],
    "years": [
      2024,
      2023
    ],
    "corps": [
      "百度",
      "OPPO"
    ]
  }
}