{
  "success": true,
  "data": {
    "id": 91692,
    "name": "<p>缓存穿透不用布隆过滤器怎么解决</p>",
    "options": null,
    "answer": "<p>缓存穿透指的是查询一个不存在的数据，导致请求直接穿透缓存访问数据库，若大量此类请求会对数据库造成巨大压力。即便不使用布隆过滤器，也有多种方法可以解决缓存穿透问题：</p>\n<h3>空值缓存</h3>\n<ul>\n  <li><strong>实现方式</strong>：当查询的数据在数据库中不存在时，在缓存中存储一个特殊的空值（如 <code>null</code>、<code>\"\"</code> 或者自定义的标识），并设置一个较短的过期时间。后续相同的查询请求会直接从缓存中获取这个空值，避免再次访问数据库。</li>\n  <li><strong>示例代码（Python + Redis）</strong>：</li>\n</ul>\n<pre><code class=\"language-python\">import redis\n\n# 连接 Redis\nr = redis.Redis(host='localhost', port=6379, db=0)\n\ndef get_data(key):\n    # 先从缓存中获取数据\n    data = r.get(key)\n    if data is not None:\n        # 如果缓存中有数据，判断是否为空值标识\n        if data == b'__NULL__':\n            return None\n        return data.decode('utf-8')\n    # 缓存中没有数据，查询数据库\n    # 这里假设使用一个模拟的数据库查询函数\n    db_data = query_database(key)\n    if db_data is None:\n        # 数据库中也没有数据，设置空值缓存\n        r.setex(key, 60, '__NULL__')\n    else:\n        # 数据库中有数据，将数据存入缓存\n        r.setex(key, 3600, db_data)\n    return db_data\n\ndef query_database(key):\n    # 模拟数据库查询，这里简单返回 None\n    return None\n</code></pre>\n<ul>\n  <li><strong>优缺点</strong>：\n    <ul>\n      <li><strong>优点</strong>：实现简单，能有效拦截重复的无效请求。</li>\n      <li><strong>缺点</strong>：需要额外的内存来存储空值，且对于不断变化的无效请求，可能会占用较多缓存空间。</li>\n    </ul>\n  </li>\n</ul>\n<h3>接口层校验</h3>\n<ul>\n  <li><strong>实现方式</strong>：在应用程序的接口层对请求参数进行合法性校验，过滤掉明显不合法的请求。例如，对于一些需要传入 ID 的接口，检查 ID 是否符合格式要求、是否在合理的范围内等。</li>\n  <li><strong>示例代码（Python + Flask）</strong>：</li>\n</ul>\n<pre><code class=\"language-python\">from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/get_data', methods=['GET'])\ndef get_data():\n    key = request.args.get('key')\n    # 简单的参数校验，假设 key 必须是数字\n    if not key or not key.isdigit():\n        return 'Invalid key', 400\n    # 后续处理逻辑\n    return 'Processed'\n\nif __name__ == '__main__':\n    app.run()\n</code></pre>\n<ul>\n  <li><strong>优缺点</strong>：\n    <ul>\n      <li><strong>优点</strong>：可以在请求进入系统之前就拦截无效请求，减轻缓存和数据库的压力。</li>\n      <li><strong>缺点</strong>：对于复杂的业务逻辑，参数校验规则可能比较复杂，需要仔细设计和维护。</li>\n    </ul>\n  </li>\n</ul>\n<h3>热点数据预加载</h3>\n<ul>\n  <li><strong>实现方式</strong>：对于一些可能会被频繁访问的数据，在系统启动或者定期任务中，将这些数据预先加载到缓存中。这样，即使有部分无效请求，也不会对数据库造成太大影响。</li>\n  <li><strong>示例代码（Python + Redis）</strong>：</li>\n</ul>\n<pre><code class=\"language-python\">import redis\n\n# 连接 Redis\nr = redis.Redis(host='localhost', port=6379, db=0)\n\ndef preload_data():\n    # 模拟从数据库中获取热点数据\n    hot_data = get_hot_data_from_db()\n    for key, value in hot_data.items():\n        r.setex(key, 3600, value)\n\ndef get_hot_data_from_db():\n    # 模拟数据库查询，返回热点数据\n    return {'hot_key1': 'value1', 'hot_key2': 'value2'}\n\nif __name__ == '__main__':\n    preload_data()\n</code></pre>\n<ul>\n  <li><strong>优缺点</strong>：\n    <ul>\n      <li><strong>优点</strong>：可以提高系统的响应速度，减少数据库的访问压力。</li>\n      <li><strong>缺点</strong>：需要提前知道哪些数据是热点数据，并且对于数据变化频繁的场景，需要定期更新缓存。</li>\n    </ul>\n  </li>\n</ul>",
    "type": 6,
    "level": 2,
    "freq": 0.0002884338,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：在不使用布隆过滤器的情况下，如何解决Redis缓存穿透问题。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Redis缓存穿透问题的理解。</li>\n      <li>除布隆过滤器外解决缓存穿透的方法。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）缓存穿透</h4>\n<p>缓存穿透是指查询一个一定不存在的数据，由于缓存中没有，会去查询数据库，而数据库中也没有该数据，这样每次请求都会穿透缓存访问数据库，给数据库带来很大压力。</p>\n<h3>3. 解析</h3>\n<h4>（1）空值缓存</h4>\n<p>\n  当查询的数据在数据库中不存在时，将该查询对应的空结果也缓存到Redis中，同时设置一个较短的过期时间。这样下次同样的查询就可以直接从缓存中获取空结果，避免再次访问数据库。\n  优点是实现简单，能有效拦截相同的无效请求。缺点是对于不同的无效请求，会占用一定的缓存空间，且如果大量不同的无效请求，缓存空间会被大量占用。\n</p>\n<h4>（2）接口层校验</h4>\n<p>\n  在接口层对请求参数进行严格的校验，过滤掉明显不合法的请求。例如，对于ID类型的参数，检查其是否为合法的格式和范围；对于一些必须的参数，检查是否存在。\n  优点是可以在请求进入系统前就拦截掉无效请求，减轻后续系统的压力。缺点是需要对业务逻辑有较深入的了解，才能准确地进行参数校验。\n</p>\n<h4>（3）使用热点数据预缓存</h4>\n<p>\n  对于一些常见的查询条件和可能的查询结果，提前将其缓存到Redis中。这样当有请求到来时，大部分情况下可以直接从缓存中获取结果，减少数据库的访问。\n  优点是可以提高系统的响应速度，减少数据库压力。缺点是需要对业务数据有一定的了解，才能准确地预缓存热点数据，且预缓存的数据可能会占用较多的缓存空间。\n</p>\n<h4>（4）使用限流和熔断机制</h4>\n<p>\n  通过限流机制，限制单位时间内的请求数量，避免过多的无效请求进入系统。当请求量超过一定阈值时，可以触发熔断机制，直接返回错误信息，而不再去查询数据库。\n  优点是可以保护数据库不被大量的无效请求压垮，提高系统的稳定性。缺点是可能会影响正常用户的使用体验，需要合理设置限流和熔断的阈值。\n</p>\n<h3>4. 示例代码（以空值缓存为例）</h3>\n<pre><code class=\"language-python\">import redis\n\n# 连接Redis\nr = redis.Redis(host='localhost', port=6379, db=0)\n\ndef get_data(key):\n    # 先从缓存中获取数据\n    data = r.get(key)\n    if data is not None:\n        if data == b'null':\n            return None\n        return data.decode()\n    # 缓存中没有，查询数据库\n    # 这里假设数据库查询函数为 query_db\n    result = query_db(key)\n    if result is None:\n        # 数据库中也没有，缓存空值\n        r.setex(key, 60, 'null')\n        return None\n    # 缓存查询结果\n    r.setex(key, 3600, result)\n    return result\n\ndef query_db(key):\n    # 模拟数据库查询，这里返回None表示数据不存在\n    return None\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）只依赖单一方法</h4>\n<p>\n  误区：只使用一种方法来解决缓存穿透问题，而忽略了不同方法的优缺点和适用场景。\n  纠正：可以结合多种方法，根据具体的业务场景和系统特点，综合使用不同的解决方案，以达到更好的效果。\n</p>\n<h4>（2）忽略缓存过期时间</h4>\n<p>\n  误区：在使用空值缓存时，没有设置合理的过期时间，导致缓存中的空值长期存在，影响后续正常数据的查询。\n  纠正：根据业务需求和数据的更新频率，设置合理的过期时间，确保缓存中的数据及时更新。\n</p>\n<h4>（3）过度依赖限流和熔断</h4>\n<p>\n  误区：过度依赖限流和熔断机制，而忽略了对无效请求的过滤和缓存的使用。\n  纠正：限流和熔断机制是一种应急措施，应该结合其他方法，如接口层校验和空值缓存，从源头上减少无效请求的产生。\n</p>\n<h3>6. 总结回答</h3>\n<p>“在不使用布隆过滤器的情况下，可以通过以下几种方法解决Redis缓存穿透问题：</p>\n<ol>\n  <li>空值缓存：当查询的数据在数据库中不存在时，将空结果缓存到Redis中，并设置较短的过期时间，避免相同的无效请求再次访问数据库。</li>\n  <li>接口层校验：在接口层对请求参数进行严格的校验，过滤掉明显不合法的请求，减轻后续系统的压力。</li>\n  <li>热点数据预缓存：提前将常见的查询条件和可能的查询结果缓存到Redis中，提高系统的响应速度，减少数据库的访问。</li>\n  <li>限流和熔断机制：通过限制单位时间内的请求数量，当请求量超过阈值时触发熔断机制，保护数据库不被大量的无效请求压垮。</li>\n</ol>\n<p>在实际应用中，可以根据具体的业务场景和系统特点，综合使用多种方法来解决缓存穿透问题。同时，要注意避免常见的误区，如只依赖单一方法、忽略缓存过期时间和过度依赖限流和熔断等。”</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      不用布隆过滤器解决缓存穿透时，若数据库查询压力过大，如何优化查询逻辑？\n      提示：考虑数据库索引、查询语句优化、分库分表等方面。\n    </p>\n  </li>\n  <li>\n    <p>\n      当使用空值缓存解决缓存穿透时，空值缓存的过期时间如何合理设置？\n      提示：结合业务数据的更新频率、数据的重要性等因素思考。\n    </p>\n  </li>\n  <li>\n    <p>\n      不借助布隆过滤器，在高并发场景下，如何保证缓存和数据库数据的一致性？\n      提示：从更新策略、锁机制、消息队列等角度去考虑。\n    </p>\n  </li>\n  <li>\n    <p>\n      若采用接口层校验来解决缓存穿透，对于复杂的业务规则，怎样设计高效的校验逻辑？\n      提示：可以从规则分类、缓存校验结果、异步校验等方面着手。\n    </p>\n  </li>\n  <li>\n    <p>\n      不用布隆过滤器，在分布式系统中解决缓存穿透，会面临哪些新的挑战，如何应对？\n      提示：考虑分布式环境下的网络延迟、数据一致性、节点故障等问题。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((缓存穿透及解决方法))\n    缓存穿透定义\n      查询不存在数据穿透缓存访问数据库\n      大量请求对数据库造成巨大压力\n    解决方法\n      空值缓存\n        实现方式\n          数据库无数据时缓存特殊空值并设短过期时间\n        优缺点\n          优点\n            实现简单\n            拦截重复无效请求\n          缺点\n            额外内存存空值\n            占用较多缓存空间\n      接口层校验\n        实现方式\n          接口层对请求参数合法性校验\n        优缺点\n          优点\n            提前拦截无效请求\n            减轻缓存和数据库压力\n          缺点\n            复杂业务逻辑校验规则复杂\n            需要仔细设计和维护\n      热点数据预加载\n        实现方式\n          系统启动或定期任务预加载热点数据到缓存\n        优缺点\n          优点\n            提高系统响应速度\n            减少数据库访问压力\n          缺点\n            需要提前知道热点数据\n            数据变化频繁需定期更新缓存",
    "keynote": "缓存穿透：查询不存在数据穿透缓存访问数据库，大量请求对数据库压力大\n解决方法：\n- 空值缓存：数据库无数据时缓存特殊空值设短过期时间，实现简单但占内存\n- 接口层校验：接口层校验请求参数合法性，提前拦截但规则复杂\n- 热点数据预加载：系统启动或定期预加载热点数据，提高响应但需提前知热点且定期更新",
    "group_id": 16,
    "kps": [
      "常见问题与解决方案"
    ],
    "years": [
      2023
    ],
    "corps": [
      "美团"
    ]
  }
}