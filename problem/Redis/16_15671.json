{
  "success": true,
  "data": {
    "id": 15671,
    "name": "<p>redis分布式锁过期但业务逻辑还未执行完，如何解决</p>",
    "options": null,
    "answer": "<p>当Redis分布式锁过期但业务逻辑还未执行完时，可以通过以下几种方法解决：</p>\n<h3>方案一：自动续期</h3>\n<ul>\n  <li><strong>原理</strong>：在获取锁之后，启动一个守护线程，定期检查业务逻辑是否执行完毕，如果未执行完毕且锁快要过期，就对锁进行续期，以保证在业务逻辑执行期间锁不会过期。</li>\n  <li><strong>实现方式</strong>：\n    <ul>\n      <li><strong>使用Redisson框架</strong>：Redisson是一个基于Redis实现的Java驻内存数据网格（In-Memory Data Grid），它提供了分布式锁的自动续期功能。以下是一个简单的示例代码：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-java\">import org.redisson.Redisson;\nimport org.redisson.api.RLock;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\n\npublic class RedissonLockExample {\n    public static void main(String[] args) {\n        // 创建Redisson客户端\n        Config config = new Config();\n        config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\n        RedissonClient redisson = Redisson.create(config);\n\n        // 获取锁\n        RLock lock = redisson.getLock(\"myLock\");\n        try {\n            // 尝试获取锁，等待100秒，锁的过期时间为10秒\n            lock.lock(10, java.util.concurrent.TimeUnit.SECONDS);\n            // 模拟业务逻辑执行\n            Thread.sleep(20000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            // 释放锁\n            lock.unlock();\n        }\n        // 关闭Redisson客户端\n        redisson.shutdown();\n    }\n}\n</code></pre>\n<pre><code>- **手动实现**：在获取锁成功后，启动一个定时任务，每隔一段时间检查业务是否完成，如果未完成则延长锁的过期时间。例如在Python中使用Redis-py库：\n</code></pre>\n<pre><code class=\"language-python\">import redis\nimport threading\nimport time\n\n# 连接Redis\nr = redis.Redis(host='localhost', port=6379, db=0)\n\n# 锁的键名\nlock_key = 'my_lock'\n\n# 锁的过期时间\nlock_expire = 10\n\ndef renew_lock():\n    while True:\n        # 检查业务是否完成\n        if r.get('business_finished'):\n            break\n        # 延长锁的过期时间\n        r.expire(lock_key, lock_expire)\n        time.sleep(lock_expire / 3)\n\ndef business_logic():\n    # 获取锁\n    if r.set(lock_key, 'locked', nx=True, ex=lock_expire):\n        try:\n            # 启动守护线程进行续期\n            renew_thread = threading.Thread(target=renew_lock)\n            renew_thread.daemon = True\n            renew_thread.start()\n\n            # 模拟业务逻辑执行\n            time.sleep(20)\n\n            # 标记业务完成\n            r.set('business_finished', 'true')\n        finally:\n            # 释放锁\n            r.delete(lock_key)\n\nif __name__ == '__main__':\n    business_logic()\n</code></pre>\n<h3>方案二：设置合理的过期时间</h3>\n<ul>\n  <li><strong>原理</strong>：在设置锁的过期时间时，根据业务逻辑的平均执行时间，适当增加一定的缓冲时间，以确保在正常情况下业务逻辑能够在锁过期之前执行完毕。</li>\n  <li><strong>实现方式</strong>：在获取锁时，根据业务的历史执行时间统计，预估一个合理的过期时间。例如在Java中使用Jedis库：</li>\n</ul>\n<pre><code class=\"language-java\">import redis.clients.jedis.Jedis;\n\npublic class RedisLockExample {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"localhost\", 6379);\n        String lockKey = \"myLock\";\n        // 根据业务预估的合理过期时间，这里设置为30秒\n        int expireTime = 30;\n        // 获取锁\n        String result = jedis.set(lockKey, \"locked\", \"NX\", \"EX\", expireTime);\n        if (\"OK\".equals(result)) {\n            try {\n                // 模拟业务逻辑执行\n                Thread.sleep(20000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                // 释放锁\n                jedis.del(lockKey);\n            }\n        }\n        jedis.close();\n    }\n}\n</code></pre>\n<h3>方案三：分段锁</h3>\n<ul>\n  <li><strong>原理</strong>：将复杂的业务逻辑拆分成多个小的子任务，每个子任务使用独立的锁进行保护。这样即使某个子任务的锁过期，也不会影响其他子任务的执行，并且可以减少单个锁的持有时间。</li>\n  <li><strong>实现方式</strong>：例如，一个业务逻辑包含数据查询、数据处理和数据存储三个子任务，可以分别为这三个子任务获取锁：</li>\n</ul>\n<pre><code class=\"language-python\">import redis\n\n# 连接Redis\nr = redis.Redis(host='localhost', port=6379, db=0)\n\n# 锁的过期时间\nlock_expire = 10\n\ndef query_data():\n    lock_key = 'query_lock'\n    if r.set(lock_key, 'locked', nx=True, ex=lock_expire):\n        try:\n            # 模拟数据查询\n            print(\"Querying data...\")\n            import time\n            time.sleep(5)\n        finally:\n            r.delete(lock_key)\n\ndef process_data():\n    lock_key = 'process_lock'\n    if r.set(lock_key, 'locked', nx=True, ex=lock_expire):\n        try:\n            # 模拟数据处理\n            print(\"Processing data...\")\n            import time\n            time.sleep(5)\n        finally:\n            r.delete(lock_key)\n\ndef store_data():\n    lock_key = 'store_lock'\n    if r.set(lock_key, 'locked', nx=True, ex=lock_expire):\n        try:\n            # 模拟数据存储\n            print(\"Storing data...\")\n            import time\n            time.sleep(5)\n        finally:\n            r.delete(lock_key)\n\nif __name__ == '__main__':\n    query_data()\n    process_data()\n    store_data()\n</code></pre>",
    "type": 6,
    "level": 2,
    "freq": 0.001730603,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Redis分布式锁过期但业务逻辑还未执行完该如何解决。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Redis分布式锁原理的理解。</li>\n      <li>对锁过期机制的认识。</li>\n      <li>解决锁过期但业务未完成问题的方法。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Redis分布式锁原理</h4>\n<p>Redis分布式锁通常利用Redis的<code>SETNX</code>（SET if Not eXists）命令或<code>SET</code>命令的<code>NX</code>选项来实现。当一个客户端成功设置一个特定的键值对时，就表示获取到了锁，其他客户端无法再设置相同的键，从而实现互斥访问。</p>\n<h4>（2）锁过期机制</h4>\n<p>为了避免死锁，通常会给锁设置一个过期时间。当锁过期后，Redis会自动删除该键，其他客户端就可以再次尝试获取锁。但如果业务逻辑执行时间超过了锁的过期时间，就会出现锁过期但业务未完成的问题。</p>\n<h3>3. 解析</h3>\n<h4>（1）自动续期</h4>\n<ul>\n  <li><strong>原理</strong>：在获取锁成功后，启动一个守护线程（或定时任务），定期检查业务是否执行完，如果未执行完且锁即将过期，就对锁进行续期，延长锁的过期时间。</li>\n  <li><strong>实现方式</strong>：可以使用Redis的<code>EXPIRE</code>命令来延长锁的过期时间。例如，在Java中可以使用Redisson框架，它内部实现了自动续期的机制，被称为“看门狗”。</li>\n</ul>\n<h4>（2）设置合理的过期时间</h4>\n<ul>\n  <li><strong>原理</strong>：在业务开始前，对业务逻辑的执行时间进行预估，根据预估时间设置一个相对合理的锁过期时间。但这种方法有一定的局限性，因为业务执行时间可能会受到多种因素的影响，难以准确预估。</li>\n  <li><strong>实现方式</strong>：在使用<code>SET</code>命令设置锁时，通过<code>EX</code>或<code>PX</code>选项指定过期时间。例如：<code>SET lock_key unique_value EX 60</code>，表示锁的过期时间为60秒。</li>\n</ul>\n<h4>（3）分段锁</h4>\n<ul>\n  <li><strong>原理</strong>：将业务逻辑拆分成多个小段，每个小段分别获取和释放锁。这样可以减少每个锁的持有时间，降低锁过期但业务未完成的风险。</li>\n  <li><strong>实现方式</strong>：在代码中按照业务逻辑的步骤，将其划分为多个部分，每个部分前后分别添加获取锁和释放锁的操作。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<h4>（1）使用Redisson实现自动续期</h4>\n<pre><code class=\"language-java\">import org.redisson.Redisson;\nimport org.redisson.api.RLock;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\n\npublic class RedissonLockExample {\n    public static void main(String[] args) {\n        Config config = new Config();\n        config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\n        RedissonClient redisson = Redisson.create(config);\n\n        RLock lock = redisson.getLock(\"myLock\");\n        try {\n            // 获取锁，自动续期\n            lock.lock();\n            // 模拟业务逻辑\n            Thread.sleep(10000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            // 释放锁\n            lock.unlock();\n        }\n    }\n}\n</code></pre>\n<h4>（2）设置合理的过期时间</h4>\n<pre><code class=\"language-python\">import redis\n\n# 连接Redis\nr = redis.Redis(host='localhost', port=6379, db=0)\n\n# 尝试获取锁\nlock_key = 'my_lock'\nunique_value = 'unique_value'\nlock_acquired = r.set(lock_key, unique_value, ex=60, nx=True)\n\nif lock_acquired:\n    try {\n        # 模拟业务逻辑\n        import time\n        time.sleep(30)\n    } finally {\n        # 释放锁\n        r.delete(lock_key)\n    }\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）不设置过期时间</h4>\n<ul>\n  <li><strong>误区</strong>：为了避免锁过期但业务未完成的问题，不设置锁的过期时间。</li>\n  <li><strong>纠正</strong>：不设置过期时间可能会导致死锁，当持有锁的客户端出现异常崩溃时，其他客户端将无法获取锁。</li>\n</ul>\n<h4>（2）过期时间设置过短</h4>\n<ul>\n  <li><strong>误区</strong>：没有对业务执行时间进行合理预估，将过期时间设置得过短，导致频繁出现锁过期但业务未完成的情况。</li>\n  <li><strong>纠正</strong>：在设置过期时间前，对业务逻辑进行分析和测试，尽量设置一个合理的过期时间。</li>\n</ul>\n<h4>（3）不考虑自动续期的性能开销</h4>\n<ul>\n  <li><strong>误区</strong>：使用自动续期机制时，没有考虑到守护线程或定时任务的性能开销。</li>\n  <li><strong>纠正</strong>：在使用自动续期时，要评估其对系统性能的影响，避免因频繁续期导致性能下降。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“当Redis分布式锁过期但业务逻辑还未执行完时，可以采用以下几种方法解决：</p>\n<ul>\n  <li><strong>自动续期</strong>：在获取锁成功后，启动一个守护线程或定时任务，定期检查业务是否执行完，如果未执行完且锁即将过期，就使用<code>EXPIRE</code>命令对锁进行续期。例如，使用Redisson框架，它内部的“看门狗”机制可以自动完成续期操作。</li>\n  <li><strong>设置合理的过期时间</strong>：在业务开始前，对业务逻辑的执行时间进行预估，根据预估时间使用<code>SET</code>命令的<code>EX</code>或<code>PX</code>选项设置一个相对合理的锁过期时间。但由于业务执行时间可能受多种因素影响，这种方法有一定局限性。</li>\n  <li><strong>分段锁</strong>：将业务逻辑拆分成多个小段，每个小段分别获取和释放锁，减少每个锁的持有时间，降低锁过期但业务未完成的风险。</li>\n</ul>\n<p>需要注意的是，不设置过期时间可能会导致死锁，过期时间设置过短会频繁出现问题，使用自动续期要考虑性能开销。”</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      <strong>Redisson 实现分布式锁时，如何保证锁的可重入性在业务逻辑未执行完场景下的正确性？</strong>\n      提示：思考 Redisson 内部是如何记录锁的重入次数，以及在锁过期续期时如何处理重入状态。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>使用 Lua 脚本解决分布式锁过期问题时，脚本的原子性是如何保证的，对业务性能有什么影响？</strong>\n      提示：了解 Redis 执行 Lua 脚本的机制，从脚本执行过程和业务并发情况分析性能影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在集群环境下，使用 Redis 分布式锁，若主节点故障发生主从切换，业务逻辑未执行完时锁丢失该怎么处理？</strong>\n      提示：考虑 Redis 集群的特性，如 Sentinel 机制、Redis Cluster 的数据同步，思考应对锁丢失的策略。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>对于不同业务场景，如何动态调整分布式锁的过期时间以避免业务逻辑未执行完锁过期的问题？</strong>\n      提示：分析不同业务的执行时间特点，结合系统监控和配置管理来动态设置过期时间。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如果使用 Redis 分布式锁的业务系统存在大量短时间内的锁竞争，且业务逻辑执行时间不稳定，如何优化锁的使用？</strong>\n      提示：从锁的粒度、锁的获取策略、业务逻辑拆分等方面思考优化方法。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Redis分布式锁过期但业务未执行完的解决方法))\n    方案一：自动续期\n      原理\n        启动守护线程定期检查业务，未完成且锁快过期则续期\n      实现方式\n        使用Redisson框架\n        手动实现\n    方案二：设置合理的过期时间\n      原理\n        根据业务平均执行时间增加缓冲时间\n      实现方式\n        根据业务历史执行时间预估过期时间\n    方案三：分段锁\n      原理\n        拆分业务为子任务，各用独立锁保护\n      实现方式\n        为每个子任务获取锁",
    "keynote": "方案一：自动续期\n- 原理：启动守护线程定期检查业务，未完成且锁快过期则续期\n- 实现：Redisson框架或手动实现\n\n方案二：设置合理的过期时间\n- 原理：根据业务平均执行时间增加缓冲时间\n- 实现：根据业务历史执行时间预估过期时间\n\n方案三：分段锁\n- 原理：拆分业务为子任务，各用独立锁保护\n- 实现：为每个子任务获取锁",
    "group_id": 16,
    "kps": [
      "常见问题与解决方案"
    ],
    "years": [
      2024,
      2023,
      2022
    ],
    "corps": [
      "好未来",
      "字节跳动",
      "飞猪",
      "阿里大文娱",
      "网易",
      "招商银行"
    ]
  }
}