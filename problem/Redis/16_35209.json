{
  "success": true,
  "data": {
    "id": 35209,
    "name": "<p>分布式锁的可重入如何实现，其原理是什么</p>",
    "options": null,
    "answer": "<h3>实现方式</h3>\n<h4>基于 Redis 的 Lua 脚本实现</h4>\n<p>在 Redis 中，可通过 Lua 脚本保证操作的原子性来实现可重入锁。以下是一个示例代码（使用 Python 和 Redis-py 库）：</p>\n<pre><code class=\"language-python\">import redis\n\n# 连接 Redis\nr = redis.Redis(host='localhost', port=6379, db=0)\n\ndef acquire_reentrant_lock(key, identifier, acquire_timeout=10, lock_timeout=10):\n    lua_script = \"\"\"\n    if redis.call('exists', KEYS[1]) == 0 then\n        redis.call('hset', KEYS[1], ARGV[1], 1)\n        redis.call('pexpire', KEYS[1], ARGV[2])\n        return 1\n    elseif redis.call('hexists', KEYS[1], ARGV[1]) == 1 then\n        redis.call('hincrby', KEYS[1], ARGV[1], 1)\n        redis.call('pexpire', KEYS[1], ARGV[2])\n        return 1\n    else\n        return 0\n    end\n    \"\"\"\n    result = r.eval(lua_script, 1, key, identifier, lock_timeout * 1000)\n    return result\n\ndef release_reentrant_lock(key, identifier):\n    lua_script = \"\"\"\n    if redis.call('hexists', KEYS[1], ARGV[1]) == 0 then\n        return nil\n    elseif redis.call('hincrby', KEYS[1], ARGV[1], -1) > 0 then\n        return 0\n    else\n        redis.call('del', KEYS[1])\n        return 1\n    end\n    \"\"\"\n    result = r.eval(lua_script, 1, key, identifier)\n    return result\n\n\n</code></pre>\n<p>在上述代码中，<code>acquire_reentrant_lock</code> 函数用于获取可重入锁。如果锁不存在，则创建一个哈希表，将当前线程的标识符作为字段，值设为 1，并设置过期时间；如果锁已存在且是当前线程持有的，则将该字段的值加 1 并更新过期时间；如果锁已被其他线程持有，则返回 0 表示获取失败。<code>release_reentrant_lock</code> 函数用于释放锁，将对应字段的值减 1，如果减 1 后的值仍大于 0，则表示该线程还持有锁；如果减 1 后的值为 0，则删除该哈希表，表示完全释放锁。</p>\n<h4>使用 Redisson 框架</h4>\n<p>Redisson 是一个基于 Redis 的 Java 驻内存数据网格（In-Memory Data Grid），它提供了分布式和可重入锁的实现。以下是一个简单的示例：</p>\n<pre><code class=\"language-java\">import org.redisson.Redisson;\nimport org.redisson.api.RLock;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class RedissonReentrantLockExample {\n    public static void main(String[] args) {\n        // 创建 Redisson 客户端\n        Config config = new Config();\n        config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\n        RedissonClient redisson = Redisson.create(config);\n\n        // 获取可重入锁\n        RLock lock = redisson.getLock(\"myLock\");\n        try {\n            // 尝试获取锁，最多等待 10 秒，锁的持有时间为 30 秒\n            boolean isLocked = lock.tryLock(10, 30, TimeUnit.SECONDS);\n            if (isLocked) {\n                // 模拟业务操作\n                System.out.println(\"获取到锁，执行操作\");\n                // 可重入调用\n                lock.lock();\n                System.out.println(\"再次获取锁，执行操作\");\n                lock.unlock();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            // 释放锁\n            if (lock.isHeldByCurrentThread()) {\n                lock.unlock();\n            }\n            redisson.shutdown();\n        }\n    }\n}\n</code></pre>\n<p>Redisson 内部使用了 Lua 脚本和哈希表来实现可重入锁，它会记录每个线程获取锁的次数，在释放锁时相应地减少次数，直到次数为 0 时才真正释放锁。</p>\n<h3>原理</h3>\n<p>可重入锁的核心原理是记录持有锁的线程和该线程获取锁的次数。在 Redis 中，通常使用哈希表来存储这些信息。</p>\n<ul>\n  <li><strong>获取锁</strong>：当一个线程尝试获取锁时，首先检查锁是否存在。如果锁不存在，则创建一个哈希表，将该线程的标识符作为字段，值设为 1，表示该线程首次获取锁；如果锁已存在且是当前线程持有的，则将该字段的值加 1，表示该线程再次获取锁；如果锁已被其他线程持有，则获取失败。</li>\n  <li><strong>释放锁</strong>：当一个线程释放锁时，将对应字段的值减 1。如果减 1 后的值仍大于 0，则表示该线程还持有锁；如果减 1 后的值为 0，则删除该哈希表，表示该线程完全释放锁。</li>\n</ul>\n<p>通过这种方式，同一个线程可以多次获取和释放锁，实现了锁的可重入性。同时，使用 Lua 脚本保证了操作的原子性，避免了并发问题。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.0002884338,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：分布式锁的可重入如何实现，其原理是什么。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对分布式锁和可重入概念的理解。</li>\n      <li>实现分布式锁可重入的方法。</li>\n      <li>分布式锁可重入实现的原理。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）分布式锁</h4>\n<p>在分布式系统中，多个进程或服务可能会同时访问共享资源，为了保证数据的一致性和正确性，需要使用分布式锁来控制对共享资源的访问。</p>\n<h4>（2）可重入锁</h4>\n<p>可重入锁是指同一个线程或进程在持有锁的情况下，可以再次获取该锁而不会被阻塞。在分布式环境中，可重入锁允许同一个客户端在持有分布式锁的情况下，再次获取该锁。</p>\n<h3>3. 解析</h3>\n<h4>（1）实现方法</h4>\n<p>在Redis中实现分布式锁的可重入，常见的方法是使用Redis的Hash数据结构和Lua脚本。</p>\n<ul>\n  <li><strong>使用Hash存储锁信息</strong>：可以使用一个Hash来存储锁的相关信息，其中键可以是锁的名称，字段可以是客户端的唯一标识，值可以是重入次数。</li>\n  <li><strong>使用Lua脚本保证原子性</strong>：由于Redis执行Lua脚本是原子性的，可以使用Lua脚本来实现加锁、解锁和重入次数的更新操作。</li>\n</ul>\n<h4>（2）原理</h4>\n<ul>\n  <li><strong>加锁过程</strong>：\n    <ul>\n      <li>客户端尝试获取锁时，首先检查Hash中是否存在该锁的键。</li>\n      <li>如果不存在，则创建该键，并将客户端的唯一标识作为字段，重入次数初始化为1。</li>\n      <li>如果存在，检查字段是否为当前客户端的唯一标识。如果是，则将重入次数加1；如果不是，则表示锁已被其他客户端持有，获取锁失败。</li>\n    </ul>\n  </li>\n  <li><strong>解锁过程</strong>：\n    <ul>\n      <li>客户端释放锁时，检查Hash中该锁的键和字段是否存在。</li>\n      <li>如果存在，将重入次数减1。如果重入次数减为0，则删除该键，表示锁已释放；如果重入次数不为0，则表示客户端仍然持有锁。</li>\n    </ul>\n  </li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-lua\">-- 加锁脚本\n-- KEYS[1]: 锁的名称\n-- ARGV[1]: 客户端的唯一标识\n-- ARGV[2]: 重入次数\nlocal lockKey = KEYS[1]\nlocal clientId = ARGV[1]\nlocal reentrantCount = tonumber(ARGV[2])\n\n-- 检查锁是否存在\nif redis.call('hexists', lockKey, clientId) == 1 then\n    -- 锁已被当前客户端持有，增加重入次数\n    redis.call('hincrby', lockKey, clientId, reentrantCount)\n    return 1\nelse\n    -- 锁未被持有，尝试获取锁\n    if redis.call('hsetnx', lockKey, clientId, reentrantCount) == 1 then\n        -- 获取锁成功\n        return 1\n    else\n        -- 获取锁失败\n        return 0\n    end\nend\n\n-- 解锁脚本\n-- KEYS[1]: 锁的名称\n-- ARGV[1]: 客户端的唯一标识\n-- ARGV[2]: 重入次数\nlocal lockKey = KEYS[1]\nlocal clientId = ARGV[1]\nlocal reentrantCount = tonumber(ARGV[2])\n\n-- 检查锁是否被当前客户端持有\nif redis.call('hexists', lockKey, clientId) == 1 then\n    local count = tonumber(redis.call('hget', lockKey, clientId))\n    count = count - reentrantCount\n    if count > 0 then\n        -- 重入次数减1\n        redis.call('hset', lockKey, clientId, count)\n        return 1\n    else\n        -- 重入次数为0，释放锁\n        redis.call('hdel', lockKey, clientId)\n        return 1\n    end\nelse\n    -- 锁未被当前客户端持有，解锁失败\n    return 0\nend\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）未考虑原子性</h4>\n<ul>\n  <li>误区：在实现加锁和解锁操作时，没有使用原子性操作，可能会导致并发问题。</li>\n  <li>纠正：使用Redis的Lua脚本保证加锁、解锁和重入次数更新操作的原子性。</li>\n</ul>\n<h4>（2）未正确处理重入次数</h4>\n<ul>\n  <li>误区：在加锁和解锁时，没有正确处理重入次数，可能会导致锁无法正常释放。</li>\n  <li>纠正：在加锁时增加重入次数，解锁时减少重入次数，当重入次数为0时释放锁。</li>\n</ul>\n<h4>（3）未使用客户端唯一标识</h4>\n<ul>\n  <li>误区：没有使用客户端的唯一标识来区分不同的客户端，可能会导致不同客户端之间的锁混淆。</li>\n  <li>纠正：使用客户端的唯一标识作为Hash的字段，确保每个客户端的锁信息是独立的。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“在Redis中实现分布式锁的可重入，可使用Redis的Hash数据结构和Lua脚本。原理是利用Hash存储锁的相关信息，其中键为锁的名称，字段为客户端的唯一标识，值为重入次数。使用Lua脚本保证加锁、解锁和重入次数更新操作的原子性。</p>\n<p>加锁时，检查Hash中是否存在该锁的键。若不存在则创建并将重入次数初始化为1；若存在且字段为当前客户端唯一标识，则将重入次数加1，否则获取锁失败。解锁时，检查Hash中该锁的键和字段是否存在，若存在则将重入次数减1，减为0时删除该键表示释放锁。</p>\n<p>需要注意的是，实现时要保证操作的原子性，正确处理重入次数，并使用客户端唯一标识区分不同客户端，避免出现并发问题、锁无法正常释放和锁混淆等情况。”</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      Redis 可重入分布式锁在集群环境下会有什么问题，如何解决？\n      提示：考虑 Redis 集群的主从复制特性、节点故障等情况对锁的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      实现 Redis 可重入分布式锁时，如何处理锁的过期时间设置问题？\n      提示：思考过期时间设置过短或过长分别会带来什么后果，以及如何动态调整过期时间。\n    </p>\n  </li>\n  <li>\n    <p>\n      对比使用 Lua 脚本和 Java 代码实现 Redis 可重入分布式锁，各有什么优缺点？\n      提示：从性能、代码复杂度、原子性保障等方面进行对比。\n    </p>\n  </li>\n  <li>\n    <p>\n      若多个服务实例同时竞争 Redis 可重入分布式锁，可能会出现什么异常情况，怎样进行异常处理？\n      提示：考虑网络延迟、Redis 服务故障等因素导致的异常。\n    </p>\n  </li>\n  <li>\n    <p>\n      Redis 可重入分布式锁的实现依赖于 Redis 的哪些数据结构和命令，为什么选择这些？\n      提示：回顾实现过程中用到的数据结构（如 Hash）和命令（如 HSET、HGET 等），分析其优势。\n    </p>\n  </li>\n  <li>\n    <p>\n      在高并发场景下，Redis 可重入分布式锁的性能瓶颈在哪里，如何优化？\n      提示：思考锁的获取和释放操作的性能开销，以及并发竞争对性能的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      如何在 Redis 可重入分布式锁中实现锁的公平性？\n      提示：公平锁意味着按照请求顺序获取锁，可考虑使用 Redis 的列表等数据结构。\n    </p>\n  </li>\n  <li>\n    <p>\n      当 Redis 可重入分布式锁的持有线程崩溃时，如何确保锁能被正确释放？\n      提示：结合锁的过期机制和自动释放策略进行思考。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((可重入锁实现与原理))\n    实现方式\n      基于 Redis 的 Lua 脚本实现\n        acquire_reentrant_lock 函数\n        release_reentrant_lock 函数\n      使用 Redisson 框架\n        Redisson 客户端创建\n        可重入锁获取与释放\n    原理\n      核心原理\n        记录持有线程和获取次数\n      获取锁\n        锁不存在创建哈希表\n        锁已存在且当前线程持有则加 1\n        锁被其他线程持有则失败\n      释放锁\n        对应字段值减 1\n        值大于 0 仍持有锁\n        值为 0 删除哈希表",
    "keynote": "实现方式：\n- 基于 Redis 的 Lua 脚本：用 acquire_reentrant_lock 函数获取锁，release_reentrant_lock 函数释放锁\n- 使用 Redisson 框架：创建 Redisson 客户端，获取和释放可重入锁\n\n原理：\n- 核心：记录持有线程和获取次数\n- 获取锁：锁不存在创建哈希表，当前线程持有则加 1，其他线程持有则失败\n- 释放锁：对应字段值减 1，大于 0 仍持有，为 0 删除哈希表",
    "group_id": 16,
    "kps": [
      "高级特性"
    ],
    "years": [
      2025
    ],
    "corps": [
      "美团"
    ]
  }
}