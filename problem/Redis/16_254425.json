{
  "success": true,
  "data": {
    "id": 254425,
    "name": "<p>什么是缓存击穿，它与正常缓存未命中有什么区别？</p>",
    "options": null,
    "answer": "<h3>缓存击穿的定义</h3>\n<p>缓存击穿指的是在高并发场景下，一个原本存在于缓存中的热门数据（热点 key）突然过期失效，此时大量的请求会在同一时间直接访问数据库，给数据库带来巨大的压力，甚至可能导致数据库崩溃。简单来说，就是因为热点数据过期，使得大量请求绕过缓存直接冲击数据库。</p>\n<h3>与正常缓存未命中的区别</h3>\n<h4>1. 数据情况</h4>\n<ul>\n  <li><strong>缓存击穿</strong>：缓存击穿针对的是原本存在于缓存中的热点数据。这些数据通常是经常被访问的，在缓存中是有过记录的，只是由于过期等原因突然从缓存中消失了。</li>\n  <li><strong>正常缓存未命中</strong>：正常缓存未命中涉及的数据可能是新数据，之前从未被缓存过；也可能是缓存中已经删除的数据。这些数据本身就不在缓存的预期范围内，或者是因为业务逻辑等原因被清理出了缓存。</li>\n</ul>\n<h4>2. 请求特点</h4>\n<ul>\n  <li><strong>缓存击穿</strong>：会在短时间内出现大量针对该热点数据的请求。因为这个热点数据平时被大量用户频繁访问，一旦过期，大量用户的请求会同时到达数据库。</li>\n  <li><strong>正常缓存未命中</strong>：请求相对比较分散，不会像缓存击穿那样集中在某一个特定的数据上。不同用户的请求可能是针对不同的未缓存数据，不会形成对某一个数据的集中冲击。</li>\n</ul>\n<h4>3. 影响程度</h4>\n<ul>\n  <li><strong>缓存击穿</strong>：由于大量请求集中在数据库的同一条记录上，会给数据库带来极大的压力，可能导致数据库的负载过高，甚至出现性能问题，如响应时间变长、数据库崩溃等。</li>\n  <li><strong>正常缓存未命中</strong>：一般情况下，对数据库的影响相对较小。因为请求分散，数据库可以较为正常地处理这些请求，不会出现像缓存击穿那样的集中压力。</li>\n</ul>\n<h4>4. 解决方案</h4>\n<ul>\n  <li><strong>缓存击穿</strong>：通常采用的解决方案有设置热点数据永不过期、使用互斥锁等。设置热点数据永不过期可以避免数据过期导致的击穿问题；使用互斥锁则是在缓存失效时，只允许一个请求去更新缓存，其他请求等待，从而避免大量请求同时访问数据库。</li>\n  <li><strong>正常缓存未命中</strong>：一般是在缓存未命中时，从数据库中获取数据并将其存入缓存，以便后续请求可以直接从缓存中获取，提高访问效率。</li>\n</ul>",
    "type": 6,
    "level": 1,
    "freq": 0.0002884338,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：明确缓存击穿的定义以及它和正常缓存未命中的区别。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对缓存击穿概念的理解。</li>\n      <li>对正常缓存未命中情况的认识。</li>\n      <li>能够清晰对比两者的差异。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）缓存的基本概念</h4>\n<p>缓存是一种数据存储技术，用于减少对原始数据源（如数据库）的访问，提高系统的响应速度和性能。常见的缓存有内存缓存（如Redis）。</p>\n<h4>（2）缓存命中与未命中</h4>\n<ul>\n  <li>缓存命中：当请求的数据可以直接从缓存中获取时，称为缓存命中。</li>\n  <li>缓存未命中：当请求的数据在缓存中不存在，需要从原始数据源（如数据库）获取时，称为缓存未命中。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）缓存击穿的定义</h4>\n<p>缓存击穿是指在高并发场景下，一个非常热门的key（如某个热门商品的信息）在缓存中过期失效的瞬间，大量的请求同时涌入，这些请求都会发现该key在缓存中不存在，于是都去访问数据库，给数据库带来巨大的压力，甚至可能导致数据库崩溃。</p>\n<h4>（2）正常缓存未命中的情况</h4>\n<p>正常缓存未命中是指在一般情况下，由于缓存中本身就没有存储请求的数据，或者数据被正常更新后缓存未同步等原因，导致请求需要去访问原始数据源。这种情况通常是随机的、分散的，不会在同一时间集中大量请求到数据库。</p>\n<h4>（3）两者的区别</h4>\n<ul>\n  <li><strong>发生场景</strong>：\n    <ul>\n      <li>缓存击穿通常发生在高并发场景下，针对的是热门key。</li>\n      <li>正常缓存未命中可以发生在任何场景，没有明显的并发和热门key的特征。</li>\n    </ul>\n  </li>\n  <li><strong>影响范围</strong>：\n    <ul>\n      <li>缓存击穿会导致大量请求瞬间集中到数据库，可能使数据库压力过大甚至崩溃。</li>\n      <li>正常缓存未命中一般不会对数据库造成太大的冲击，因为请求是分散的。</li>\n    </ul>\n  </li>\n  <li><strong>原因</strong>：\n    <ul>\n      <li>缓存击穿主要是因为热门key过期，大量请求同时发现缓存缺失。</li>\n      <li>正常缓存未命中可能是因为数据本身未被缓存、缓存更新不及时等原因。</li>\n    </ul>\n  </li>\n</ul>\n<h3>4. 示例说明</h3>\n<h4>（1）缓存击穿示例</h4>\n<p>假设一个电商网站有一款热门手机的信息存储在Redis缓存中，该缓存的过期时间设置为1小时。在缓存过期的瞬间，正好赶上该手机的抢购活动，大量用户同时发起请求，这些请求都发现该手机信息在缓存中不存在，于是都去访问数据库，可能导致数据库崩溃。</p>\n<h4>（2）正常缓存未命中示例</h4>\n<p>一个普通的博客网站，用户随机访问一篇文章，而这篇文章的信息之前没有被缓存，此时请求就会去数据库中获取文章信息，这就是正常的缓存未命中，不会对数据库造成太大压力。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆两者概念</h4>\n<ul>\n  <li>误区：将缓存击穿和正常缓存未命中简单等同，认为都是缓存中没有数据就去访问数据库。</li>\n  <li>纠正：要明确缓存击穿的高并发和针对热门key的特点，以及它可能带来的严重后果。</li>\n</ul>\n<h4>（2）忽视影响差异</h4>\n<ul>\n  <li>误区：没有认识到缓存击穿和正常缓存未命中对数据库影响的巨大差异。</li>\n  <li>纠正：理解缓存击穿可能导致数据库崩溃，而正常缓存未命中一般不会有如此严重的后果。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“缓存击穿是指在高并发场景下，一个热门key在缓存中过期失效的瞬间，大量请求同时涌入，都去访问数据库，给数据库带来巨大压力甚至导致崩溃的现象。</p>\n<p>正常缓存未命中是指在一般情况下，由于缓存中本身没有存储请求的数据，或者数据被正常更新后缓存未同步等原因，请求需要去访问原始数据源。</p>\n<p>两者的区别主要体现在发生场景、影响范围和原因上。缓存击穿通常发生在高并发场景下针对热门key，会对数据库造成巨大冲击；而正常缓存未命中可以发生在任何场景，请求分散，对数据库影响较小。缓存击穿主要是因为热门key过期，大量请求同时发现缓存缺失；正常缓存未命中则是由于数据未缓存或缓存更新不及时等原因。”</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      如何解决缓存击穿问题？\n      提示：从多个角度思考，如业务逻辑、技术手段等，可考虑使用互斥锁、预加载等方法。\n    </p>\n  </li>\n  <li>\n    <p>\n      缓存击穿在高并发场景下会有什么更严重的后果？\n      提示：结合高并发时系统资源的使用情况，如数据库连接数、CPU 负载等进行分析。\n    </p>\n  </li>\n  <li>\n    <p>\n      互斥锁解决缓存击穿时，如何避免死锁问题？\n      提示：思考锁的获取和释放机制，以及锁的超时设置等方面。\n    </p>\n  </li>\n  <li>\n    <p>\n      缓存击穿和缓存雪崩在解决方案上有哪些相同点和不同点？\n      提示：对比两者的产生原因，从不同的解决方案中找出共性和差异。\n    </p>\n  </li>\n  <li>\n    <p>\n      若使用 Redis 集群，缓存击穿问题会有什么新的特点？\n      提示：考虑 Redis 集群的分布式特性，如节点间的数据同步、故障转移等对缓存击穿的影响。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((缓存击穿相关内容))\n    缓存击穿的定义\n      高并发场景\n      热点key过期\n      大量请求冲击数据库\n    与正常缓存未命中的区别\n      数据情况\n        缓存击穿：热点数据曾在缓存，因过期消失\n        正常缓存未命中：新数据或已删除数据\n      请求特点\n        缓存击穿：短时间大量请求针对热点数据\n        正常缓存未命中：请求分散\n      影响程度\n        缓存击穿：给数据库极大压力，可能崩溃\n        正常缓存未命中：对数据库影响较小\n      解决方案\n        缓存击穿：热点数据永不过期、互斥锁\n        正常缓存未命中：从数据库取数据存入缓存",
    "keynote": "缓存击穿定义：高并发下热点key过期，大量请求冲击数据库\n与正常缓存未命中区别：\n- 数据情况：缓存击穿是热点数据过期消失；正常未命中是新或已删数据\n- 请求特点：缓存击穿短时间大量请求针对热点；正常未命中请求分散\n- 影响程度：缓存击穿给数据库极大压力；正常未命中影响较小\n- 解决方案：缓存击穿用热点永不过期、互斥锁；正常未命中从数据库取数据存缓存",
    "group_id": 16,
    "kps": [
      "常见问题与解决方案"
    ],
    "years": [
      2023
    ],
    "corps": [
      "字节跳动"
    ]
  }
}