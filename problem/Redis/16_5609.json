{
  "success": true,
  "data": {
    "id": 5609,
    "name": "<p>什么是缓存雪崩？该如何解决？</p>",
    "options": null,
    "answer": "<p>缓存雪崩是指在某些情况下，由于大量缓存同时失效，导致大量请求直接访问后端数据库，从而造成数据库瞬间压力过大甚至崩溃的现象。这种情况通常发生在以下几种场景中：</p>\n<ol>\n  <li><strong>定时失效</strong>：如果多个缓存数据设置了相同的失效时间，可能会在同一时刻失效，导致大量请求同时打到数据库。</li>\n  <li><strong>大量缓存缺失</strong>：当缓存系统出现故障或重启时，会导致大量缓存数据失效。</li>\n</ol>\n<h3>缓存雪崩的解决方案</h3>\n<ol>\n  <li>\n    <p><strong>设置不同的过期时间</strong>：对不同的缓存数据设置不相同的过期时间，确保不会在同一时间失效，避免瞬间大量请求数据库。</p>\n  </li>\n  <li>\n    <p><strong>使用随机过期时间</strong>：在设置缓存过期时间时，可以加上一些随机的时间偏移，进一步降低规律性，避免雪崩。</p>\n  </li>\n  <li>\n    <p><strong>采用缓存预热</strong>：在系统启动时，将一些热点数据预先加载到缓存中，减少用户首次请求时对数据库的压力。</p>\n  </li>\n  <li>\n    <p><strong>引入缓存互斥锁</strong>：在缓存失效时，设置一个互斥锁，确保只有一个请求能够去查询数据库，并更新缓存，防止同时有多个请求同时查询数据库。</p>\n  </li>\n  <li>\n    <p><strong>异步加载缓存</strong>：在缓存失效时，可以先返回一个空值或默认值，然后在后台异步加载数据并更新缓存。</p>\n  </li>\n  <li>\n    <p><strong>对数据库进行限流</strong>：可以使用一些限流手段，例如熔断器（Circuit Breaker），在高并发请求到达时，暂时拒绝部分请求，等待数据库恢复。</p>\n  </li>\n</ol>\n<p>通过这些措施，可以有效减少缓存雪崩带来的风险，确保系统的稳定性和响应性。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.0204788,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：什么是缓存雪崩以及如何解决。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对缓存雪崩概念的理解。</li>\n      <li>分析缓存雪崩产生的原因。</li>\n      <li>掌握解决缓存雪崩的方法。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）缓存作用</h4>\n<p>缓存是为了减少对后端数据源（如数据库）的访问压力，提高系统响应速度。Redis 是常用的缓存中间件，将热点数据存储在 Redis 中，当有请求时，优先从 Redis 中获取数据。</p>\n<h4>（2）缓存失效机制</h4>\n<p>Redis 中的缓存数据通常会设置过期时间，当过期时间到达后，缓存数据会被删除。</p>\n<h3>3. 解析</h3>\n<h4>（1）缓存雪崩定义</h4>\n<p>缓存雪崩是指在某一时刻，大量的缓存数据同时过期失效，或者 Redis 服务发生故障无法正常提供服务，导致大量请求直接访问后端数据源（如数据库），造成数据库瞬间压力过大，甚至可能导致数据库崩溃，进而使整个系统不可用。</p>\n<h4>（2）产生原因</h4>\n<ul>\n  <li><strong>大量缓存同时过期</strong>：在设置缓存时，如果给大量的缓存数据设置了相同或相近的过期时间，当这些过期时间到达时，就会出现大量缓存同时失效的情况。</li>\n  <li><strong>Redis 服务故障</strong>：如 Redis 服务器硬件故障、网络故障、Redis 进程崩溃等，导致 Redis 无法正常工作，所有请求都直接打到后端数据库。</li>\n</ul>\n<h4>（3）解决方法</h4>\n<ul>\n  <li><strong>设置随机过期时间</strong>：在设置缓存过期时间时，为每个缓存数据的过期时间添加一个随机值，避免大量缓存同时过期。例如，原本设置缓存过期时间为 60 分钟，可以在 50 - 70 分钟之间随机选择一个值作为过期时间。</li>\n  <li><strong>缓存预热</strong>：在系统启动前，将一些热点数据提前加载到缓存中，并设置不同的过期时间，避免在系统运行初期出现大量缓存同时失效的情况。</li>\n  <li><strong>使用多级缓存</strong>：可以同时使用本地缓存（如 Guava Cache）和分布式缓存（如 Redis）。当 Redis 中的缓存失效时，先从本地缓存中获取数据，减少对后端数据库的访问压力。</li>\n  <li><strong>限流降级</strong>：当检测到大量请求直接访问数据库时，可以通过限流算法（如令牌桶算法、漏桶算法）限制请求的流量，对一些非核心业务进行降级处理，保证核心业务的正常运行。</li>\n  <li><strong>Redis 高可用</strong>：采用 Redis 集群、主从复制、哨兵模式等技术，提高 Redis 的可用性。当主节点出现故障时，能够自动切换到从节点，保证 Redis 服务的正常运行。</li>\n  <li><strong>数据持久化</strong>：开启 Redis 的数据持久化功能（如 RDB、AOF），当 Redis 服务器重启后，可以快速恢复缓存数据，减少对后端数据库的压力。</li>\n</ul>\n<h3>4. 示例代码（Java 实现随机过期时间）</h3>\n<pre><code class=\"language-java\">import redis.clients.jedis.Jedis;\nimport java.util.Random;\n\npublic class RedisCache {\n    private static final int BASE_EXPIRE_TIME = 60; // 基础过期时间 60 秒\n    private static final int RANDOM_RANGE = 20; // 随机范围 20 秒\n    private static final Random random = new Random();\n\n    public static void setWithRandomExpire(Jedis jedis, String key, String value) {\n        int expireTime = BASE_EXPIRE_TIME + random.nextInt(RANDOM_RANGE);\n        jedis.setex(key, expireTime, value);\n    }\n\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"localhost\", 6379);\n        setWithRandomExpire(jedis, \"testKey\", \"testValue\");\n        jedis.close();\n    }\n}\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）忽视过期时间设置</h4>\n<ul>\n  <li>误区：给大量缓存设置相同的过期时间，没有考虑到可能会引发缓存雪崩。</li>\n  <li>纠正：采用随机过期时间或不同的过期策略，分散缓存失效的时间点。</li>\n</ul>\n<h4>（2）只依赖单一缓存</h4>\n<ul>\n  <li>误区：只使用 Redis 作为缓存，没有考虑 Redis 服务故障的情况。</li>\n  <li>纠正：使用多级缓存，提高系统的容错能力。</li>\n</ul>\n<h4>（3）未考虑限流降级</h4>\n<ul>\n  <li>误区：没有对突发的大量请求进行限流和降级处理，导致数据库压力过大。</li>\n  <li>纠正：在系统中引入限流和降级机制，保障系统的稳定性。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“缓存雪崩是指在某一时刻，大量缓存数据同时过期失效，或者 Redis 服务发生故障，使得大量请求直接访问后端数据源，造成数据库压力过大甚至崩溃，进而导致整个系统不可用。</p>\n<p>解决缓存雪崩可以采取以下措施：一是设置随机过期时间，避免大量缓存同时失效；二是进行缓存预热，提前将热点数据加载到缓存中；三是使用多级缓存，如本地缓存和分布式缓存结合；四是采用限流降级策略，限制请求流量，对非核心业务降级；五是保证 Redis 高可用，通过集群、主从复制等技术；六是开启 Redis 数据持久化，便于重启后快速恢复缓存数据。”</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>可以详细解释一下缓存雪崩的定义和场景吗？</strong><br>提示：考虑具体的业务场景和缓存失效的原因。</p>\n  </li>\n  <li>\n    <p><strong>除了缓存雪崩，还有哪些缓存相关的问题？</strong><br>提示：想想缓存击穿和缓存穿透这两个概念。</p>\n  </li>\n  <li>\n    <p><strong>针对缓存雪崩，具体的防御策略有哪些？</strong><br>提示：想想使用不同的过期策略、减缓失效的技术等。</p>\n  </li>\n  <li>\n    <p><strong>在高并发场景中，如何设计缓存在它失效时的应对策略？</strong><br>提示：考虑使用互斥锁或其他同步机制。</p>\n  </li>\n  <li>\n    <p><strong>如何监控和分析缓存的状态以预防雪崩现象？</strong><br>提示：想想使用哪些监控工具或指标。</p>\n  </li>\n  <li>\n    <p><strong>如果缓存容量不足，如何判断哪些数据应该被删除？</strong><br>提示：考虑使用LRU、LFU等缓存淘汰算法。</p>\n  </li>\n  <li>\n    <p><strong>请解释一下如何合理设定缓存的过期时间。</strong><br>提示：考虑业务数据的变化频率和访问模式。</p>\n  </li>\n  <li>\n    <p><strong>在分布式系统中，如何确保多个缓存节点的一致性？</strong><br>提示：想想数据同步、分布式锁等机制。</p>\n  </li>\n  <li>\n    <p><strong>在实际使用Redis时，如何选择合适的持久化策略？</strong><br>提示：考虑RDB快照和AOF（Append Only File）的优缺点。</p>\n  </li>\n  <li>\n    <p><strong>如何评估缓存的命中率，优化策略有哪些？</strong><br>提示：考虑使用统计工具和性能调优方法。</p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  缓存雪崩\n    定时失效\n      设置相同的失效时间导致同时失效\n    大量缓存缺失\n      缓存系统故障或重启导致大量缓存失效",
    "keynote": "关键要点：\n1. 缓存雪崩是由于大量缓存同时失效，导致数据库压力过大。\n2. 定时失效：多个缓存数据设置相同失效时间，导致同时失效。\n3. 大量缓存缺失：缓存系统故障或重启导致缓存失效。\n4. 解决方案：设置不同过期时间、使用随机过期时间、采用缓存预热、引入缓存互斥锁、异步加载缓存、对数据库进行限流。\n```",
    "group_id": 16,
    "kps": [
      "常见问题与解决方案"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "快手",
      "赛力斯",
      "字节飞书",
      "字节跳动",
      "海兴电力",
      "滴滴",
      "合思",
      "去哪儿旅行",
      "新国都",
      "南昌某公司",
      "慧策",
      "卓望",
      "唯品会",
      "雄安元拓",
      "阿里巴巴",
      "满帮集团",
      "美团",
      "网易",
      "万声音乐",
      "淘天集团",
      "杭州阿信网络科技",
      "京东",
      "OPPO",
      "科大讯飞",
      "好未来",
      "深信服",
      "拼多多",
      "携程",
      "贝壳",
      "B站",
      "用友",
      "爱奇艺",
      "浩鲸科技",
      "同程旅行",
      "货拉拉",
      "建信金融科技",
      "Shopee虾皮",
      "图森未来",
      "腾讯",
      "美团金服",
      "百度",
      "联想集团"
    ]
  }
}