{
  "success": true,
  "data": {
    "id": 55046,
    "name": "<p>Redis 底层跳表的原理是什么，跳表插入一个新节点时会修改哪些内容？</p>",
    "options": null,
    "answer": "<h3>Redis 底层跳表的原理</h3>\n<p>跳表（Skip List）是一种可以实现快速查找的数据结构，它在有序链表的基础上增加了多级索引，以提高查找效率。Redis 中的有序集合（Sorted Set）在元素数量较多或者元素成员长度较长时会使用跳表作为底层实现之一。</p>\n<h4>基本结构</h4>\n<ul>\n  <li><strong>链表节点</strong>：跳表本质上是一个有序链表，每个节点包含一个键值对，节点按照键的大小有序排列。</li>\n  <li><strong>多级索引</strong>：在原始链表的基础上，通过随机的方式为部分节点建立多级索引。每一级索引都是一个有序链表，且索引节点指向原始链表中的对应节点。最顶层的索引节点最少，越往下层索引节点越多，最底层的索引就是原始链表。</li>\n</ul>\n<h4>查找过程</h4>\n<ul>\n  <li>从最顶层的索引开始，从左到右遍历，直到找到一个节点，其下一个节点的键大于要查找的键。</li>\n  <li>然后下降到下一层索引，继续从当前节点开始向右遍历，重复上述过程，直到下降到原始链表。</li>\n  <li>在原始链表中继续向右查找，直到找到目标节点或者确定目标节点不存在。</li>\n</ul>\n<h4>时间复杂度</h4>\n<ul>\n  <li>平均情况下，跳表的查找、插入和删除操作的时间复杂度都是 <span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n        <semantics>\n          <mrow>\n            <mi>O</mi>\n            <mo stretchy=\"false\">(</mo>\n            <mi>l</mi>\n            <mi>o</mi>\n            <mi>g</mi>\n            <mi>n</mi>\n            <mo stretchy=\"false\">)</mo>\n          </mrow>\n          <annotation encoding=\"application/x-tex\">O(log n)</annotation>\n        </semantics>\n      </math></span>，这是因为多级索引的存在使得查找过程可以快速跳过大量节点。</li>\n  <li>空间复杂度为 <span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n        <semantics>\n          <mrow>\n            <mi>O</mi>\n            <mo stretchy=\"false\">(</mo>\n            <mi>n</mi>\n            <mo stretchy=\"false\">)</mo>\n          </mrow>\n          <annotation encoding=\"application/x-tex\">O(n)</annotation>\n        </semantics>\n      </math></span>，主要用于存储多级索引。</li>\n</ul>\n<h3>跳表插入一个新节点时会修改的内容</h3>\n<h4>确定新节点的层数</h4>\n<ul>\n  <li>在插入新节点时，首先需要随机确定该节点的层数。Redis 中使用随机算法来决定新节点的层数，这个随机算法保证了新节点的层数是一个符合一定概率分布的值。一般来说，新节点的层数为 1 的概率最大，层数越高，概率越小。</li>\n</ul>\n<h4>查找插入位置</h4>\n<ul>\n  <li>从最顶层的索引开始，按照查找过程找到新节点在每一层索引中的插入位置。</li>\n</ul>\n<h4>修改索引指针</h4>\n<ul>\n  <li>在每一层索引中，将新节点插入到相应的位置，并修改前后节点的指针。具体来说，需要修改新节点的前一个节点的后继指针，使其指向新节点，同时修改新节点的后继指针，使其指向前一个节点原来的后继节点。</li>\n</ul>\n<h4>更新最高层数</h4>\n<ul>\n  <li>如果新节点的层数大于当前跳表的最高层数，则需要增加新的索引层，并在新的索引层中插入新节点。</li>\n</ul>\n<p>以下是一个简单的示例，展示了插入新节点时指针的修改过程：</p>\n<p>假设原始跳表如下：</p>\n<pre><code>Level 3:  1 --------------------> 5\nLevel 2:  1 ---------> 3 ---------> 5\nLevel 1:  1 -> 2 -> 3 -> 4 -> 5\n</code></pre>\n<p>现在要插入节点 6，假设新节点的层数为 2。</p>\n<p>插入过程如下：</p>\n<ol>\n  <li>在 Level 2 中，找到插入位置，将 5 的后继指针指向 6，6 的后继指针指向 NULL。</li>\n  <li>在 Level 1 中，找到插入位置，将 5 的后继指针指向 6，6 的后继指针指向 NULL。</li>\n</ol>\n<p>插入后的跳表如下：</p>\n<pre><code>Level 3:  1 --------------------> 5\nLevel 2:  1 ---------> 3 ---------> 5 ---------> 6\nLevel 1:  1 -> 2 -> 3 -> 4 -> 5 -> 6\n</code></pre>\n<p>通过这种方式，新节点被插入到跳表中，同时保证了跳表的有序性和多级索引的正确性。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.002019037,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：一是Redis底层跳表的原理，二是跳表插入新节点时会修改的内容。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Redis跳表数据结构的理解。</li>\n      <li>跳表的工作原理。</li>\n      <li>跳表插入操作的具体流程。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）跳表的定义</h4>\n<p>跳表（Skip List）是一种有序的数据结构，它通过在每个节点中维护多个指向其他节点的指针，从而达到快速查找的目的。它是一种随机化的数据结构，其效率可以和平衡树相媲美。</p>\n<h4>（2）跳表的应用场景</h4>\n<p>Redis中使用跳表作为有序集合（Sorted Set）的底层实现之一，用于支持高效的范围查找和排序操作。</p>\n<h3>3. 解析</h3>\n<h4>（1）Redis底层跳表的原理</h4>\n<ul>\n  <li><strong>多层链表结构</strong>：跳表由多层链表组成，最底层是一个普通的有序链表，存储了所有的元素。每一层链表都是下一层链表的子集，且元素是有序排列的。</li>\n  <li><strong>随机层数</strong>：每个节点的层数是随机确定的，通过一个随机算法决定该节点在多少层链表中出现。一般来说，节点出现在高层链表的概率较低。</li>\n  <li><strong>查找过程</strong>：从最高层链表的头节点开始，沿着链表向右查找，当遇到比目标值大的节点时，向下一层链表继续查找，直到找到目标节点或到达链表末尾。这种查找方式可以跳过大量的节点，从而提高查找效率。</li>\n</ul>\n<h4>（2）跳表插入新节点时会修改的内容</h4>\n<ul>\n  <li><strong>确定新节点的层数</strong>：通过随机算法确定新节点的层数。</li>\n  <li><strong>查找插入位置</strong>：从最高层链表开始，找到新节点应该插入的位置。</li>\n  <li><strong>插入新节点</strong>：在每一层链表中，将新节点插入到合适的位置，并更新前后节点的指针。</li>\n  <li><strong>更新高层链表</strong>：如果新节点的层数高于当前跳表的最大层数，需要创建新的高层链表，并更新头节点的指针。</li>\n</ul>\n<h3>4. 示例代码（伪代码）</h3>\n<pre><code class=\"language-python\"># 跳表节点类\nclass SkipListNode:\n    def __init__(self, value, level):\n        self.value = value\n        self.forward = [None] * (level + 1)\n\n# 跳表类\nclass SkipList:\n    def __init__(self, max_level):\n        self.max_level = max_level\n        self.level = 0\n        self.header = SkipListNode(-1, max_level)\n\n    def random_level(self):\n        # 随机确定节点的层数\n        level = 0\n        import random\n        while random.random() &#x3C; 0.5 and level &#x3C; self.max_level:\n            level += 1\n        return level\n\n    def insert(self, value):\n        update = [None] * (self.max_level + 1)\n        current = self.header\n\n        # 查找插入位置\n        for i in range(self.level, -1, -1):\n            while current.forward[i] and current.forward[i].value &#x3C; value:\n                current = current.forward[i]\n            update[i] = current\n\n        current = current.forward[0]\n\n        if current is None or current.value != value:\n            # 确定新节点的层数\n            new_level = self.random_level()\n\n            if new_level > self.level:\n                for i in range(self.level + 1, new_level + 1):\n                    update[i] = self.header\n                self.level = new_level\n\n            # 创建新节点\n            new_node = SkipListNode(value, new_level)\n\n            # 插入新节点\n            for i in range(new_level + 1):\n                new_node.forward[i] = update[i].forward[i]\n                update[i].forward[i] = new_node\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）认为跳表是平衡树</h4>\n<ul>\n  <li>误区：将跳表和平衡树混淆，认为它们的实现原理相同。</li>\n  <li>纠正：跳表是一种随机化的数据结构，通过随机层数来提高查找效率；而平衡树是通过复杂的旋转操作来保持树的平衡。</li>\n</ul>\n<h4>（2）忽略随机层数的作用</h4>\n<ul>\n  <li>误区：不理解随机层数在跳表中的作用。</li>\n  <li>纠正：随机层数可以使跳表在平均情况下达到较好的性能，避免了最坏情况下的性能退化。</li>\n</ul>\n<h4>（3）不清楚插入操作的细节</h4>\n<ul>\n  <li>误区：只知道插入新节点，但不清楚具体需要修改哪些内容。</li>\n  <li>纠正：插入新节点时需要确定新节点的层数、查找插入位置、更新前后节点的指针以及可能需要更新高层链表。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“Redis底层跳表是一种有序的数据结构，它由多层链表组成，最底层是普通的有序链表，每一层链表都是下一层链表的子集。每个节点的层数是随机确定的，通过随机算法决定该节点在多少层链表中出现。查找时从最高层链表的头节点开始，沿着链表向右查找，遇到比目标值大的节点时向下一层链表继续查找，直到找到目标节点或到达链表末尾。</p>\n<p>当跳表插入一个新节点时，首先通过随机算法确定新节点的层数，然后从最高层链表开始查找插入位置。找到插入位置后，在每一层链表中将新节点插入到合适的位置，并更新前后节点的指针。如果新节点的层数高于当前跳表的最大层数，还需要创建新的高层链表，并更新头节点的指针。</p>\n<p>需要注意的是，跳表和平衡树不同，它是一种随机化的数据结构，通过随机层数来提高查找效率。同时，随机层数在跳表中起着重要作用，它可以使跳表在平均情况下达到较好的性能。”</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      跳表删除节点时的具体步骤是怎样的，会修改哪些内容？\n      提示：思考删除节点时如何定位节点，以及删除后对各层链表的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      跳表的随机层数是如何生成的，为什么要采用这种方式？\n      提示：关注随机层数的算法实现，以及随机层数对跳表性能的作用。\n    </p>\n  </li>\n  <li>\n    <p>\n      跳表在并发场景下可能会出现什么问题，如何解决？\n      提示：考虑多线程同时操作跳表时，插入、删除等操作可能引发的冲突。\n    </p>\n  </li>\n  <li>\n    <p>\n      与其他数据结构（如红黑树）相比，跳表在插入操作上有什么优势和劣势？\n      提示：从时间复杂度、实现复杂度、内存占用等方面对比。\n    </p>\n  </li>\n  <li>\n    <p>\n      当跳表的节点数量非常大时，插入操作的性能会受到怎样的影响，如何优化？\n      提示：分析大量节点下跳表的结构特点，思考优化插入性能的方法。\n    </p>\n  </li>\n  <li>\n    <p>\n      跳表插入节点时，如何保证各层链表的有序性？\n      提示：关注插入过程中节点的比较和插入位置的确定。\n    </p>\n  </li>\n  <li>\n    <p>\n      跳表的空间复杂度是多少，插入新节点对空间复杂度有什么影响？\n      提示：计算跳表的空间占用，分析插入新节点后空间的变化。\n    </p>\n  </li>\n  <li>\n    <p>\n      如何在跳表中实现范围查询，插入新节点会对范围查询有什么影响？\n      提示：思考范围查询的实现思路，以及新节点插入后对范围查询结果的影响。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Redis底层跳表的原理))\n    基本概念\n      跳表定义\n      Redis有序集合使用场景\n    基本结构\n      链表节点\n      多级索引\n    查找过程\n      顶层索引遍历\n      下降索引层\n      原始链表查找\n    时间复杂度\n      平均查找、插入、删除复杂度\n      空间复杂度\n    插入新节点\n      确定新节点层数\n      查找插入位置\n      修改索引指针\n      更新最高层数",
    "keynote": "Redis跳表原理\n- 基本概念：跳表是有序链表加多级索引，Redis有序集合元素多或成员长时用跳表\n- 基本结构：链表节点含键值对且按键排序，多级索引随机建立，顶层节点少，底层是原始链表\n- 查找过程：从顶层索引左到右遍历，遇大键下降一层，最后在原始链表查找\n- 时间复杂度：平均查找、插入、删除O(log n)，空间复杂度O(n)\n- 插入新节点：随机确定层数，按查找过程找插入位置，修改索引指针，层数超当前最高则新增索引层",
    "group_id": 16,
    "kps": [
      "数据结构"
    ],
    "years": [
      2024,
      2023,
      2022
    ],
    "corps": [
      "百奥",
      "腾讯",
      "美团",
      "腾讯音乐",
      "B站",
      "字节跳动"
    ]
  }
}