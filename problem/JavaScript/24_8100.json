{
  "success": true,
  "data": {
    "id": 8100,
    "name": "<p>手写 Promise.all</p>",
    "options": null,
    "answer": "<p>好的，下面是一个手写 <code>Promise.all</code> 的简单实现。<code>Promise.all</code> 是一个静态方法，它接受一个 iterable（如数组）作为参数，并返回一个新的 Promise，该 Promise 在所有输入的 Promise 都成功时被解决，或者只要有一个 Promise 被拒绝时就被拒绝。</p>\n<p>这是一个简单的实现示例：</p>\n<pre><code class=\"language-javascript\">function myPromiseAll(promises) {\n    // 返回一个新的Promise\n    return new Promise((resolve, reject) => {\n        // 如果传入的不是一个可迭代对象，抛出错误\n        if (!Array.isArray(promises)) {\n            return reject(new TypeError(\"Argument must be an array\"));\n        }\n\n        const results = [];          // 用于存储 resolved 的结果\n        let completed = 0;           // 计数器，记录已成功的 Promise 数量\n\n        if (promises.length === 0) {\n            return resolve(results); // 如果没有 Promise，直接解决为空数组\n        }\n\n        // 遍历每一个 Promise\n        promises.forEach((promise, index) => {\n            // 确保每个 item 是一个 Promise\n            Promise.resolve(promise)\n                .then(value => {\n                    results[index] = value; // 将成功的结果存入对应的索引\n                    completed++;             // 增加计数\n\n                    // 如果所有的 Promise 都成功，调用 resolve\n                    if (completed === promises.length) {\n                        resolve(results);\n                    }\n                })\n                .catch(error => {\n                    // 只要一个 Promise 被拒绝，就调用 reject\n                    reject(error);\n                });\n        });\n    });\n}\n\n// 使用示例\nconst promise1 = Promise.resolve(3);\nconst promise2 = 42; // 非 Promise 也会被转换\nconst promise3 = new Promise((resolve, reject) => {\n    setTimeout(resolve, 100, 'foo');\n});\n\nmyPromiseAll([promise1, promise2, promise3]).then(values => {\n    console.log(values); // [3, 42, 'foo']\n}).catch(error => {\n    console.error(error);\n});\n</code></pre>\n<h3>实现说明：</h3>\n<ol>\n  <li><strong>参数检查</strong>：首先检查传入的参数是否为数组。</li>\n  <li><strong>处理空数组</strong>：如果入参数组长度为0，直接返回空数组。</li>\n  <li><strong>遍历输入的 Promise</strong>：使用 <code>forEach</code> 遍历传入的 Promise 数组，对每个 Promise 使用 <code>Promise.resolve</code> 进行处理，确保其为 Promise。</li>\n  <li><strong>处理 resolved</strong>：如果某个 Promise 成功，结果存到 <code>results</code> 数组中，并增加 <code>completed</code> 计数。如果所有 Promise 都已成功，调用 <code>resolve</code>。</li>\n  <li><strong>处理 rejected</strong>：只要有一个 Promise 被拒绝，立即调用 <code>reject</code>。</li>\n</ol>\n<p>这种实现方式比较简单，适用于基本场景。对于更复杂的使用场景，可能需要处理更多边界情况。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.03499327,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：手写一个与 JavaScript 原生 <code>Promise.all</code> 功能相同的函数。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对 <code>Promise</code> 原理的理解。</li>\n      <li>处理多个 <code>Promise</code> 并发执行的能力。</li>\n      <li>如何管理 <code>Promise</code> 的状态和结果收集。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Promise.all 功能</h4>\n<p><code>Promise.all</code> 接收一个可迭代对象（通常是数组），该对象包含多个 <code>Promise</code> 实例。它返回一个新的 <code>Promise</code> 实例，这个新的 <code>Promise</code> 实例在所有传入的 <code>Promise</code> 都成功时才会成功，其结果是一个包含所有传入 <code>Promise</code> 结果的数组，顺序与传入的顺序一致。如果其中任何一个 <code>Promise</code> 失败，则新的 <code>Promise</code> 会立即失败，并返回第一个失败 <code>Promise</code> 的错误信息。</p>\n<h4>（2）Promise 状态</h4>\n<p><code>Promise</code> 有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。状态一旦改变就不会再变。</p>\n<h3>3. 解析</h3>\n<h4>（1）实现思路</h4>\n<ul>\n  <li>创建一个新的 <code>Promise</code> 实例，用于返回最终结果。</li>\n  <li>遍历传入的可迭代对象，为每个 <code>Promise</code> 添加 <code>then</code> 和 <code>catch</code> 回调。</li>\n  <li>使用计数器记录已完成的 <code>Promise</code> 数量，当计数器等于传入 <code>Promise</code> 的总数时，说明所有 <code>Promise</code> 都已成功，将结果数组传递给新 <code>Promise</code> 的 <code>resolve</code> 方法。</li>\n  <li>如果任何一个 <code>Promise</code> 失败，立即调用新 <code>Promise</code> 的 <code>reject</code> 方法，并传入失败的错误信息。</li>\n</ul>\n<h4>（2）代码实现</h4>\n<pre><code class=\"language-javascript\">function myPromiseAll(promises) {\n    return new Promise((resolve, reject) => {\n        const results = [];\n        let completedCount = 0;\n\n        if (promises.length === 0) {\n            resolve(results);\n            return;\n        }\n\n        promises.forEach((promise, index) => {\n            Promise.resolve(promise).then((value) => {\n                results[index] = value;\n                completedCount++;\n\n                if (completedCount === promises.length) {\n                    resolve(results);\n                }\n            }).catch((error) => {\n                reject(error);\n            });\n        });\n    });\n}\n</code></pre>\n<h4>（3）代码解释</h4>\n<ul>\n  <li><code>Promise.resolve(promise)</code> 确保传入的元素是一个 <code>Promise</code> 实例，如果不是则将其转换为已解决的 <code>Promise</code>。</li>\n  <li><code>results[index] = value</code> 确保结果数组的顺序与传入的 <code>Promise</code> 顺序一致。</li>\n  <li><code>completedCount</code> 用于记录已完成的 <code>Promise</code> 数量，当它等于 <code>promises.length</code> 时，说明所有 <code>Promise</code> 都已成功，调用 <code>resolve(results)</code> 返回结果数组。</li>\n  <li>如果任何一个 <code>Promise</code> 失败，调用 <code>reject(error)</code> 立即终止并返回错误信息。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-javascript\">const promise1 = Promise.resolve(1);\nconst promise2 = new Promise((resolve) => setTimeout(() => resolve(2), 1000));\nconst promise3 = Promise.resolve(3);\n\nmyPromiseAll([promise1, promise2, promise3]).then((values) => {\n    console.log(values); // 输出: [1, 2, 3]\n}).catch((error) => {\n    console.error(error);\n});\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）结果顺序问题</h4>\n<ul>\n  <li>误区：没有按照传入的 <code>Promise</code> 顺序存储结果，导致最终结果数组顺序混乱。</li>\n  <li>纠正：使用索引来存储每个 <code>Promise</code> 的结果，确保结果数组的顺序与传入的顺序一致。</li>\n</ul>\n<h4>（2）边界情况处理</h4>\n<ul>\n  <li>误区：没有处理传入的可迭代对象为空的情况。</li>\n  <li>纠正：在函数开始时检查传入的可迭代对象的长度，如果为 0 则立即返回一个已解决的 <code>Promise</code>，结果为空数组。</li>\n</ul>\n<h4>（3）错误处理</h4>\n<ul>\n  <li>误区：没有正确处理 <code>Promise</code> 失败的情况，导致一个 <code>Promise</code> 失败后程序继续执行。</li>\n  <li>纠正：为每个 <code>Promise</code> 添加 <code>catch</code> 回调，当任何一个 <code>Promise</code> 失败时，立即调用新 <code>Promise</code> 的 <code>reject</code> 方法。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“可以通过以下代码实现 <code>Promise.all</code> 功能：</p>\n<pre><code class=\"language-javascript\">function myPromiseAll(promises) {\n    return new Promise((resolve, reject) => {\n        const results = [];\n        let completedCount = 0;\n\n        if (promises.length === 0) {\n            resolve(results);\n            return;\n        }\n\n        promises.forEach((promise, index) => {\n            Promise.resolve(promise).then((value) => {\n                results[index] = value;\n                completedCount++;\n\n                if (completedCount === promises.length) {\n                    resolve(results);\n                }\n            }).catch((error) => {\n                reject(error);\n            });\n        });\n    });\n}\n</code></pre>\n<p>实现思路是创建一个新的 <code>Promise</code> 实例，遍历传入的可迭代对象，为每个 <code>Promise</code> 添加 <code>then</code> 和 <code>catch</code> 回调，使用计数器记录已完成的 <code>Promise</code> 数量，当所有 <code>Promise</code> 都成功时返回结果数组，任何一个 <code>Promise</code> 失败则立即返回错误信息。同时要注意处理结果顺序、边界情况和错误处理等问题。”</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>Promise.race的实现</strong><br>提示：请解释Promise.race的工作机制，并尝试手写它。</p>\n  </li>\n  <li>\n    <p><strong>处理错误</strong><br>提示：在你的Promise.all实现中，如何处理其中一个Promise失败的情况？完整执行还是立即返回？</p>\n  </li>\n  <li>\n    <p><strong>并发限制</strong><br>提示：如果你想限制同时执行的Promise数量，如何实现？可以采用什么样的策略？</p>\n  </li>\n  <li>\n    <p><strong>性能优化</strong><br>提示：在何种情况下使用Promise.all会导致性能问题？你会如何改进？</p>\n  </li>\n  <li>\n    <p><strong>Promise的链式调用</strong><br>提示：请解释Promise的链式调用机制，如何确保每个Promise的执行顺序？</p>\n  </li>\n  <li>\n    <p><strong>异步迭代</strong><br>提示：在一些场景中，需要异步迭代数组数据，是否可以用Promise.all处理？如果不能，为什么？</p>\n  </li>\n  <li>\n    <p><strong>Abortable Promises</strong><br>提示：如果需要中止一个Promise，怎样设计你的Promise实现来支持这一点？</p>\n  </li>\n  <li>\n    <p><strong>Promise的取消机制</strong><br>提示：JavaScript的Promise没有取消机制，你认为应该如何实现一个可取消的Promise？</p>\n  </li>\n  <li>\n    <p><strong>不同环境下的Promise行为</strong><br>提示：在Node.js与浏览器环境中的Promise行为有什么主要区别吗？如何处理？</p>\n  </li>\n  <li>\n    <p><strong>结合async/await</strong><br>提示：如何利用async/await语法简化Promise.all的使用？请给出示例。</p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Promise.all 实现))\n    参数检查\n      检查是否为数组\n    处理空数组\n      直接返回空数组\n    遍历输入的 Promise\n      使用 forEach 遍历\n      使用 Promise.resolve 确保每个元素是 Promise\n    处理 resolved\n      存储结果到 results 数组\n      增加 completed 计数\n      所有成功时调用 resolve\n    处理 rejected\n      一旦拒绝立即调用 reject",
    "keynote": "- 参数检查：确保传入的是数组，否则抛出 TypeError。\n- 处理空数组：如果数组为空，则直接解决返回空数组。\n- 遍历输入的 Promise：使用 `forEach` 来遍历每个 Promise，并通过 `Promise.resolve` 确保它们都是有效的 Promise 对象。\n- 处理 resolved：将每个成功的结果保存在对应的索引位置上，当所有 Promise 完成时，整体 resolve。\n- 处理 rejected：只要有一个 Promise 被拒绝，整个过程就 reject。",
    "group_id": 24,
    "kps": [
      "ES6",
      "异步编程"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "字节跳动",
      "MiniMax",
      "趣链科技",
      "猫眼娱乐",
      "贝壳",
      "B站",
      "慧策",
      "美团",
      "杭州兑吧",
      "同花顺",
      "心影随行",
      "米哈游",
      "小米",
      "Shopee虾皮",
      "滴滴",
      "深信服",
      "拼多多",
      "携程",
      "猿辅导",
      "用友",
      "小红书",
      "去哪儿旅行",
      "去哪儿网",
      "商汤科技",
      "瓜子二手车",
      "上海爱数信息技术股份有限公司",
      "Momenta",
      "字节飞书",
      "掌阅科技",
      "杭州生机勃勃智能科技",
      "字节抖音",
      "小荷健康",
      "腾讯",
      "阿里巴巴",
      "淘天集团",
      "百度",
      "网易",
      "快手",
      "度小满",
      "途虎养车"
    ]
  }
}