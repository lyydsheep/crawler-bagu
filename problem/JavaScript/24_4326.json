{
  "success": true,
  "data": {
    "id": 4326,
    "name": "<p>JavaScript中手写Promise ？</p>",
    "options": null,
    "answer": "<p>在 JavaScript 中，<code>Promise</code> 是一个表示异步操作最终完成或失败的对象。虽然现代 JavaScript 已经内置了 <code>Promise</code>，但了解如何手写一个简单的 <code>Promise</code> 实现有助于理解其工作原理。</p>\n<p>下面是一个简化的 <code>Promise</code> 实现，展示了其核心概念：</p>\n<pre><code class=\"language-javascript\">class MyPromise {\n    constructor(executor) {\n        this.state = 'pending'; // 初始状态为 pending\n        this.value = undefined; // 存储成功结果\n        this.reason = undefined; // 存储失败原因\n\n        // 用于存储 then 方法传入的回调函数\n        this.onFulfilledCallbacks = [];\n        this.onRejectedCallbacks = [];\n\n        // 成功的回调\n        const resolve = (value) => {\n            if (this.state === 'pending') {\n                this.state = 'fulfilled'; // 改变状态为 fulfilled\n                this.value = value;\n                // 执行所有成功的回调\n                this.onFulfilledCallbacks.forEach(fn => fn());\n            }\n        };\n\n        // 失败的回调\n        const reject = (reason) => {\n            if (this.state === 'pending') {\n                this.state = 'rejected'; // 改变状态为 rejected\n                this.reason = reason;\n                // 执行所有失败的回调\n                this.onRejectedCallbacks.forEach(fn => fn());\n            }\n        };\n\n        try {\n            // 立即执行 executor 函数，并传入 resolve 和 reject\n            executor(resolve, reject);\n        } catch (error) {\n            // 如果 executor 抛出异常，则直接调用 reject\n            reject(error);\n        }\n    }\n\n    // then 方法\n    then(onFulfilled, onRejected) {\n        // 如果没有传入 onFulfilled 或 onRejected，则使用默认的空函数\n        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };\n\n        let promise2;\n\n        if (this.state === 'fulfilled') {\n            // 如果当前状态是 fulfilled，立即执行 onFulfilled 回调\n            promise2 = new MyPromise((resolve, reject) => {\n                setTimeout(() => { // 使用 setTimeout 模拟异步行为\n                    try {\n                        const x = onFulfilled(this.value);\n                        resolvePromise(promise2, x, resolve, reject);\n                    } catch (error) {\n                        reject(error);\n                    }\n                }, 0);\n            });\n        }\n\n        if (this.state === 'rejected') {\n            // 如果当前状态是 rejected，立即执行 onRejected 回调\n            promise2 = new MyPromise((resolve, reject) => {\n                setTimeout(() => { // 使用 setTimeout 模拟异步行为\n                    try {\n                        const x = onRejected(this.reason);\n                        resolvePromise(promise2, x, resolve, reject);\n                    } catch (error) {\n                        reject(error);\n                    }\n                }, 0);\n            });\n        }\n\n        if (this.state === 'pending') {\n            // 如果当前状态是 pending，将回调函数存储起来，等待状态改变后再执行\n            promise2 = new MyPromise((resolve, reject) => {\n                this.onFulfilledCallbacks.push(() => {\n                    setTimeout(() => { // 使用 setTimeout 模拟异步行为\n                        try {\n                            const x = onFulfilled(this.value);\n                            resolvePromise(promise2, x, resolve, reject);\n                        } catch (error) {\n                            reject(error);\n                        }\n                    }, 0);\n                });\n\n                this.onRejectedCallbacks.push(() => {\n                    setTimeout(() => { // 使用 setTimeout 模拟异步行为\n                        try {\n                            const x = onRejected(this.reason);\n                            resolvePromise(promise2, x, resolve, reject);\n                        } catch (error) {\n                            reject(error);\n                        }\n                    }, 0);\n                });\n            });\n        }\n\n        return promise2;\n    }\n\n    // catch 方法\n    catch(onRejected) {\n        return this.then(null, onRejected);\n    }\n\n    // finally 方法\n    finally(callback) {\n        return this.then(\n            value => MyPromise.resolve(callback()).then(() => value),\n            reason => MyPromise.resolve(callback()).then(() => { throw reason })\n        );\n    }\n}\n\n// resolvePromise 函数，处理 promise 链式调用时的返回值\nfunction resolvePromise(promise2, x, resolve, reject) {\n    // 防止循环引用\n    if (promise2 === x) {\n        return reject(new TypeError('Chaining cycle detected for promise'));\n    }\n\n    let called = false; // 标记是否已经调用过 resolve 或 reject\n\n    if (x !== null &#x26;&#x26; (typeof x === 'object' || typeof x === 'function')) {\n        try {\n            const then = x.then; // 获取 x 的 then 方法\n            if (typeof then === 'function') {\n                // 如果 x 是一个 thenable 对象（具有 then 方法），则将其视为 Promise\n                then.call(x, y => {\n                    if (called) return;\n                    called = true;\n                    resolvePromise(promise2, y, resolve, reject); // 递归解析\n                }, r => {\n                    if (called) return;\n                    called = true;\n                    reject(r);\n                });\n            } else {\n                // 如果 x 不是一个 thenable 对象，则直接 resolve\n                resolve(x);\n            }\n        } catch (error) {\n            if (called) return;\n            called = true;\n            reject(error);\n        }\n    } else {\n        // 如果 x 是一个普通值，则直接 resolve\n        resolve(x);\n    }\n}\n\n// 静态方法：resolve\nMyPromise.resolve = function (value) {\n    return new MyPromise((resolve, reject) => {\n        resolve(value);\n    });\n};\n\n// 静态方法：reject\nMyPromise.reject = function (reason) {\n    return new MyPromise((resolve, reject) => {\n        reject(reason);\n    });\n};\n\n// 静态方法：all\nMyPromise.all = function (promises) {\n    return new MyPromise((resolve, reject) => {\n        let count = 0;\n        const result = [];\n        promises.forEach((promise, index) => {\n            MyPromise.resolve(promise).then(value => {\n                count++;\n                result[index] = value;\n                if (count === promises.length) {\n                    resolve(result);\n                }\n            }, reject);\n        });\n    });\n};\n\n// 静态方法：race\nMyPromise.race = function (promises) {\n    return new MyPromise((resolve, reject) => {\n        promises.forEach(promise => {\n            MyPromise.resolve(promise).then(resolve, reject);\n        });\n    });\n};\n</code></pre>\n<h3>代码说明：</h3>\n<ol>\n  <li>\n    <p><strong>构造函数</strong>：<code>MyPromise</code> 构造函数接受一个 <code>executor</code> 函数，该函数有两个参数：<code>resolve</code> 和 <code>reject</code>。<code>executor</code> 函数会在 <code>MyPromise</code> 实例化时立即执行。</p>\n  </li>\n  <li>\n    <p><strong>状态管理</strong>：<code>Promise</code> 有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。状态一旦从 <code>pending</code> 变为 <code>fulfilled</code> 或 <code>rejected</code>，就不能再改变。</p>\n  </li>\n  <li>\n    <p><strong><code>then</code> 方法</strong>：<code>then</code> 方法接受两个可选的回调函数：<code>onFulfilled</code> 和 <code>onRejected</code>。它会根据 <code>Promise</code> 的状态来决定何时调用这些回调函数。</p>\n  </li>\n  <li>\n    <p><strong><code>catch</code> 方法</strong>：<code>catch</code> 方法是 <code>then</code> 方法的一个简化形式，专门用于处理 <code>Promise</code> 的失败情况。</p>\n  </li>\n  <li>\n    <p><strong><code>finally</code> 方法</strong>：<code>finally</code> 方法无论 <code>Promise</code> 是否成功或失败都会执行。</p>\n  </li>\n  <li>\n    <p><strong>静态方法</strong>：</p>\n    <ul>\n      <li><code>MyPromise.resolve(value)</code>：返回一个以 <code>value</code> 解析的 <code>Promise</code>。</li>\n      <li><code>MyPromise.reject(reason)</code>：返回一个以 <code>reason</code> 拒绝的 <code>Promise</code>。</li>\n      <li><code>MyPromise.all(promises)</code>：接收一个 <code>Promise</code> 数组，当所有 <code>Promise</code> 都成功时返回一个包含所有结果的数组；如果有任何一个 <code>Promise</code> 失败，则返回第一个失败的 <code>Promise</code>。</li>\n      <li><code>MyPromise.race(promises)</code>：接收一个 <code>Promise</code> 数组，返回第一个完成的 <code>Promise</code>，无论是成功还是失败。</li>\n    </ul>\n  </li>\n</ol>\n<h3>测试代码：</h3>\n<pre><code class=\"language-javascript\">const myPromise = new MyPromise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('成功');\n    }, 1000);\n});\n\nmyPromise\n    .then(res => {\n        console.log(res); // 输出: 成功\n        return '下一个';\n    })\n    .then(res => {\n        console.log(res); // 输出: 下一个\n    })\n    .catch(err => {\n        console.error(err);\n    });\n</code></pre>\n<p>这个实现是一个简化的版本，省略了一些复杂的细节（如微任务队列、更严格的错误处理等），但它展示了 <code>Promise</code> 的核心机制。</p>",
    "type": 6,
    "level": 3,
    "freq": 0.0003364737,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：在JavaScript里手写一个Promise实现。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Promise状态机机制的理解，包括pending、fulfilled、rejected三种状态。</li>\n      <li>异步操作处理逻辑。</li>\n      <li>回调函数的管理和执行。</li>\n      <li>then方法链式调用的实现原理。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Promise状态</h4>\n<ul>\n  <li><strong>pending</strong>：初始状态，既不是成功，也不是失败状态。</li>\n  <li><strong>fulfilled</strong>：意味着操作成功完成。</li>\n  <li><strong>rejected</strong>：意味着操作失败。</li>\n  <li>状态一旦从pending变为fulfilled或rejected，就不能再改变。</li>\n</ul>\n<h4>（2）基本方法</h4>\n<ul>\n  <li><strong>then</strong>：用于处理Promise成功或失败的结果，可链式调用。</li>\n  <li><strong>catch</strong>：用于捕获Promise的错误，是then(null, onRejected)的语法糖。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）实现思路</h4>\n<ul>\n  <li>定义构造函数，接收一个执行器函数，执行器函数接收两个参数resolve和reject，用于改变Promise的状态。</li>\n  <li>定义状态和结果变量，以及成功和失败回调数组。</li>\n  <li>实现resolve和reject方法，用于改变状态和执行回调。</li>\n  <li>实现then方法，根据状态执行回调，并返回一个新的Promise以支持链式调用。</li>\n</ul>\n<h4>（2）代码实现</h4>\n<pre><code class=\"language-javascript\">// 定义Promise的三种状态\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\n\nclass MyPromise {\n    constructor(executor) {\n        // 初始状态为pending\n        this.status = PENDING;\n        // 存储结果\n        this.value = undefined;\n        // 存储错误信息\n        this.reason = undefined;\n        // 存储成功回调\n        this.onFulfilledCallbacks = [];\n        // 存储失败回调\n        this.onRejectedCallbacks = [];\n\n        const resolve = (value) => {\n            if (this.status === PENDING) {\n                this.status = FULFILLED;\n                this.value = value;\n                // 执行所有成功回调\n                this.onFulfilledCallbacks.forEach(callback => callback());\n            }\n        };\n\n        const reject = (reason) => {\n            if (this.status === PENDING) {\n                this.status = REJECTED;\n                this.reason = reason;\n                // 执行所有失败回调\n                this.onRejectedCallbacks.forEach(callback => callback());\n            }\n        };\n\n        try {\n            // 执行执行器函数\n            executor(resolve, reject);\n        } catch (error) {\n            // 捕获执行器函数中的错误并拒绝Promise\n            reject(error);\n        }\n    }\n\n    then(onFulfilled, onRejected) {\n        // 处理参数默认值\n        onFulfilled = typeof onFulfilled === 'function'? onFulfilled : value => value;\n        onRejected = typeof onRejected === 'function'? onRejected : error => { throw error; };\n\n        return new MyPromise((resolve, reject) => {\n            const handleFulfilled = () => {\n                try {\n                    const result = onFulfilled(this.value);\n                    // 如果结果是Promise，等待其状态改变\n                    if (result instanceof MyPromise) {\n                        result.then(resolve, reject);\n                    } else {\n                        resolve(result);\n                    }\n                } catch (error) {\n                    reject(error);\n                }\n            };\n\n            const handleRejected = () => {\n                try {\n                    const result = onRejected(this.reason);\n                    if (result instanceof MyPromise) {\n                        result.then(resolve, reject);\n                    } else {\n                        resolve(result);\n                    }\n                } catch (error) {\n                    reject(error);\n                }\n            };\n\n            if (this.status === FULFILLED) {\n                setTimeout(handleFulfilled, 0);\n            } else if (this.status === REJECTED) {\n                setTimeout(handleRejected, 0);\n            } else {\n                // 状态为pending，存储回调\n                this.onFulfilledCallbacks.push(() => setTimeout(handleFulfilled, 0));\n                this.onRejectedCallbacks.push(() => setTimeout(handleRejected, 0));\n            }\n        });\n    }\n\n    catch(onRejected) {\n        return this.then(null, onRejected);\n    }\n}\n\n// 示例使用\nconst promise = new MyPromise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('Success');\n    }, 1000);\n});\n\npromise.then((value) => {\n    console.log(value);\n}).catch((error) => {\n    console.error(error);\n});\n</code></pre>\n<h3>4. 常见误区</h3>\n<h4>（1）状态管理错误</h4>\n<ul>\n  <li>误区：没有正确控制Promise状态的转换，导致状态可以多次改变。</li>\n  <li>纠正：在resolve和reject方法中添加状态判断，确保状态一旦改变就不能再变。</li>\n</ul>\n<h4>（2）异步处理问题</h4>\n<ul>\n  <li>误区：没有考虑异步操作，直接执行回调，导致回调执行顺序错误。</li>\n  <li>纠正：使用setTimeout将回调放入异步队列，确保在状态改变后再执行。</li>\n</ul>\n<h4>（3）链式调用实现错误</h4>\n<ul>\n  <li>误区：then方法没有返回新的Promise，导致无法链式调用。</li>\n  <li>纠正：在then方法中返回一个新的Promise，并根据回调结果改变新Promise的状态。</li>\n</ul>\n<h3>5. 总结回答</h3>\n<p>“在JavaScript中可以手写一个Promise。首先要明确Promise有pending、fulfilled、rejected三种状态，状态一旦改变就不能再变。实现时，定义一个构造函数接收执行器函数，执行器函数接收resolve和reject两个参数用于改变状态。同时定义状态、结果、错误信息变量，以及成功和失败回调数组。</p>\n<p>实现resolve和reject方法来改变状态并执行相应回调，实现then方法处理成功和失败结果，且返回一个新的Promise以支持链式调用。另外，要注意处理异步操作，将回调放入异步队列。同时要避免状态管理错误、异步处理不当和链式调用实现错误等常见问题。”</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>Promise的状态管理</strong><br>提示：请解释一下Promise的三种状态及其转换过程。</p>\n  </li>\n  <li>\n    <p><strong>Promise的链式调用</strong><br>提示：可以描述一下如何实现Promise的链式调用以及其带来的优势吗？</p>\n  </li>\n  <li>\n    <p><strong>Promise的错误处理</strong><br>提示：在Promise链中，如果某个then中的操作抛出错误，该如何处理？</p>\n  </li>\n  <li>\n    <p><strong>async/await与Promise的关系</strong><br>提示：请阐述async/await是如何基于Promise实现的，以及它相较于传统Promise的优缺点。</p>\n  </li>\n  <li>\n    <p><strong>Promise.all和Promise.race</strong><br>提示：你能解释这两个方法的用途和它们之间的区别吗？</p>\n  </li>\n  <li>\n    <p><strong>自定义Promise的场景</strong><br>提示：在什么情况下你会考虑自定义一个Promise？请给出一些实际应用场景的例子。</p>\n  </li>\n  <li>\n    <p><strong>Promise的延迟执行</strong><br>提示：如何实现一个能延迟执行的Promise？可以举个例子吗？</p>\n  </li>\n  <li>\n    <p><strong>Promise的取消机制</strong><br>提示：Promise本身并不支持取消操作，你能阐述一下如何实现一个可取消的Promise吗？</p>\n  </li>\n  <li>\n    <p><strong>Promise的并发处理</strong><br>提示：在处理多个异步操作时，你认为Promise提供了哪些方式来提高并发处理效率？</p>\n  </li>\n  <li>\n    <p><strong>与其他异步处理机制的比较</strong><br>提示：请比较一下Promise与回调函数和事件发射器在异步编程中的优势和劣势。</p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((JavaScript手写Promise实现))\n    Promise概念\n      表示异步操作结果的对象\n      了解手写实现助于理解原理\n    代码实现\n      构造函数\n        接收executor函数\n        立即执行executor\n      状态管理\n        pending（进行中）\n        fulfilled（已成功）\n        rejected（已失败）\n        状态改变不可逆\n      then方法\n        接收onFulfilled和onRejected回调\n        根据状态决定回调执行时机\n      catch方法\n        处理Promise失败情况\n      finally方法\n        无论结果都执行\n      静态方法\n        resolve(value)\n        reject(reason)\n        all(promises)\n        race(promises)\n    代码说明\n      构造函数特性\n      状态变化规则\n      各方法功能\n    测试代码\n      模拟异步操作\n      链式调用then和catch",
    "keynote": "### 关键要点\n1. **Promise概念**\n    - 是表示异步操作最终完成或失败的对象。\n    - 手写实现有助于理解其工作原理。\n2. **代码实现**\n    - **构造函数**：接收 `executor` 函数，包含 `resolve` 和 `reject` 参数，实例化时立即执行。\n    - **状态管理**：三种状态 `pending`、`fulfilled`、`rejected`，状态改变不可逆。\n    - **then方法**：接收 `onFulfilled` 和 `onRejected` 回调，根据状态决定执行时机。\n    - **catch方法**：专门处理 `Promise` 失败情况。\n    - **finally方法**：无论 `Promise` 结果如何都会执行。\n    - **静态方法**\n        - `resolve(value)`：返回以 `value` 解析的 `Promise`。\n        - `reject(reason)`：返回以 `reason` 拒绝的 `Promise`。\n        - `all(promises)`：所有 `Promise` 成功时返回结果数组，有一个失败则返回第一个失败的 `Promise`。\n        - `race(promises)`：返回第一个完成的 `Promise`。\n3. **测试代码**：模拟异步操作，进行 `then` 和 `catch` 的链式调用。",
    "group_id": 24,
    "kps": [
      "ES6",
      "异步编程",
      "代码实现"
    ],
    "years": [
      2024
    ],
    "corps": [
      "携程"
    ]
  }
}