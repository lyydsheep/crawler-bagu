{
  "success": true,
  "data": {
    "id": 20074,
    "name": "<p>如何判断JavaScript数据类型</p>",
    "options": null,
    "answer": "<p>在 JavaScript 中，有多种方式可以判断数据类型，以下为你详细介绍：</p>\n<h3>1. typeof 操作符</h3>\n<p><code>typeof</code> 是一个一元操作符，返回一个表示数据类型的字符串。它能快速区分基本数据类型，但对于对象和数组等引用类型，除了函数外，都返回 <code>object</code>。</p>\n<pre><code class=\"language-javascript\">console.log(typeof undefined); // \"undefined\"\nconsole.log(typeof true); // \"boolean\"\nconsole.log(typeof 123); // \"number\"\nconsole.log(typeof 'hello'); // \"string\"\nconsole.log(typeof Symbol()); // \"symbol\"\nconsole.log(typeof BigInt(10)); // \"bigint\"\nconsole.log(typeof function() {}); // \"function\"\nconsole.log(typeof {}); // \"object\"\nconsole.log(typeof []); // \"object\"\nconsole.log(typeof null); // \"object\"（这是 JavaScript 语言的一个历史遗留问题）\n</code></pre>\n<h3>2. instanceof 操作符</h3>\n<p><code>instanceof</code> 用于判断一个对象是否是某个构造函数的实例，它会检查对象的原型链。</p>\n<pre><code class=\"language-javascript\">function Person() {}\nconst person = new Person();\nconsole.log(person instanceof Person); // true\n\nconst arr = [];\nconsole.log(arr instanceof Array); // true\nconsole.log(arr instanceof Object); // true\n\nconst date = new Date();\nconsole.log(date instanceof Date); // true\n</code></pre>\n<h3>3. Object.prototype.toString.call()</h3>\n<p><code>Object.prototype.toString.call()</code> 方法可以返回一个表示数据类型的字符串，格式为 <code>[object Type]</code>，其中 <code>Type</code> 是具体的数据类型。这种方法能准确区分各种数据类型，包括基本数据类型和引用数据类型。</p>\n<pre><code class=\"language-javascript\">console.log(Object.prototype.toString.call(undefined)); // \"[object Undefined]\"\nconsole.log(Object.prototype.toString.call(null)); // \"[object Null]\"\nconsole.log(Object.prototype.toString.call(true)); // \"[object Boolean]\"\nconsole.log(Object.prototype.toString.call(123)); // \"[object Number]\"\nconsole.log(Object.prototype.toString.call('hello')); // \"[object String]\"\nconsole.log(Object.prototype.toString.call(Symbol())); // \"[object Symbol]\"\nconsole.log(Object.prototype.toString.call(BigInt(10))); // \"[object BigInt]\"\nconsole.log(Object.prototype.toString.call(function() {})); // \"[object Function]\"\nconsole.log(Object.prototype.toString.call([])); // \"[object Array]\"\nconsole.log(Object.prototype.toString.call({})); // \"[object Object]\"\nconsole.log(Object.prototype.toString.call(new Date())); // \"[object Date]\"\nconsole.log(Object.prototype.toString.call(/abc/)); // \"[object RegExp]\"\n</code></pre>\n<h3>4. Array.isArray()</h3>\n<p><code>Array.isArray()</code> 是一个专门用于判断一个值是否为数组的方法，它比 <code>typeof</code> 更准确。</p>\n<pre><code class=\"language-javascript\">const arr = [];\nconst obj = {};\nconsole.log(Array.isArray(arr)); // true\nconsole.log(Array.isArray(obj)); // false\n</code></pre>\n<h3>5. 使用自定义函数封装判断逻辑</h3>\n<p>可以将 <code>Object.prototype.toString.call()</code> 封装成一个函数，方便使用。</p>\n<pre><code class=\"language-javascript\">function getType(value) {\n    return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nconsole.log(getType(undefined)); // \"Undefined\"\nconsole.log(getType(null)); // \"Null\"\nconsole.log(getType([])); // \"Array\"\n</code></pre>",
    "type": 6,
    "level": 1,
    "freq": 0.02860027,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：在JavaScript里怎样判断数据类型。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对JavaScript不同数据类型的了解。</li>\n      <li>掌握判断数据类型的多种方法及其适用场景。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）JavaScript数据类型</h4>\n<ul>\n  <li><strong>基本数据类型</strong>：包括<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code>（ES6新增）、<code>bigint</code>（ES2020新增）。</li>\n  <li><strong>引用数据类型</strong>：如<code>object</code>（包含数组、函数、日期等特殊对象）。</li>\n</ul>\n<h4>（2）判断数据类型的重要性</h4>\n<p>在编写代码时，根据不同的数据类型进行不同的操作，避免因数据类型不匹配导致的错误。</p>\n<h3>3. 解析</h3>\n<h4>（1）typeof运算符</h4>\n<ul>\n  <li><strong>原理</strong>：返回一个表示数据类型的字符串。</li>\n  <li><strong>适用场景</strong>：能快速判断基本数据类型，但对于<code>null</code>和引用数据类型判断不准确。</li>\n  <li><strong>示例</strong>：</li>\n</ul>\n<pre><code class=\"language-javascript\">console.log(typeof undefined); // \"undefined\"\nconsole.log(typeof true); // \"boolean\"\nconsole.log(typeof 123); // \"number\"\nconsole.log(typeof 'hello'); // \"string\"\nconsole.log(typeof Symbol()); // \"symbol\"\nconsole.log(typeof 123n); // \"bigint\"\nconsole.log(typeof []); // \"object\"\nconsole.log(typeof null); // \"object\"\n</code></pre>\n<h4>（2）instanceof运算符</h4>\n<ul>\n  <li><strong>原理</strong>：用于判断对象是否是某个构造函数的实例。</li>\n  <li><strong>适用场景</strong>：常用于判断引用数据类型，如数组、自定义对象等。</li>\n  <li><strong>示例</strong>：</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr = [];\nconsole.log(arr instanceof Array); // true\nfunction Person() {}\nconst person = new Person();\nconsole.log(person instanceof Person); // true\n</code></pre>\n<h4>（3）Object.prototype.toString.call()方法</h4>\n<ul>\n  <li><strong>原理</strong>：返回一个表示对象类型的字符串，格式为<code>[object Type]</code>。</li>\n  <li><strong>适用场景</strong>：能准确判断所有数据类型。</li>\n  <li><strong>示例</strong>：</li>\n</ul>\n<pre><code class=\"language-javascript\">console.log(Object.prototype.toString.call(undefined)); // \"[object Undefined]\"\nconsole.log(Object.prototype.toString.call(null)); // \"[object Null]\"\nconsole.log(Object.prototype.toString.call(true)); // \"[object Boolean]\"\nconsole.log(Object.prototype.toString.call(123)); // \"[object Number]\"\nconsole.log(Object.prototype.toString.call('hello')); // \"[object String]\"\nconsole.log(Object.prototype.toString.call(Symbol())); // \"[object Symbol]\"\nconsole.log(Object.prototype.toString.call(123n)); // \"[object BigInt]\"\nconsole.log(Object.prototype.toString.call([])); // \"[object Array]\"\n</code></pre>\n<h4>（4）Array.isArray()方法</h4>\n<ul>\n  <li><strong>原理</strong>：专门用于判断一个值是否为数组。</li>\n  <li><strong>适用场景</strong>：当需要判断一个值是否为数组时使用。</li>\n  <li><strong>示例</strong>：</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr = [];\nconsole.log(Array.isArray(arr)); // true\n</code></pre>\n<h3>4. 常见误区</h3>\n<h4>（1）过度依赖typeof</h4>\n<ul>\n  <li>误区：认为<code>typeof</code>能准确判断所有数据类型。</li>\n  <li>纠正：<code>typeof</code>对<code>null</code>和引用数据类型判断不准确，对于复杂数据类型判断需结合其他方法。</li>\n</ul>\n<h4>（2）错误使用instanceof</h4>\n<ul>\n  <li>误区：用<code>instanceof</code>判断基本数据类型。</li>\n  <li>纠正：<code>instanceof</code>主要用于判断引用数据类型，基本数据类型不能用其判断。</li>\n</ul>\n<h4>（3）忽略Object.prototype.toString.call()的通用性</h4>\n<ul>\n  <li>误区：未意识到该方法能准确判断所有数据类型。</li>\n  <li>纠正：在需要准确判断数据类型时，优先考虑使用该方法。</li>\n</ul>\n<h3>5. 总结回答</h3>\n<p>在JavaScript中，判断数据类型有多种方法：</p>\n<ul>\n  <li><strong>typeof运算符</strong>：可快速判断基本数据类型，但对<code>null</code>和引用数据类型判断不准确。例如<code>typeof []</code>返回<code>\"object\"</code>，<code>typeof null</code>也返回<code>\"object\"</code>。</li>\n  <li><strong>instanceof运算符</strong>：用于判断对象是否是某个构造函数的实例，常用于判断引用数据类型，如<code>arr instanceof Array</code>可判断<code>arr</code>是否为数组。</li>\n  <li><strong>Object.prototype.toString.call()方法</strong>：能准确判断所有数据类型，返回格式为<code>[object Type]</code>，如<code>Object.prototype.toString.call([])</code>返回<code>\"[object Array]\"</code>。</li>\n  <li><strong>Array.isArray()方法</strong>：专门用于判断一个值是否为数组，如<code>Array.isArray([])</code>返回<code>true</code>。</li>\n</ul>\n<p>在实际应用中，应根据具体需求选择合适的方法进行数据类型判断。</p>",
    "more_ask": "<h3>1. <code>Object.prototype.toString.call()</code> 方法的原理是什么？</h3>\n<p>提示：思考 JavaScript 内部对象的属性和方法，以及该方法如何获取对象的类型信息。</p>\n<h3>2. 如何使用 <code>typeof</code> 判断 <code>null</code> 类型时避免误判？</h3>\n<p>提示：结合 <code>typeof</code> 对 <code>null</code> 的返回值和其他判断方式来解决。</p>\n<h3>3. 对于自定义对象，如何准确判断它是否是某个类的实例？</h3>\n<p>提示：考虑使用 <code>instanceof</code> 运算符，同时思考其局限性和其他补充判断方法。</p>\n<h3>4. 当使用 <code>typeof</code> 判断函数时，它返回的是什么？为什么会这样？</h3>\n<p>提示：回顾 <code>typeof</code> 对不同数据类型的返回值，以及函数在 JavaScript 中的特性。</p>\n<h3>5. 在判断数组类型时，<code>Array.isArray()</code> 和 <code>instanceof Array</code> 有什么区别？</h3>\n<p>提示：从跨窗口、跨 iframe 等场景去分析两者的差异。</p>\n<h3>6. 如何判断一个对象是否是纯对象（即通过 <code>{}</code> 或 <code>new Object()</code> 创建的对象）？</h3>\n<p>提示：可以结合 <code>Object.prototype.toString.call()</code> 和对象的原型链来判断。</p>\n<h3>7. 对于 <code>Symbol</code> 类型，除了 <code>typeof</code> 还有其他判断方式吗？</h3>\n<p>提示：思考 <code>Symbol</code> 类型的特性和相关的全局方法。</p>\n<h3>8. 如何判断一个变量是否是 <code>NaN</code>？</h3>\n<p>提示：<code>NaN</code> 有特殊的比较规则，可结合 <code>isNaN()</code> 和 <code>Number.isNaN()</code> 来分析。</p>",
    "mindmap": "mindmap\n  root((JavaScript数据类型判断方式))\n    typeof操作符\n      一元操作符，返回类型字符串\n      区分基本类型快\n      引用类型除函数外返回object\n      null返回object是历史遗留问题\n    instanceof操作符\n      判断对象是否为构造函数实例\n      检查对象原型链\n    Object.prototype.toString.call()\n      返回[object Type]格式字符串\n      准确区分各种类型\n    Array.isArray()\n      专门判断值是否为数组\n      比typeof更准确\n    自定义函数封装\n      封装Object.prototype.toString.call()",
    "keynote": "typeof操作符：一元，返回类型字符串，区分基本类型快，引用除函数外为object，null返回object是遗留问题\ninstanceof操作符：判断对象是否为构造函数实例，检查原型链\nObject.prototype.toString.call()：返回[object Type]，准确区分各类数据\nArray.isArray()：专门判断数组，比typeof准确\n自定义函数封装：封装Object.prototype.toString.call()",
    "group_id": 24,
    "kps": [
      "基础语法"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "字节跳动",
      "趣链科技",
      "中软国际",
      "美团",
      "百度",
      "网易有道",
      "数字马力",
      "小红书",
      "猫眼娱乐",
      "同程旅行",
      "携程",
      "小米",
      "滴滴",
      "360",
      "大华",
      "奇安信",
      "用友",
      "航天远景",
      "4399",
      "神策数据",
      "金山",
      "货拉拉",
      "爱数科技",
      "B站",
      "卫翎科技",
      "字节国际",
      "腾讯",
      "腾讯音乐",
      "阿里盒马",
      "阿里大文娱",
      "京东",
      "网易",
      "快手",
      "招银网络科技",
      "科大讯飞",
      "成都好未来科技",
      "好未来",
      "途虎养车",
      "阿里巴巴"
    ]
  }
}