{"success":true,"data":{"id":4335,"name":"<p>手写防抖、节流函数，此外防抖和节流的区别是什么 ？</p>","options":null,"answer":"<h3>防抖（Debounce）与节流（Throttle）的区别</h3>\n<p><strong>防抖（Debounce）</strong>:</p>\n<ul>\n  <li>防抖是指在事件触发后，n秒内不再触发该事件，重新计时。如果在n秒内再次触发事件，前一次的计时会被重置。通常用于输入框的输入事件，只有在输入结束后才会执行相关的操作。</li>\n</ul>\n<p><strong>节流（Throttle）</strong>:</p>\n<ul>\n  <li>节流是指在一定时间间隔内，只能执行一次事件处理函数。即使事件被频繁触发，也不会在短时间内执行多次，通常用于窗口的滚动、调整大小等事件。</li>\n</ul>\n<h3>防抖的实现</h3>\n<pre><code class=\"language-javascript\">function debounce(func, delay) {\n    let timer;\n    return function(...args) {\n        const context = this;\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n            func.apply(context, args);\n        }, delay);\n    };\n}\n\n// 使用示例\nconst log = debounce(() => {\n    console.log('Debounced!');\n}, 1000);\n\nwindow.addEventListener('resize', log);\n</code></pre>\n<h3>节流的实现</h3>\n<pre><code class=\"language-javascript\">function throttle(func, delay) {\n    let lastTime = 0;\n    return function(...args) {\n        const context = this;\n        const now = Date.now();\n        if (now - lastTime >= delay) {\n            lastTime = now;\n            func.apply(context, args);\n        }\n    };\n}\n\n// 使用示例\nconst log = throttle(() => {\n    console.log('Throttled!');\n}, 1000);\n\nwindow.addEventListener('scroll', log);\n</code></pre>\n<h3>总结</h3>\n<ul>\n  <li><strong>防抖</strong>适用于用户停止输入的场景，比如搜索框的联想词。</li>\n  <li><strong>节流</strong>适用于固定时间间隔的场景，尤其是频繁触发的事件，如滚动和调整窗口大小。</li>\n</ul>","type":6,"level":2,"freq":0.03701211,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：手写防抖、节流函数，并阐述防抖和节流的区别。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对防抖和节流概念的理解。</li>\n      <li>JavaScript 中函数的定义和闭包的运用。</li>\n      <li>对防抖和节流应用场景的认识。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）防抖（Debounce）</h4>\n<ul>\n  <li>防抖是指在一定时间内，只有最后一次触发事件才会执行相应的函数。如果在这个时间间隔内再次触发事件，会重新计时。常用于搜索框输入联想、窗口大小改变等场景，避免不必要的频繁计算。</li>\n</ul>\n<h4>（2）节流（Throttle）</h4>\n<ul>\n  <li>节流是指在一定时间内，只执行一次函数。如果在这个时间间隔内多次触发事件，只有第一次会生效，后续的触发会被忽略，直到时间间隔结束。常用于滚动加载、按钮点击等场景，控制函数的执行频率。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）手写防抖函数</h4>\n<pre><code class=\"language-javascript\">function debounce(func, delay) {\n    let timer = null;\n    return function() {\n        const context = this;\n        const args = arguments;\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeout(() => {\n            func.apply(context, args);\n        }, delay);\n    };\n}\n</code></pre>\n<p>在上述代码中，通过闭包保存了一个定时器 <code>timer</code>。每次调用返回的函数时，会清除之前的定时器并重新设置一个新的定时器。只有当延迟时间 <code>delay</code> 结束后，函数 <code>func</code> 才会被执行。</p>\n<h4>（2）手写节流函数</h4>\n<pre><code class=\"language-javascript\">function throttle(func, delay) {\n    let canRun = true;\n    return function() {\n        const context = this;\n        const args = arguments;\n        if (canRun) {\n            func.apply(context, args);\n            canRun = false;\n            setTimeout(() => {\n                canRun = true;\n            }, delay);\n        }\n    };\n}\n</code></pre>\n<p>在上述代码中，通过闭包保存了一个标志 <code>canRun</code>。当函数第一次被调用时，会执行函数并将 <code>canRun</code> 设为 <code>false</code>。在 <code>delay</code> 时间内，再次调用返回的函数时，由于 <code>canRun</code> 为 <code>false</code>，函数不会被执行。只有当 <code>delay</code> 时间结束，<code>canRun</code> 重新设为 <code>true</code> 后，函数才能再次被执行。</p>\n<h4>（3）防抖和节流的区别</h4>\n<ul>\n  <li><strong>执行时机</strong>：\n    <ul>\n      <li>防抖是在一定时间内，只有最后一次触发事件才会执行函数。</li>\n      <li>节流是在一定时间内，只执行第一次触发的函数。</li>\n    </ul>\n  </li>\n  <li><strong>应用场景</strong>：\n    <ul>\n      <li>防抖适用于需要避免频繁触发的场景，如搜索框输入联想、窗口大小改变等。</li>\n      <li>节流适用于需要控制执行频率的场景，如滚动加载、按钮点击等。</li>\n    </ul>\n  </li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-javascript\">// 防抖示例\nfunction search() {\n    console.log('Searching...');\n}\nconst debouncedSearch = debounce(search, 300);\nwindow.addEventListener('input', debouncedSearch);\n\n// 节流示例\nfunction loadMore() {\n    console.log('Loading more...');\n}\nconst throttledLoadMore = throttle(loadMore, 1000);\nwindow.addEventListener('scroll', throttledLoadMore);\n</code></pre>\n<p>在上述示例中，<code>debouncedSearch</code> 函数会在用户输入停止 300 毫秒后才执行 <code>search</code> 函数，避免了频繁搜索。<code>throttledLoadMore</code> 函数会在用户滚动页面时，每隔 1 秒执行一次 <code>loadMore</code> 函数，控制了加载的频率。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆防抖和节流的概念</h4>\n<ul>\n  <li>误区：不能准确区分防抖和节流的执行时机和应用场景。</li>\n  <li>纠正：理解防抖是最后一次触发生效，节流是第一次触发生效，并根据具体场景选择合适的方法。</li>\n</ul>\n<h4>（2）没有使用闭包</h4>\n<ul>\n  <li>误区：在实现防抖和节流函数时，没有使用闭包来保存定时器或标志变量。</li>\n  <li>纠正：使用闭包可以确保定时器或标志变量在函数调用之间保持状态。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>防抖函数和节流函数的实现如下：</p>\n<pre><code class=\"language-javascript\">// 防抖函数\nfunction debounce(func, delay) {\n    let timer = null;\n    return function() {\n        const context = this;\n        const args = arguments;\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeout(() => {\n            func.apply(context, args);\n        }, delay);\n    };\n}\n\n// 节流函数\nfunction throttle(func, delay) {\n    let canRun = true;\n    return function() {\n        const context = this;\n        const args = arguments;\n        if (canRun) {\n            func.apply(context, args);\n            canRun = false;\n            setTimeout(() => {\n                canRun = true;\n            }, delay);\n        }\n    };\n}\n</code></pre>\n<p>防抖和节流的区别在于：</p>\n<ul>\n  <li>执行时机：防抖是在一定时间内，只有最后一次触发事件才会执行函数；节流是在一定时间内，只执行第一次触发的函数。</li>\n  <li>应用场景：防抖适用于需要避免频繁触发的场景，如搜索框输入联想、窗口大小改变等；节流适用于需要控制执行频率的场景，如滚动加载、按钮点击等。</li>\n</ul>","more_ask":"<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>请解释一下你是如何实现防抖和节流函数的？</strong></p>\n    <ul>\n      <li>提示：着重关注实现的细节，比如使用的计时器及其清除方法。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在什么场景下你会选择使用防抖而不是节流？</strong></p>\n    <ul>\n      <li>提示：考虑用户交互的频率和需要响应的时间差。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如果需求变更，需要同时允许控制函数的执行频率和允许函数立即执行，你会怎么做？</strong></p>\n    <ul>\n      <li>提示：提到结合防抖与节流的思路。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何处理防抖和节流函数中的异步操作？</strong></p>\n    <ul>\n      <li>提示：探讨异步请求和状态管理的问题。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在大型应用中，如何优化防抖和节流函数的性能？</strong></p>\n    <ul>\n      <li>提示：考虑函数的复用、内存泄漏的风险等。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>能否给出防抖和节流在实际开发中的一些具体应用案例？</strong></p>\n    <ul>\n      <li>提示：从表单提交、滚动事件、窗口缩放等角度切入。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如果你需要在Vue或React框架中使用防抖或节流，你会如何实现？</strong></p>\n    <ul>\n      <li>提示：考虑组件生命周期和状态管理。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>描述事件绑定和解除时，防抖或节流函数的执行逻辑，你有哪些注意事项？</strong></p>\n    <ul>\n      <li>提示：关注如何确保在组件卸载时清理定时器。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>可以实现一个防抖或节流的类或工厂函数吗？</strong></p>\n    <ul>\n      <li>提示：考虑封装和扩展性。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在使用防抖函数时，如何确保最后一次事件调用也能被执行？</strong></p>\n    <ul>\n      <li>提示：讨论如何修改函数内部逻辑。</li>\n    </ul>\n  </li>\n</ol>","mindmap":"mindmap\n  root((防抖与节流))\n    防抖(Debounce)\n      定义\n      应用场景\n        输入框输入事件\n    节流(Throttle)\n      定义\n      应用场景\n        窗口滚动\n        调整大小\n    总结\n      防抖适用情况\n      节流适用情况","keynote":"- 防抖是指在事件触发后，n秒内不再触发该事件，重新计时。如果在n秒内再次触发事件，前一次的计时会被重置。\n- 防抖通常用于输入框的输入事件，只有在输入结束后才会执行相关的操作。\n- 节流是指在一定时间间隔内，只能执行一次事件处理函数。即使事件被频繁触发，也不会在短时间内执行多次。\n- 节流通常用于窗口的滚动、调整大小等事件。\n- 防抖适用于用户停止输入的场景，比如搜索框的联想词。\n- 节流适用于固定时间间隔的场景，尤其是频繁触发的事件，如滚动和调整窗口大小。","group_id":24,"kps":["异步编程","代码实现"],"years":[2025,2024,2023,2022],"corps":["腾讯云智","小鹅通","京东","滴滴","派诺科技","小米","字节跳动","小红书","晶果网络","网易","数新网络","腾讯","深圳吉比特","快手","比心","Shopee虾皮","深信服","拼多多","携程","顺丰","CVTE视源股份","蚂蚁集团","微软","B站","奇安信","用友","4399","酷家乐","旷视科技","浩鲸科技","知乎","金山","货拉拉","Momenta","游卡","飞猪","中国工商银行","美团","阿里巴巴","百度","好未来","度小满"]}}