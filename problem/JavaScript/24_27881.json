{
  "success": true,
  "data": {
    "id": 27881,
    "name": "<p>简述JavaScript继承的原理</p>",
    "options": null,
    "answer": "<p>JavaScript继承的核心目的是让一个对象能够使用另一个对象的属性和方法，其实现原理主要基于原型链、构造函数、组合继承、寄生组合继承等方式，下面分别介绍：</p>\n<h3>原型链继承</h3>\n<ul>\n  <li><strong>原理</strong>：JavaScript中每个对象都有一个内部属性 <code>[[Prototype]]</code>（在浏览器中可以通过 <code>__proto__</code> 访问），它指向该对象的原型对象。当访问一个对象的属性或方法时，JavaScript 首先会在该对象本身查找，如果找不到，就会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的末尾（即 <code>Object.prototype</code>）。</li>\n  <li><strong>示例代码</strong></li>\n</ul>\n<pre><code class=\"language-javascript\">function Parent() {\n    this.name = 'parent';\n}\nParent.prototype.sayName = function() {\n    console.log(this.name);\n};\n\nfunction Child() {}\n// 将Child的原型指向Parent的实例，从而形成原型链\nChild.prototype = new Parent();\n\nconst child = new Child();\nchild.sayName(); // 输出: parent\n</code></pre>\n<h3>构造函数继承</h3>\n<ul>\n  <li><strong>原理</strong>：在子类构造函数中通过 <code>call()</code>、<code>apply()</code> 或 <code>bind()</code> 方法调用父类构造函数，将父类的属性和方法添加到子类的实例中。</li>\n  <li><strong>示例代码</strong></li>\n</ul>\n<pre><code class=\"language-javascript\">function Parent() {\n    this.name = 'parent';\n}\nParent.prototype.sayName = function() {\n    console.log(this.name);\n};\n\nfunction Child() {\n    // 调用父类构造函数\n    Parent.call(this);\n}\n\nconst child = new Child();\nconsole.log(child.name); // 输出: parent\n</code></pre>\n<h3>组合继承</h3>\n<ul>\n  <li><strong>原理</strong>：结合了原型链继承和构造函数继承的优点。通过原型链继承实现对父类原型上属性和方法的继承，通过构造函数继承实现对父类实例属性的继承。</li>\n  <li><strong>示例代码</strong></li>\n</ul>\n<pre><code class=\"language-javascript\">function Parent() {\n    this.name = 'parent';\n}\nParent.prototype.sayName = function() {\n    console.log(this.name);\n};\n\nfunction Child() {\n    // 构造函数继承\n    Parent.call(this);\n}\n// 原型链继承\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nconst child = new Child();\nchild.sayName(); // 输出: parent\n</code></pre>\n<h3>寄生组合继承</h3>\n<ul>\n  <li><strong>原理</strong>：在组合继承的基础上进行优化，避免了两次调用父类构造函数。通过 <code>Object.create()</code> 方法创建一个以父类原型为原型的新对象，然后将该对象赋值给子类的原型。</li>\n  <li><strong>示例代码</strong></li>\n</ul>\n<pre><code class=\"language-javascript\">function Parent() {\n    this.name = 'parent';\n}\nParent.prototype.sayName = function() {\n    console.log(this.name);\n};\n\nfunction Child() {\n    // 构造函数继承\n    Parent.call(this);\n}\n// 寄生组合继承\nfunction inheritPrototype(Child, Parent) {\n    const prototype = Object.create(Parent.prototype);\n    prototype.constructor = Child;\n    Child.prototype = prototype;\n}\ninheritPrototype(Child, Parent);\n\nconst child = new Child();\nchild.sayName(); // 输出: parent\n</code></pre>\n<h3>class 继承（ES6）</h3>\n<ul>\n  <li><strong>原理</strong>：ES6 引入了 <code>class</code> 关键字和 <code>extends</code> 关键字，实现了更简洁的继承语法。其底层原理仍然基于原型链和构造函数继承。</li>\n  <li><strong>示例代码</strong></li>\n</ul>\n<pre><code class=\"language-javascript\">class Parent {\n    constructor() {\n        this.name = 'parent';\n    }\n    sayName() {\n        console.log(this.name);\n    }\n}\n\nclass Child extends Parent {\n    constructor() {\n        super();\n    }\n}\n\nconst child = new Child();\nchild.sayName(); // 输出: parent\n</code></pre>\n<p>综上所述，JavaScript 继承的原理主要是基于原型链和构造函数的特性，通过不同的方式实现对象之间属性和方法的共享和复用。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.02590848,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：简述JavaScript继承的原理。</li>\n  <li><strong>考察点</strong>：对JavaScript中不同继承方式原理的理解，包括原型链继承、构造函数继承、组合继承、寄生组合继承等，以及原型、原型链、构造函数等概念。</li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）原型与原型链</h4>\n<ul>\n  <li>每个对象都有一个内部属性<code>[[Prototype]]</code>（在浏览器中可通过<code>__proto__</code>访问），它指向该对象的原型对象。</li>\n  <li>当访问一个对象的属性或方法时，JavaScript首先在该对象本身查找，如果找不到，就会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的末尾（<code>Object.prototype</code>）。</li>\n</ul>\n<h4>（2）构造函数</h4>\n<ul>\n  <li>构造函数是一种特殊的函数，用于创建对象。使用<code>new</code>关键字调用构造函数时，会创建一个新对象，该对象继承自构造函数的<code>prototype</code>属性。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）原型链继承</h4>\n<ul>\n  <li><strong>原理</strong>：让子类的原型指向父类的实例，这样子类实例就可以通过原型链访问父类的属性和方法。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-javascript\">function Parent() {\n    this.name = 'parent';\n}\nParent.prototype.sayName = function() {\n    console.log(this.name);\n};\n\nfunction Child() {}\nChild.prototype = new Parent();\n\nconst child = new Child();\nchild.sayName(); \n</code></pre>\n<ul>\n  <li><strong>缺点</strong>：多个子类实例会共享父类的引用类型属性；创建子类实例时，无法向父类构造函数传递参数。</li>\n</ul>\n<h4>（2）构造函数继承</h4>\n<ul>\n  <li><strong>原理</strong>：在子类构造函数中使用<code>call</code>、<code>apply</code>或<code>bind</code>方法调用父类构造函数，将父类的属性和方法复制到子类实例上。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-javascript\">function Parent() {\n    this.name = 'parent';\n}\nfunction Child() {\n    Parent.call(this);\n    this.childName = 'child';\n}\n\nconst child = new Child();\nconsole.log(child.name); \n</code></pre>\n<ul>\n  <li><strong>缺点</strong>：只能继承父类的实例属性和方法，不能继承父类原型上的属性和方法；每个子类实例都会复制一份父类的属性和方法，造成内存浪费。</li>\n</ul>\n<h4>（3）组合继承</h4>\n<ul>\n  <li><strong>原理</strong>：结合了原型链继承和构造函数继承的优点。通过原型链继承父类的原型属性和方法，通过构造函数继承父类的实例属性和方法。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-javascript\">function Parent() {\n    this.name = 'parent';\n}\nParent.prototype.sayName = function() {\n    console.log(this.name);\n};\n\nfunction Child() {\n    Parent.call(this);\n    this.childName = 'child';\n}\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nconst child = new Child();\nchild.sayName(); \n</code></pre>\n<ul>\n  <li><strong>缺点</strong>：会调用两次父类构造函数，一次是在创建子类原型时，一次是在子类构造函数中。</li>\n</ul>\n<h4>（4）寄生组合继承</h4>\n<ul>\n  <li><strong>原理</strong>：在组合继承的基础上进行优化，通过创建一个空对象，将其原型指向父类的原型，然后将子类的原型指向这个空对象，避免了两次调用父类构造函数。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-javascript\">function Parent() {\n    this.name = 'parent';\n}\nParent.prototype.sayName = function() {\n    console.log(this.name);\n};\n\nfunction Child() {\n    Parent.call(this);\n    this.childName = 'child';\n}\nfunction createPrototype(proto) {\n    function F() {}\n    F.prototype = proto;\n    return new F();\n}\nChild.prototype = createPrototype(Parent.prototype);\nChild.prototype.constructor = Child;\n\nconst child = new Child();\nchild.sayName(); \n</code></pre>\n<h4>（5）ES6类继承</h4>\n<ul>\n  <li><strong>原理</strong>：ES6引入了<code>class</code>和<code>extends</code>关键字，实现了更简洁的继承语法。本质上还是基于原型链和构造函数的原理，使用<code>extends</code>关键字让子类继承父类的属性和方法，使用<code>super</code>关键字调用父类的构造函数。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-javascript\">class Parent {\n    constructor() {\n        this.name = 'parent';\n    }\n    sayName() {\n        console.log(this.name);\n    }\n}\nclass Child extends Parent {\n    constructor() {\n        super();\n        this.childName = 'child';\n    }\n}\nconst child = new Child();\nchild.sayName(); \n</code></pre>\n<h3>4. 常见误区</h3>\n<h4>（1）混淆不同继承方式的优缺点</h4>\n<ul>\n  <li>误区：不能准确区分各种继承方式的优缺点，在实际应用中选择不恰当的继承方式。</li>\n  <li>纠正：理解每种继承方式的原理，明确其适用场景和局限性。</li>\n</ul>\n<h4>（2）对原型链理解不深入</h4>\n<ul>\n  <li>误区：不清楚原型链的查找机制，导致对继承的实现原理理解困难。</li>\n  <li>纠正：深入学习原型和原型链的概念，通过调试和示例代码加深理解。</li>\n</ul>\n<h4>（3）忽略ES6类继承的本质</h4>\n<ul>\n  <li>误区：认为ES6的<code>class</code>和<code>extends</code>是全新的继承机制，与传统的原型链和构造函数无关。</li>\n  <li>纠正：了解ES6类继承是基于原型链和构造函数的语法糖，本质上还是使用了相同的原理。</li>\n</ul>\n<h3>5. 总结回答</h3>\n<p>JavaScript继承的原理基于原型、原型链和构造函数等概念。常见的继承方式有原型链继承、构造函数继承、组合继承、寄生组合继承和ES6类继承。</p>\n<p>原型链继承通过让子类的原型指向父类的实例，使子类实例可以通过原型链访问父类的属性和方法，但存在共享引用类型属性和无法传递参数的问题。</p>\n<p>构造函数继承在子类构造函数中调用父类构造函数，将父类的属性和方法复制到子类实例上，但不能继承父类原型上的属性和方法。</p>\n<p>组合继承结合了原型链继承和构造函数继承的优点，但会调用两次父类构造函数。</p>\n<p>寄生组合继承在组合继承的基础上进行优化，避免了两次调用父类构造函数。</p>\n<p>ES6类继承使用<code>class</code>和<code>extends</code>关键字，本质上还是基于原型链和构造函数的原理，使用<code>super</code>关键字调用父类的构造函数。</p>",
    "more_ask": "<ol>\n  <li><strong>不同继承方式的性能对比</strong>：提示：从内存占用、创建对象的时间开销等方面去考虑，比如比较原型链继承和组合继承。</li>\n  <li><strong>如何实现多重继承</strong>：提示：JavaScript本身不支持多重继承，但可以通过一些技巧模拟，思考如何结合不同继承方式来实现。</li>\n  <li><strong>继承中构造函数的执行顺序</strong>：提示：当使用组合继承等多种方式结合时，构造函数的调用顺序会影响对象的属性和方法初始化。</li>\n  <li><strong>在继承中如何处理静态属性和方法</strong>：提示：静态属性和方法是属于类而不是实例的，思考在继承过程中它们的传递和使用。</li>\n  <li><strong>继承对原型链的影响</strong>：提示：继承会改变原型链的结构，考虑不同继承方式下原型链的变化以及对属性查找的影响。</li>\n  <li><strong>如何避免继承中的原型污染</strong>：提示：原型污染可能会导致意外的行为，思考在继承过程中如何防止对原型的错误修改。</li>\n  <li><strong>ES6类继承和传统继承方式的区别</strong>：提示：ES6引入了类的概念，对比它的继承和传统的原型链、构造函数等继承方式的不同。</li>\n  <li><strong>在继承中如何重写父类方法</strong>：提示：重写方法时要考虑如何在子类中覆盖父类的方法，同时可能还需要调用父类的原方法。</li>\n</ol>",
    "mindmap": "mindmap\n  root((JavaScript继承))\n    核心目的\n      使用其他对象属性和方法\n    实现原理\n      原型链继承\n        基于[[Prototype]]属性查找\n      构造函数继承\n        用call、apply、bind调用父类构造函数\n      组合继承\n        结合原型链和构造函数继承优点\n      寄生组合继承\n        优化组合继承，避免两次调用父类构造函数\n      class继承（ES6）\n        用class和extends关键字，底层基于原型链和构造函数继承",
    "keynote": "核心目的：让对象使用其他对象属性和方法\n实现原理：\n- 原型链继承：基于 `[[Prototype]]` 属性查找\n- 构造函数继承：用 `call`、`apply`、`bind` 调用父类构造函数\n- 组合继承：结合原型链和构造函数继承优点\n- 寄生组合继承：优化组合继承，避免两次调用父类构造函数\n- class 继承（ES6）：用 `class` 和 `extends` 关键字，底层基于原型链和构造函数继承",
    "group_id": 24,
    "kps": [
      "原型和继承"
    ],
    "years": [
      2024,
      2023,
      2022
    ],
    "corps": [
      "吉比特",
      "字节飞书",
      "美团优选",
      "华为OD",
      "瑞幸",
      "顺丰",
      "淘天集团",
      "即时设计",
      "腾讯",
      "小鹅通",
      "字节跳动",
      "腾讯云智",
      "阿里瓴羊",
      "Shopee虾皮",
      "滴滴",
      "深信服",
      "携程",
      "蚂蚁集团",
      "360",
      "猿辅导",
      "用友",
      "腾讯音乐",
      "小红书",
      "去哪儿旅行",
      "4399",
      "旷视科技",
      "神策数据",
      "饿了么",
      "大智慧",
      "掌阅科技",
      "腾讯互娱",
      "美团",
      "阿里大文娱",
      "百度",
      "华为",
      "京东",
      "网易",
      "快手",
      "讯飞教育",
      "联想集团",
      "度小满",
      "美团到家",
      "OPPO"
    ]
  }
}