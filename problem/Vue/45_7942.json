{
  "success": true,
  "data": {
    "id": 7942,
    "name": "<p>Computed 和 Watch 的区别</p>",
    "options": null,
    "answer": "<p>在 Vue 中，<code>computed</code> 和 <code>watch</code> 都是用于监听数据变化的功能，但它们的使用场景和实现方式有所不同。以下是它们之间的主要区别：</p>\n<h3>Computed</h3>\n<ol>\n  <li>\n    <p><strong>目的</strong>：<code>computed</code> 属性主要用于计算和派生数据。它们通常用于依赖其他数据的计算值。</p>\n  </li>\n  <li>\n    <p><strong>缓存</strong>：<code>computed</code> 属性是基于其依赖进行缓存的。只有当依赖的数据发生变化时，<code>computed</code> 属性才会重新计算。因此，它们在性能上更为高效。</p>\n  </li>\n  <li>\n    <p><strong>使用方法</strong>：</p>\n    <pre><code class=\"language-javascript\">computed: {\n  computedProperty() {\n    return this.someData * 2; // 计算属性\n  }\n}\n</code></pre>\n  </li>\n  <li>\n    <p><strong>响应性</strong>：当其依赖的响应式数据发生变化时，<code>computed</code> 属性会自动更新。</p>\n  </li>\n</ol>\n<h3>Watch</h3>\n<ol>\n  <li>\n    <p><strong>目的</strong>：<code>watch</code> 主要用于观察数据的变化并执行某些操作，例如异步请求、复杂逻辑处理或手动操作。</p>\n  </li>\n  <li>\n    <p><strong>不缓存</strong>：<code>watch</code> 不会进行缓存，每当被观察的数据变化时，都会触发相应的处理操作。</p>\n  </li>\n  <li>\n    <p><strong>使用方法</strong>：</p>\n    <pre><code class=\"language-javascript\">watch: {\n  someData(newVal, oldVal) {\n    console.log('someData发生变化了', newVal, oldVal);\n    // 执行某些操作\n  }\n}\n</code></pre>\n  </li>\n  <li>\n    <p><strong>适用场景</strong>：适合需要在数据变化时执行异步操作或是复杂逻辑的场景。</p>\n  </li>\n</ol>\n<h3>总结</h3>\n<ul>\n  <li>使用 <code>computed</code> 来处理依赖其他数据的计算，享受缓存的优势。</li>\n  <li>使用 <code>watch</code> 来监视数据变化并执行特定的逻辑或异步操作。</li>\n</ul>\n<p>根据你的需求选择合适的工具可以让你的 Vue 应用更高效和清晰。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.04474143,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Vue中Computed和Watch的区别。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Computed和Watch基本概念的理解。</li>\n      <li>两者在使用场景、实现原理、性能表现等方面的差异。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Computed</h4>\n<ul>\n  <li>计算属性，用于处理一些需要经过计算才能得到的值。它基于响应式依赖进行缓存，只有当依赖的数据发生变化时，才会重新计算。</li>\n</ul>\n<h4>（2）Watch</h4>\n<ul>\n  <li>侦听器，用于观察一个响应式数据的变化，并在数据变化时执行相应的回调函数。可以监听单个或多个数据的变化，适合处理异步操作或复杂的逻辑。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）定义和语法差异</h4>\n<ul>\n  <li><strong>Computed</strong>：通过在Vue实例的<code>computed</code>选项中定义，它是一个对象，每个属性都是一个计算属性，属性可以是一个函数，也可以是一个包含<code>get</code>和<code>set</code>方法的对象。</li>\n</ul>\n<pre><code class=\"language-vue\">&#x3C;template>\n  &#x3C;div>{{ fullName }}&#x3C;/div>\n&#x3C;/template>\n\n&#x3C;script>\nexport default {\n  data() {\n    return {\n      firstName: 'John',\n      lastName: 'Doe'\n    };\n  },\n  computed: {\n    fullName() {\n      return this.firstName + ' ' + this.lastName;\n    }\n  }\n};\n&#x3C;/script>\n</code></pre>\n<ul>\n  <li><strong>Watch</strong>：通过在Vue实例的<code>watch</code>选项中定义，它也是一个对象，每个属性对应一个要监听的数据，属性值是一个回调函数，当监听的数据发生变化时，回调函数会被调用。</li>\n</ul>\n<pre><code class=\"language-vue\">&#x3C;template>\n  &#x3C;div>{{ message }}&#x3C;/div>\n&#x3C;/template>\n\n&#x3C;script>\nexport default {\n  data() {\n    return {\n      message: 'Hello',\n      newMessage: 'World'\n    };\n  },\n  watch: {\n    message(newVal, oldVal) {\n      console.log(`Message changed from ${oldVal} to ${newVal}`);\n    }\n  }\n};\n&#x3C;/script>\n</code></pre>\n<h4>（2）使用场景差异</h4>\n<ul>\n  <li><strong>Computed</strong>：适用于需要根据已有数据计算出新值的场景，如数据的格式化、拼接等。计算属性具有缓存特性，只要依赖的数据不变，多次访问计算属性时不会重新计算，提高了性能。</li>\n  <li><strong>Watch</strong>：适用于需要在数据变化时执行异步操作或复杂逻辑的场景，如发送网络请求、修改DOM等。</li>\n</ul>\n<h4>（3）实现原理差异</h4>\n<ul>\n  <li><strong>Computed</strong>：依赖于Vue的响应式系统，通过<code>Object.defineProperty()</code>劫持数据的<code>getter</code>和<code>setter</code>，当依赖的数据发生变化时，会触发计算属性的重新计算。</li>\n  <li><strong>Watch</strong>：通过<code>Object.defineProperty()</code>监听数据的变化，当数据变化时，会调用相应的回调函数。</li>\n</ul>\n<h4>（4）性能差异</h4>\n<ul>\n  <li><strong>Computed</strong>：由于具有缓存特性，在依赖数据不变的情况下，多次访问计算属性不会重新计算，性能较好。</li>\n  <li><strong>Watch</strong>：每次数据变化都会触发回调函数，如果回调函数执行的操作比较复杂，可能会影响性能。</li>\n</ul>\n<h3>4. 常见误区</h3>\n<h4>（1）混淆使用场景</h4>\n<ul>\n  <li>误区：在适合使用计算属性的场景中使用了监听器，或者在适合使用监听器的场景中使用了计算属性。</li>\n  <li>纠正：根据具体的需求选择合适的方式，需要计算新值时优先使用计算属性，需要处理异步操作或复杂逻辑时使用监听器。</li>\n</ul>\n<h4>（2）忽略计算属性的缓存特性</h4>\n<ul>\n  <li>误区：认为计算属性每次访问都会重新计算。</li>\n  <li>纠正：计算属性只有在依赖的数据发生变化时才会重新计算，多次访问相同的计算属性会直接返回缓存的值。</li>\n</ul>\n<h4>（3）在监听器中进行复杂同步计算</h4>\n<ul>\n  <li>误区：在监听器中进行复杂的同步计算，而不是使用计算属性。</li>\n  <li>纠正：复杂的同步计算应该使用计算属性，监听器更适合处理异步操作。</li>\n</ul>\n<h3>5. 总结回答</h3>\n<p>在Vue中，Computed和Watch有以下区别：</p>\n<ul>\n  <li><strong>定义和语法</strong>：Computed在<code>computed</code>选项中定义，可通过函数或包含<code>get</code>、<code>set</code>方法的对象来实现；Watch在<code>watch</code>选项中定义，每个属性对应一个要监听的数据，属性值是回调函数。</li>\n  <li><strong>使用场景</strong>：Computed适用于根据已有数据计算新值的场景，有缓存特性；Watch适用于数据变化时执行异步操作或复杂逻辑的场景。</li>\n  <li><strong>实现原理</strong>：Computed依赖响应式系统，通过劫持<code>getter</code>和<code>setter</code>实现；Watch通过监听数据变化调用回调函数。</li>\n  <li><strong>性能</strong>：Computed缓存特性使其性能较好，多次访问依赖未变的计算属性不会重新计算；Watch每次数据变化都触发回调，复杂操作可能影响性能。</li>\n</ul>\n<p>使用时要根据具体需求合理选择，避免混淆使用场景、忽略计算属性缓存特性等误区。</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>你能举例说明在什么情况下应优先使用computed而非watch吗？</strong></p>\n    <ul>\n      <li>提示：想想性能和可读性方面的考量。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如果computed属性依赖的data发生变化时，computed是如何更新的？</strong></p>\n    <ul>\n      <li>提示：考虑Vue响应式系统的工作原理。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>能否在computed属性中执行异步操作？为什么？</strong></p>\n    <ul>\n      <li>提示：思考computed的设计目的和预期的行为。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>Watch可以应用于哪些类型的数据变化？能否观察到数组及对象的变化？</strong></p>\n    <ul>\n      <li>提示：考虑Vue如何处理深层数据结构。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你与团队是如何决定使用computed还是watch的原则？</strong></p>\n    <ul>\n      <li>提示：讨论团队规范或共同理解的重要性。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何使用watch监听多个数据源的变化？</strong></p>\n    <ul>\n      <li>提示：想想watch的第二个参数和处理逻辑。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在Vue 3中，computed和watch的API有什么变化？</strong></p>\n    <ul>\n      <li>提示：了解Vue 3的新特性。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你会在watch中如何处理复杂的逻辑或数据变化？</strong></p>\n    <ul>\n      <li>提示：思考防抖、节流等常见技巧。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>解释一下Vue的响应式原理，以及它如何支持computed和watch的工作。</strong></p>\n    <ul>\n      <li>提示：聚焦于Object.defineProperty或Proxy。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在Vue应用中，你是如何测试computed和watch功能的？</strong></p>\n    <ul>\n      <li>提示：考虑单元测试和集成测试的方法。</li>\n    </ul>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  Vue监听数据变化\n    Computed\n      目的\n      缓存\n      响应性\n    Watch\n      目的\n      不缓存\n      适用场景",
    "keynote": "- Computed属性主要用于计算和派生数据。\n- Computed基于其依赖进行缓存，只有当依赖的数据发生变化时才会重新计算。\n- Computed属性在其依赖的响应式数据发生变化时会自动更新。\n- Watch用于观察数据的变化并执行某些操作，如异步请求或复杂逻辑处理。\n- Watch不会进行缓存，每次被观察的数据变化都会触发相应操作。\n- 使用Computed享受缓存优势处理依赖其他数据的计算。\n- 使用Watch监视数据变化以执行特定逻辑或异步操作。",
    "group_id": 45,
    "kps": [
      "基础"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "趣链科技",
      "中国科学院空天信息创新研究院",
      "北京某小厂",
      "hooli",
      "西安中科天塔科技股份有限公司",
      "卓望",
      "慧点科技",
      "瑞幸",
      "58同城",
      "京东",
      "卡伦特厦门分部",
      "快手",
      "腾讯PCG",
      "比心",
      "小米",
      "滴滴",
      "深信服",
      "顺丰",
      "360",
      "B站",
      "网易",
      "奇安信",
      "用友",
      "小红书",
      "爱奇艺",
      "4399",
      "网易有道",
      "欢聚集团",
      "平安科技",
      "酷家乐",
      "格力",
      "旷视科技",
      "吉比特",
      "浩鲸科技",
      "七牛云",
      "Momenta",
      "乐刻",
      "中国工商银行",
      "字节跳动",
      "腾讯",
      "美团",
      "百度",
      "联想集团",
      "完美世界",
      "满帮集团",
      "海康威视"
    ]
  }
}