{"success":true,"data":{"id":4769,"name":"<p>简述Vue 的⽗组件和⼦组件⽣命周期钩⼦执⾏顺序是什么 ？</p>","options":null,"answer":"<h4>Vue 父子组件生命周期钩子执行顺序（以挂载阶段为例）</h4>\n<ol>\n  <li>\n    <p><strong>父组件创建阶段</strong></p>\n    <ul>\n      <li><code>beforeCreate</code>：父组件初始化，数据未初始化。</li>\n      <li><code>created</code>：父组件实例创建完成，数据可用，但未开始渲染 DOM。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>子组件创建阶段</strong></p>\n    <ul>\n      <li><code>beforeCreate</code>：子组件初始化，数据未初始化。</li>\n      <li><code>created</code>：子组件实例创建完成，数据可用，但未开始渲染 DOM。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>父组件挂载前阶段</strong></p>\n    <ul>\n      <li><code>beforeMount</code>：父组件即将开始挂载（此时会触发子组件的渲染）。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>子组件挂载阶段</strong></p>\n    <ul>\n      <li><code>beforeMount</code>：子组件即将挂载（在父组件 <code>beforeMount</code> 之后执行）。</li>\n      <li><code>mounted</code>：子组件挂载完成（DOM 渲染完毕）。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>父组件挂载完成阶段</strong></p>\n    <ul>\n      <li><code>mounted</code>：父组件挂载完成（在所有子组件 <code>mounted</code> 之后执行）。</li>\n    </ul>\n  </li>\n</ol>\n<h4>完整执行顺序总结（以挂载为例）</h4>\n<pre><code>父 beforeCreate → 父 created → 父 beforeMount  \n↓（触发子组件渲染）  \n→ 子 beforeCreate → 子 created → 子 beforeMount → 子 mounted  \n↓（所有子组件挂载完成）  \n→ 父 mounted  \n</code></pre>\n<h3>扩展说明</h3>\n<ul>\n  <li><strong>更新阶段</strong>（如数据变化触发重新渲染）：<br><code>父 beforeUpdate → 子 beforeUpdate → 子 updated → 父 updated</code>。</li>\n  <li><strong>卸载阶段</strong>（如 <code>v-if</code> 控制组件销毁）：<br><code>父 beforeUnmount → 子 beforeUnmount → 子 unmounted → 父 unmounted</code>。</li>\n  <li><strong>关键原则</strong>：\n    <ul>\n      <li><strong>创建阶段</strong>：父组件先于子组件执行 <code>beforeCreate</code> 和 <code>created</code>。</li>\n      <li><strong>挂载阶段</strong>：父组件先进入 <code>beforeMount</code>，但 <code>mounted</code> 需等待所有子组件挂载完成。</li>\n      <li><strong>更新/卸载阶段</strong>：父组件先触发更新/卸载钩子，子组件执行完毕后，父组件才会最终完成。</li>\n    </ul>\n  </li>\n</ul>\n<p>理解生命周期顺序有助于调试组件渲染逻辑，例如在 <code>mounted</code> 中获取 DOM 时，需注意父组件的 <code>mounted</code> 中可访问子组件的 DOM，而子组件的 <code>mounted</code> 中只能访问自身 DOM。</p>","type":6,"level":2,"freq":0.001743173,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：简述Vue的父组件和子组件生命周期钩子执行顺序。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Vue生命周期钩子的理解。</li>\n      <li>父子组件嵌套时生命周期钩子的执行顺序。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Vue生命周期钩子</h4>\n<p>Vue实例从创建到销毁会经历一系列过程，期间有多个钩子函数可供开发者在特定阶段执行自定义逻辑，如<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code>、<code>beforeUpdate</code>、<code>updated</code>、<code>beforeDestroy</code>、<code>destroyed</code>等。</p>\n<h4>（2）父子组件关系</h4>\n<p>在Vue应用中，组件可以嵌套使用，父组件可以包含子组件，父组件创建和渲染时会触发子组件的创建和渲染。</p>\n<h3>3. 解析</h3>\n<h4>（1）挂载阶段</h4>\n<p>当创建并挂载包含子组件的父组件时，执行顺序是：</p>\n<ul>\n  <li>父组件<code>beforeCreate</code></li>\n  <li>父组件<code>created</code></li>\n  <li>父组件<code>beforeMount</code></li>\n  <li>子组件<code>beforeCreate</code></li>\n  <li>子组件<code>created</code></li>\n  <li>子组件<code>beforeMount</code></li>\n  <li>子组件<code>mounted</code></li>\n  <li>父组件<code>mounted</code></li>\n</ul>\n<p>原因是父组件在挂载前会先创建子组件实例，当子组件完成挂载后，父组件才会完成挂载。</p>\n<h4>（2）更新阶段</h4>\n<p>当父组件数据更新触发重新渲染时，执行顺序是：</p>\n<ul>\n  <li>父组件<code>beforeUpdate</code></li>\n  <li>子组件<code>beforeUpdate</code></li>\n  <li>子组件<code>updated</code></li>\n  <li>父组件<code>updated</code></li>\n</ul>\n<p>这是因为父组件数据更新会先通知子组件进行更新，子组件更新完成后，父组件再完成更新。</p>\n<h4>（3）销毁阶段</h4>\n<p>当销毁包含子组件的父组件时，执行顺序是：</p>\n<ul>\n  <li>父组件<code>beforeDestroy</code></li>\n  <li>子组件<code>beforeDestroy</code></li>\n  <li>子组件<code>destroyed</code></li>\n  <li>父组件<code>destroyed</code></li>\n</ul>\n<p>父组件在销毁前会先销毁子组件，确保子组件资源先被释放。</p>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-vue\">&#x3C;template>\n  &#x3C;div>\n    &#x3C;child-component>&#x3C;/child-component>\n  &#x3C;/div>\n&#x3C;/template>\n\n&#x3C;script>\nimport ChildComponent from './ChildComponent.vue';\n\nexport default {\n  components: {\n    ChildComponent\n  },\n  beforeCreate() {\n    console.log('父组件 beforeCreate');\n  },\n  created() {\n    console.log('父组件 created');\n  },\n  beforeMount() {\n    console.log('父组件 beforeMount');\n  },\n  mounted() {\n    console.log('父组件 mounted');\n  },\n  beforeUpdate() {\n    console.log('父组件 beforeUpdate');\n  },\n  updated() {\n    console.log('父组件 updated');\n  },\n  beforeDestroy() {\n    console.log('父组件 beforeDestroy');\n  },\n  destroyed() {\n    console.log('父组件 destroyed');\n  }\n};\n&#x3C;/script>\n</code></pre>\n<pre><code class=\"language-vue\">&#x3C;template>\n  &#x3C;div>子组件内容&#x3C;/div>\n&#x3C;/template>\n\n&#x3C;script>\nexport default {\n  beforeCreate() {\n    console.log('子组件 beforeCreate');\n  },\n  created() {\n    console.log('子组件 created');\n  },\n  beforeMount() {\n    console.log('子组件 beforeMount');\n  },\n  mounted() {\n    console.log('子组件 mounted');\n  },\n  beforeUpdate() {\n    console.log('子组件 beforeUpdate');\n  },\n  updated() {\n    console.log('子组件 updated');\n  },\n  beforeDestroy() {\n    console.log('子组件 beforeDestroy');\n  },\n  destroyed() {\n    console.log('子组件 destroyed');\n  }\n};\n&#x3C;/script>\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）认为父子组件生命周期钩子独立执行</h4>\n<p>\n  误区：以为父子组件的生命周期钩子是各自独立执行，不考虑嵌套关系。\n  纠正：要理解父子组件嵌套时，父组件创建和更新会触发子组件相应的生命周期，销毁时也有先后顺序。\n</p>\n<h4>（2）混淆各阶段执行顺序</h4>\n<p>\n  误区：记不清挂载、更新、销毁阶段父子组件生命周期钩子的具体执行顺序。\n  纠正：通过多实践和画图来加深对各阶段顺序的理解和记忆。\n</p>\n<h3>6. 总结回答</h3>\n<p>Vue父子组件生命周期钩子执行顺序如下：</p>\n<ul>\n  <li><strong>挂载阶段</strong>：父组件<code>beforeCreate</code> -> 父组件<code>created</code> -> 父组件<code>beforeMount</code> -> 子组件<code>beforeCreate</code> -> 子组件<code>created</code> -> 子组件<code>beforeMount</code> -> 子组件<code>mounted</code> -> 父组件<code>mounted</code>。</li>\n  <li><strong>更新阶段</strong>：父组件<code>beforeUpdate</code> -> 子组件<code>beforeUpdate</code> -> 子组件<code>updated</code> -> 父组件<code>updated</code>。</li>\n  <li><strong>销毁阶段</strong>：父组件<code>beforeDestroy</code> -> 子组件<code>beforeDestroy</code> -> 子组件<code>destroyed</code> -> 父组件<code>destroyed</code>。</li>\n</ul>\n<p>理解这些顺序有助于开发者在合适的生命周期钩子中编写逻辑，确保组件的正确运行。</p>","more_ask":"<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>描述 Vue 组件的生命周期钩子有哪些？</strong><br>提示：可以分为创建、挂载、更新和销毁阶段的钩子。</p>\n  </li>\n  <li>\n    <p><strong>父组件在子组件的生命周期中可以做哪些操作？</strong><br>提示：关注数据传递、事件监听和对子组件状态的管理。</p>\n  </li>\n  <li>\n    <p><strong>在生命周期的哪个阶段可以获取 DOM 元素？为什么？</strong><br>提示：讨论 <code>mounted</code> 钩子和它的作用。</p>\n  </li>\n  <li>\n    <p><strong>如何在子组件中调用父组件的方法？</strong><br>提示：考虑使用 <code>$emit</code> 事件机制的方式。</p>\n  </li>\n  <li>\n    <p><strong>如果父组件更新了状态，子组件生命周期会如何影响？</strong><br>提示：讨论 <code>props</code> 更新后的组件重新渲染情况。</p>\n  </li>\n  <li>\n    <p><strong>描述一个特定的场景，在生命周期中可能会遇到的问题或性能考虑。</strong><br>提示：可以提到频繁的数据更新如何影响渲染性能。</p>\n  </li>\n  <li>\n    <p><strong>你如何处理组件的被销毁时的清理工作？</strong><br>提示：关注 <code>beforeDestroy</code> 和 <code>destroyed</code> 钩子。</p>\n  </li>\n  <li>\n    <p><strong>怎样实现组件的复用，提高项目的可维护性？</strong><br>提示：讨论高阶组件、插槽或 mixins 的使用。</p>\n  </li>\n  <li>\n    <p><strong>在 Vue 3 中，生命周期钩子有什么变化？</strong><br>提示：提及组合式 API 和不同的生命周期语法。</p>\n  </li>\n  <li>\n    <p><strong>如何在 React 中处理组件生命周期与 Vue 的生命周期对比？</strong><br>提示：关注组件的创建、更新和销毁阶段的差异和相似点。</p>\n  </li>\n</ol>","mindmap":"mindmap\n  root((Vue父子组件生命周期))\n    创建阶段\n      父组件\n        beforeCreate\n        created\n      子组件\n        beforeCreate\n        created\n    挂载阶段\n      父组件\n        beforeMount\n      子组件\n        beforeMount\n        mounted\n      父组件\n        mounted\n    更新阶段\n      父组件\n        beforeUpdate\n      子组件\n        beforeUpdate\n        updated\n      父组件\n        updated\n    卸载阶段\n      父组件\n        beforeUnmount\n      子组件\n        beforeUnmount\n        unmounted\n      父组件\n        unmounted\n    关键原则\n      创建阶段: 父→子\n      挂载阶段: 父开始→子完成→父完成\n      更新/卸载: 父开始→子完成→父完成","keynote":"**创建阶段**\n- 父 beforeCreate → 父 created\n- 子 beforeCreate → 子 created\n\n**挂载阶段**\n- 父 beforeMount\n- 子 beforeMount → 子 mounted\n- 父 mounted\n\n**更新阶段**\n- 父 beforeUpdate\n- 子 beforeUpdate → 子 updated\n- 父 updated\n\n**卸载阶段**\n- 父 beforeUnmount\n- 子 beforeUnmount → 子 unmounted\n- 父 unmounted\n\n**核心原则**\n1. 创建：父先子后\n2. 挂载：父开始→子完成→父完成\n3. 更新/卸载：父开始→子完成→父完成\n4. mounted时：父可访问子DOM，子只能访问自身DOM","group_id":45,"kps":["基础"],"years":[2024,2023],"corps":["泰豪软件","美团","京东"]}}