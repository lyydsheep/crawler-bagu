{
  "success": true,
  "data": {
    "id": 7976,
    "name": "<p>说一下Vue的生命周期</p>",
    "options": null,
    "answer": "<p>Vue 的生命周期是指 Vue 实例从创建、更新直到销毁的过程，也可以理解为 Vue 组件在整个存在过程中所经历的各种状态。Vue 提供了一系列的生命周期钩子函数，开发者可以在这些钩子中添加自己的代码，以便于在不同的阶段执行特定的操作。</p>\n<p>以下是 Vue 生命周期的主要阶段和钩子：</p>\n<h3>1. 创建阶段</h3>\n<ul>\n  <li><strong>beforeCreate</strong>: 实例刚被初始化，数据观测和事件/观察者配置尚未开始。</li>\n  <li><strong>created</strong>: 实例被创建完成，数据观测和事件/观察者配置已经完成，但 DOM 还未生成。可以在这里获取数据或发起请求。</li>\n</ul>\n<h3>2. 挂载阶段</h3>\n<ul>\n  <li><strong>beforeMount</strong>: 在挂载开始之前被调用，此时模板已编译为虚拟 DOM。</li>\n  <li><strong>mounted</strong>: 挂载完成后被调用，此时可以访问真正的 DOM。在这里你可以执行与 DOM 相关的操作，例如获取元素的尺寸、位置等。</li>\n</ul>\n<h3>3. 更新阶段</h3>\n<ul>\n  <li><strong>beforeUpdate</strong>: 数据变化后，虚拟 DOM 重新渲染之前被调用。可以在这里进行一些操作，影响下一个 DOM 更新。</li>\n  <li><strong>updated</strong>: 由于数据变化导致虚拟 DOM 重新渲染和更新后被调用。</li>\n</ul>\n<h3>4. 销毁阶段</h3>\n<ul>\n  <li><strong>beforeDestroy</strong>: 实例销毁之前调用。在这一步，实例仍然是完全可用的，可以清理定时器、取消网络请求等。</li>\n  <li><strong>destroyed</strong>: 实例销毁后被调用，组件的所有事件监听器及子实例都已被移除，不能再使用实例上的数据和方法。</li>\n</ul>\n<h3>生命周期图示</h3>\n<p>通常可用以下简化的流程图展示 Vue 的生命周期：</p>\n<pre><code>beforeCreate → created → beforeMount → mounted\n                               ↑        ↓\n                  beforeUpdate ← updated\n                               ↓\n                         beforeDestroy → destroyed\n</code></pre>\n<h3>其他生命周期相关</h3>\n<ul>\n  <li><strong>activated</strong>: 适用于 <code>&#x3C;keep-alive></code> 组件，组件激活时调用。</li>\n  <li><strong>deactivated</strong>: 适用于 <code>&#x3C;keep-alive></code> 组件，组件停用时调用。</li>\n</ul>\n<h3>使用示例</h3>\n<p>以下是一个简单的示例，展示如何在生命周期钩子中使用代码：</p>\n<pre><code class=\"language-javascript\">new Vue({\n  data() {\n    return {\n      message: 'Hello Vue!'\n    };\n  },\n  created() {\n    console.log('Component is created!');\n  },\n  mounted() {\n    console.log('Component is mounted!');\n  },\n  updated() {\n    console.log('Component has been updated!');\n  },\n  beforeDestroy() {\n    console.log('Component is about to be destroyed!');\n  }\n});\n</code></pre>\n<p>通过理解和利用这些生命周期钩子，可以更好地管理 Vue 组件的状态和行为。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.1226031,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：阐述Vue的生命周期。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Vue实例从创建到销毁整个过程各阶段的了解。</li>\n      <li>各生命周期钩子函数的作用和执行时机。</li>\n      <li>能够结合实际开发说明各阶段的应用场景。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<p>Vue的生命周期指的是Vue实例从创建、挂载、更新、销毁等一系列过程。在这个过程中，Vue提供了多个生命周期钩子函数，开发者可以在特定阶段执行自定义代码。</p>\n<h3>3. 解析</h3>\n<h4>（1）创建阶段</h4>\n<ul>\n  <li><code>beforeCreate</code>：在实例初始化之后，数据观测 <code>data observer</code> 和 <code>event/watcher</code> 事件配置之前被调用。此时，实例的 <code>data</code> 和 <code>methods</code> 等属性还未初始化，无法访问。</li>\n  <li><code>created</code>：实例已经创建完成之后被调用。在这一步，实例已经完成了数据观测 <code>data observer</code>、<code>property</code> 和 <code>method</code> 的计算、<code>watch/event</code> 事件回调。然而，挂载阶段还没有开始，<code>$el</code> 属性目前不可用。此阶段适合进行数据的初始化，如发起网络请求获取初始数据。</li>\n</ul>\n<h4>（2）挂载阶段</h4>\n<ul>\n  <li><code>beforeMount</code>：在挂载开始之前被调用，此时模板编译已经完成，但还未将编译好的HTML挂载到页面上。<code>$el</code> 已经存在，但内容是模板字符串。</li>\n  <li><code>mounted</code>：在挂载完成后调用，此时模板已经编译完成并挂载到页面上，<code>$el</code> 已经替换为实际的DOM元素。此阶段适合进行DOM操作，如初始化第三方插件。</li>\n</ul>\n<h4>（3）更新阶段</h4>\n<ul>\n  <li><code>beforeUpdate</code>：在数据更新之前被调用，发生在虚拟DOM打补丁之前。此时数据已经发生变化，但DOM还未更新。</li>\n  <li><code>updated</code>：在数据更新之后被调用，发生在虚拟DOM重新渲染和打补丁之后。此时数据和DOM都已经更新。需要注意的是，在 <code>updated</code> 钩子函数中不要直接修改数据，否则可能会导致无限循环更新。</li>\n</ul>\n<h4>（4）销毁阶段</h4>\n<ul>\n  <li><code>beforeDestroy</code>：在实例销毁之前调用。此时实例仍然完全可用，数据、方法、指令等都还能正常使用。此阶段适合做一些清理工作，如清除定时器、取消网络请求等。</li>\n  <li><code>destroyed</code>：在实例销毁之后调用。此时所有的事件监听器和子实例都已经被销毁，实例已经完全不可用。</li>\n</ul>\n<h4>（5）激活阶段（仅适用于 <code>&#x3C;keep-alive></code> 包裹的组件）</h4>\n<ul>\n  <li><code>activated</code>：当 <code>&#x3C;keep-alive></code> 包裹的组件被激活时调用。</li>\n  <li><code>deactivated</code>：当 <code>&#x3C;keep-alive></code> 包裹的组件被停用时调用。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n\n&#x3C;head>\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &#x3C;title>Vue Lifecycle Example&#x3C;/title>\n  &#x3C;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\">&#x3C;/script>\n&#x3C;/head>\n\n&#x3C;body>\n  &#x3C;div id=\"app\">\n    {{ message }}\n  &#x3C;/div>\n  &#x3C;script>\n    new Vue({\n      el: '#app',\n      data: {\n        message: 'Hello, Vue!'\n      },\n      beforeCreate() {\n        console.log('beforeCreate: 实例初始化后，数据观测和 event/watcher 事件配置前');\n      },\n      created() {\n        console.log('created: 实例已创建完成，可访问数据和方法');\n      },\n      beforeMount() {\n        console.log('beforeMount: 挂载开始前，模板编译完成但未挂载');\n      },\n      mounted() {\n        console.log('mounted: 挂载完成，DOM 已更新');\n      },\n      beforeUpdate() {\n        console.log('beforeUpdate: 数据更新前，虚拟 DOM 打补丁前');\n      },\n      updated() {\n        console.log('updated: 数据更新后，虚拟 DOM 重新渲染和打补丁后');\n      },\n      beforeDestroy() {\n        console.log('beforeDestroy: 实例销毁前，实例仍可用');\n      },\n      destroyed() {\n        console.log('destroyed: 实例销毁后，所有事件监听器和子实例已销毁');\n      }\n    });\n  &#x3C;/script>\n&#x3C;/body>\n\n&#x3C;/html>\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆钩子函数执行顺序</h4>\n<ul>\n  <li>误区：不清楚各生命周期钩子函数的执行顺序，导致在错误的阶段执行代码。</li>\n  <li>纠正：牢记Vue生命周期各阶段的顺序，根据需求在合适的钩子函数中编写代码。</li>\n</ul>\n<h4>（2）在 <code>updated</code> 中修改数据</h4>\n<ul>\n  <li>误区：在 <code>updated</code> 钩子函数中直接修改数据，导致无限循环更新。</li>\n  <li>纠正：避免在 <code>updated</code> 中修改数据，如果需要修改数据，应在 <code>beforeUpdate</code> 或其他合适的阶段进行。</li>\n</ul>\n<h4>（3）忽略 <code>&#x3C;keep-alive></code> 相关钩子</h4>\n<ul>\n  <li>误区：在使用 <code>&#x3C;keep-alive></code> 包裹组件时，忽略 <code>activated</code> 和 <code>deactivated</code> 钩子函数。</li>\n  <li>纠正：了解 <code>&#x3C;keep-alive></code> 的作用和相关钩子函数，在组件激活和停用时执行相应的操作。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>\n  Vue的生命周期包含多个阶段，每个阶段都有对应的钩子函数，开发者可以在这些钩子函数中执行自定义代码。\n  创建阶段有 <code>beforeCreate</code> 和 <code>created</code>，前者在实例初始化后、数据观测和事件配置前调用，后者在实例创建完成后调用，可进行数据初始化。\n  挂载阶段有 <code>beforeMount</code> 和 <code>mounted</code>，分别在挂载开始前和挂载完成后调用，<code>mounted</code> 可进行DOM操作。\n  更新阶段有 <code>beforeUpdate</code> 和 <code>updated</code>，在数据更新前后调用。\n  销毁阶段有 <code>beforeDestroy</code> 和 <code>destroyed</code>，分别在实例销毁前后调用，<code>beforeDestroy</code> 可做清理工作。\n  对于 <code>&#x3C;keep-alive></code> 包裹的组件，还有 <code>activated</code> 和 <code>deactivated</code> 钩子，分别在组件激活和停用时调用。了解Vue的生命周期有助于开发者在合适的时机执行代码，优化应用性能。\n</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>你能具体说明一下每个生命周期钩子的用途以及它们的调用顺序吗？</strong></p>\n    <ul>\n      <li>提示：强调创建、更新和销毁阶段的钩子。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何在生命周期钩子中处理异步请求？</strong></p>\n    <ul>\n      <li>提示：考虑使用 <code>mounted</code> 钩子中的 API 调用。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>请解释一下 <code>beforeDestroy</code> 和 <code>destroyed</code> 的区别？</strong></p>\n    <ul>\n      <li>提示：关注它们的调用时机及可能影响的操作。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何避免在生命周期钩子中引入内存泄漏？</strong></p>\n    <ul>\n      <li>提示：提到清理事件监听和定时器。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你是否使用过 Vue Router 或 Vuex 的生命周期？如果有，它们有什么不同？</strong></p>\n    <ul>\n      <li>提示：考虑组件与状态管理的关系。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你如何调试生命周期钩子的执行情况？</strong></p>\n    <ul>\n      <li>提示：想想使用 Vue Devtools 或 console.log。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在组件之间传递数据时，生命周期钩子的使用有什么注意事项？</strong></p>\n    <ul>\n      <li>提示：关注 props 的变化和相应的钩子。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>当组件被条件渲染（v-if）时，生命周期钩子的调用有什么特别之处？</strong></p>\n    <ul>\n      <li>提示：分析在组件挂载与卸载流程中的影响。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>请谈谈如何在 <code>created</code> 钩子中初始化组件的数据？</strong></p>\n    <ul>\n      <li>提示：提到数据来源及异步操作。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在 Vue 3 中，引入了组合式 API，对生命周期钩子的使用有什么改变？</strong></p>\n    <ul>\n      <li>提示：讨论 <code>onMounted</code> 等新的生命周期函数。</li>\n    </ul>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  Vue生命周期\n    创建阶段\n      beforeCreate\n      created\n    挂载阶段\n      beforeMount\n      mounted\n    更新阶段\n      beforeUpdate\n      updated\n    销毁阶段\n      beforeDestroy\n      destroyed\n    其他生命周期相关\n      activated\n      deactivated",
    "keynote": "- Vue 生命周期覆盖了组件的创建、挂载、更新到销毁过程。\n- 在`beforeCreate`钩子中，实例初始化完成但数据观测和事件配置未开始。\n- `created`时，数据观测和事件配置完毕，但DOM尚未生成。\n- `beforeMount`发生在模板编译为虚拟DOM之后，实际DOM渲染之前。\n- `mounted`阶段允许访问真实DOM，并可执行DOM操作。\n- `beforeUpdate`用于在数据变化后，DOM重新渲染前做准备。\n- `updated`在因数据变动导致的DOM更新完成后触发。\n- `beforeDestroy`提供清理资源的机会，如清除定时器或取消请求。\n- `destroyed`表示实例已销毁，所有事件监听及子实例都被移除。\n- `activated`与`deactivated`是针对<keep-alive>包裹组件特有的状态切换钩子。",
    "group_id": 45,
    "kps": [
      "基础"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "厦门航空",
      "搜狐畅游",
      "趣链科技",
      "货拉拉",
      "蔚来",
      "建信金融科技",
      "美团",
      "网易",
      "泛联新安",
      "慧点科技",
      "高顿教育",
      "三七互娱",
      "北京某小厂",
      "数字马力",
      "华为OD",
      "网易云",
      "奥金拓",
      "浙江至元数据科技有限公司",
      "京东",
      "至爱智家,三维家",
      "淘天集团",
      "金山",
      "用友",
      "同程旅行",
      "小米",
      "滴滴",
      "深信服",
      "携程",
      "顺丰",
      "vivo",
      "CVTE视源股份",
      "360",
      "猿辅导",
      "贝壳",
      "大华",
      "浙江大华",
      "腾娱互动",
      "B站",
      "奇安信",
      "恒生电子",
      "小红书",
      "成丰货运",
      "爱奇艺",
      "4399",
      "网易有道",
      "中国电信",
      "上海平安科技",
      "酷家乐",
      "旷视科技",
      "吉比特",
      "深圳吉比特雷霆游戏",
      "唯品会",
      "中国联通",
      "浩鲸科技",
      "星环科技",
      "中油消费金融",
      "湖北航信",
      "爱数科技",
      "第四范式",
      "Momenta",
      "天融信",
      "星环",
      "掌阅科技",
      "游卡",
      "飞猪",
      "字节跳动",
      "腾讯",
      "视语科技",
      "阿里巴巴",
      "树根前端",
      "百度",
      "浪潮智能终端",
      "华为",
      "星网易视",
      "众安",
      "快手",
      "OPPO",
      "招银网络科技",
      "科大讯飞",
      "联想集团",
      "腾讯音乐",
      "满帮集团",
      "心动游戏",
      "北京前端小厂"
    ]
  }
}