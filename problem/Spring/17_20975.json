{
  "success": true,
  "data": {
    "id": 20975,
    "name": "<p>请介绍 Spring 条件装配的类型</p>",
    "options": null,
    "answer": "<p>Spring 条件装配允许在满足特定条件时才将 Bean 定义加载到 Spring 容器中，主要有以下几种类型：</p>\n<h3>@Conditional 注解</h3>\n<p>这是 Spring 条件装配的基础注解，可用于类或方法上。通过指定一个实现了 <code>Condition</code> 接口的类，根据该类的 <code>matches</code> 方法返回的布尔值来决定是否进行 Bean 的装配。</p>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\n\n// 自定义条件类\nclass MyCondition implements org.springframework.context.annotation.Condition {\n    @Override\n    public boolean matches(org.springframework.context.annotation.ConditionContext context, org.springframework.core.type.AnnotatedTypeMetadata metadata) {\n        // 这里可以编写具体的条件判断逻辑\n        return true; \n    }\n}\n\n@Configuration\npublic class MyConfig {\n    @Bean\n    @Conditional(MyCondition.class)\n    public MyBean myBean() {\n        return new MyBean();\n    }\n}\n</code></pre>\n<p>在上述代码中，只有当 <code>MyCondition</code> 类的 <code>matches</code> 方法返回 <code>true</code> 时，<code>myBean</code> 才会被装配到 Spring 容器中。</p>\n<h3>@ConditionalOnClass 和 @ConditionalOnMissingClass</h3>\n<ul>\n  <li><strong>@ConditionalOnClass</strong>：当类路径下存在指定的类时，才会进行 Bean 的装配。</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionalOnClass;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class ClassConditionConfig {\n    @Bean\n    @ConditionalOnClass(name = \"com.example.SomeClass\")\n    public MyBean classPresentBean() {\n        return new MyBean();\n    }\n}\n</code></pre>\n<p>只有当类路径下存在 <code>com.example.SomeClass</code> 时，<code>classPresentBean</code> 才会被装配。</p>\n<ul>\n  <li><strong>@ConditionalOnMissingClass</strong>：与 <code>@ConditionalOnClass</code> 相反，当类路径下不存在指定的类时，才会进行 Bean 的装配。</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionalOnMissingClass;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MissingClassConditionConfig {\n    @Bean\n    @ConditionalOnMissingClass(\"com.example.SomeClass\")\n    public MyBean classMissingBean() {\n        return new MyBean();\n    }\n}\n</code></pre>\n<p>只有当类路径下不存在 <code>com.example.SomeClass</code> 时，<code>classMissingBean</code> 才会被装配。</p>\n<h3>@ConditionalOnBean 和 @ConditionalOnMissingBean</h3>\n<ul>\n  <li><strong>@ConditionalOnBean</strong>：当 Spring 容器中存在指定类型的 Bean 时，才会进行当前 Bean 的装配。</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionalOnBean;\nimport org.springframework.context.annotation.Configuration;\n\nclass AnotherBean {}\n\n@Configuration\npublic class BeanConditionConfig {\n    @Bean\n    public AnotherBean anotherBean() {\n        return new AnotherBean();\n    }\n\n    @Bean\n    @ConditionalOnBean(AnotherBean.class)\n    public MyBean beanPresentBean() {\n        return new MyBean();\n    }\n}\n</code></pre>\n<p>只有当 Spring 容器中存在 <code>AnotherBean</code> 类型的 Bean 时，<code>beanPresentBean</code> 才会被装配。</p>\n<ul>\n  <li><strong>@ConditionalOnMissingBean</strong>：与 <code>@ConditionalOnBean</code> 相反，当 Spring 容器中不存在指定类型的 Bean 时，才会进行当前 Bean 的装配。</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionalOnMissingBean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MissingBeanConditionConfig {\n    @Bean\n    @ConditionalOnMissingBean(AnotherBean.class)\n    public MyBean beanMissingBean() {\n        return new MyBean();\n    }\n}\n</code></pre>\n<p>只有当 Spring 容器中不存在 <code>AnotherBean</code> 类型的 Bean 时，<code>beanMissingBean</code> 才会被装配。</p>\n<h3>@ConditionalOnProperty</h3>\n<p>根据配置文件中的属性值来决定是否进行 Bean 的装配。可以指定属性名、属性值等条件。</p>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionalOnProperty;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class PropertyConditionConfig {\n    @Bean\n    @ConditionalOnProperty(name = \"my.property\", havingValue = \"true\")\n    public MyBean propertyBean() {\n        return new MyBean();\n    }\n}\n</code></pre>\n<p>只有当配置文件中 <code>my.property</code> 属性的值为 <code>true</code> 时，<code>propertyBean</code> 才会被装配。</p>\n<h3>@ConditionalOnResource</h3>\n<p>当类路径下存在指定的资源时，才会进行 Bean 的装配。</p>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionalOnResource;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class ResourceConditionConfig {\n    @Bean\n    @ConditionalOnResource(resources = \"classpath:myfile.txt\")\n    public MyBean resourceBean() {\n        return new MyBean();\n    }\n}\n</code></pre>\n<p>只有当类路径下存在 <code>myfile.txt</code> 文件时，<code>resourceBean</code> 才会被装配。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.0007806401,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：介绍 Spring 条件装配的类型。</li>\n  <li><strong>考察点</strong>：对 Spring 条件装配概念的理解，以及对不同条件装配类型的掌握。</li>\n</ul>\n<h3>2. 背景知识</h3>\n<p>Spring 条件装配允许根据特定条件来决定是否将某个 Bean 定义加载到 Spring 容器中。这在不同的环境（如开发、测试、生产）或者不同的依赖存在时非常有用，可以灵活控制 Bean 的加载。</p>\n<h3>3. 解析</h3>\n<h4>（1）@Conditional 注解</h4>\n<ul>\n  <li><strong>原理</strong>：这是 Spring 条件装配的基础注解，它可以应用在类或者方法上。通过指定一个实现了 Condition 接口的类，根据该类的 matches 方法的返回值来决定是否进行装配。</li>\n  <li><strong>示例</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    @Conditional(MyCondition.class)\n    public MyBean myBean() {\n        return new MyBean();\n    }\n}\n\nimport org.springframework.context.annotation.Condition;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\n\npublic class MyCondition implements Condition {\n    @Override\n    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n        // 自定义条件逻辑\n        return true; \n    }\n}\n</code></pre>\n<h4>（2）@ConditionalOnProperty</h4>\n<ul>\n  <li><strong>原理</strong>：根据配置文件中的属性值来决定是否进行装配。可以指定属性名、属性值等条件。</li>\n  <li><strong>示例</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    @ConditionalOnProperty(name = \"my.property\", havingValue = \"true\")\n    public MyBean myBean() {\n        return new MyBean();\n    }\n}\n</code></pre>\n<h4>（3）@ConditionalOnClass 和 @ConditionalOnMissingClass</h4>\n<ul>\n  <li><strong>原理</strong>：\n    <ul>\n      <li>@ConditionalOnClass：当类路径下存在指定的类时进行装配。</li>\n      <li>@ConditionalOnMissingClass：当类路径下不存在指定的类时进行装配。</li>\n    </ul>\n  </li>\n  <li><strong>示例</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionalOnClass;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    @ConditionalOnClass(name = \"com.example.SomeClass\")\n    public MyBean myBean() {\n        return new MyBean();\n    }\n}\n</code></pre>\n<h4>（4）@ConditionalOnBean 和 @ConditionalOnMissingBean</h4>\n<ul>\n  <li><strong>原理</strong>：\n    <ul>\n      <li>@ConditionalOnBean：当 Spring 容器中存在指定类型的 Bean 时进行装配。</li>\n      <li>@ConditionalOnMissingBean：当 Spring 容器中不存在指定类型的 Bean 时进行装配。</li>\n    </ul>\n  </li>\n  <li><strong>示例</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionalOnBean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    public AnotherBean anotherBean() {\n        return new AnotherBean();\n    }\n\n    @Bean\n    @ConditionalOnBean(AnotherBean.class)\n    public MyBean myBean() {\n        return new MyBean();\n    }\n}\n</code></pre>\n<h4>（5）@ConditionalOnWebApplication 和 @ConditionalOnNotWebApplication</h4>\n<ul>\n  <li><strong>原理</strong>：\n    <ul>\n      <li>@ConditionalOnWebApplication：当应用是 Web 应用时进行装配。</li>\n      <li>@ConditionalOnNotWebApplication：当应用不是 Web 应用时进行装配。</li>\n    </ul>\n  </li>\n  <li><strong>示例</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n\n    @Bean\n    @ConditionalOnWebApplication\n    public MyWebBean myWebBean() {\n        return new MyWebBean();\n    }\n}\n</code></pre>\n<h3>4. 常见误区</h3>\n<h4>（1）混淆不同条件注解的作用</h4>\n<ul>\n  <li>误区：不能准确区分 @ConditionalOnClass 和 @ConditionalOnBean 等注解的使用场景。</li>\n  <li>纠正：理解每个注解的判断依据，@ConditionalOnClass 基于类路径，@ConditionalOnBean 基于 Spring 容器中的 Bean。</li>\n</ul>\n<h4>（2）忽略条件注解的组合使用</h4>\n<ul>\n  <li>误区：只使用单个条件注解，没有考虑多个条件组合的情况。</li>\n  <li>纠正：可以将多个条件注解组合使用，实现更复杂的条件装配逻辑。</li>\n</ul>\n<h3>5. 总结回答</h3>\n<p>Spring 条件装配有多种类型：</p>\n<ul>\n  <li><strong>@Conditional</strong>：基础注解，通过实现 Condition 接口自定义条件逻辑，根据 matches 方法返回值决定是否装配。</li>\n  <li><strong>@ConditionalOnProperty</strong>：根据配置文件中的属性值决定是否装配。</li>\n  <li><strong>@ConditionalOnClass 和 @ConditionalOnMissingClass</strong>：分别在类路径下存在或不存在指定类时进行装配。</li>\n  <li><strong>@ConditionalOnBean 和 @ConditionalOnMissingBean</strong>：分别在 Spring 容器中存在或不存在指定类型的 Bean 时进行装配。</li>\n  <li><strong>@ConditionalOnWebApplication 和 @ConditionalOnNotWebApplication</strong>：分别在应用是或不是 Web 应用时进行装配。</li>\n</ul>\n<p>在使用时，要注意准确区分不同注解的作用，还可以组合使用多个条件注解实现复杂的条件装配逻辑。</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      <strong>条件装配在实际项目中的应用场景有哪些？</strong>\n      提示：结合不同的业务需求，如根据不同的运行环境加载不同的配置、根据不同的用户类型提供不同的服务等方面思考。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>@Conditional 注解和它的派生注解在使用上有什么区别和联系？</strong>\n      提示：从注解的功能、使用方式、适用场景等方面对比，派生注解如 @ConditionalOnClass、@ConditionalOnMissingBean 等。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如何自定义一个条件装配的条件类？</strong>\n      提示：需要实现 Condition 接口，关注接口中的 matches 方法的实现逻辑。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>条件装配和 Spring 的自动配置有什么关系？</strong>\n      提示：思考 Spring 自动配置的原理，以及条件装配在其中起到的筛选和加载配置的作用。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在条件装配中，条件的执行顺序是怎样的？如何控制执行顺序？</strong>\n      提示：考虑 Spring 框架对条件的处理机制，以及是否有相关注解可以控制顺序。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如果多个条件装配注解同时作用在一个 Bean 上，会发生什么？</strong>\n      提示：分析不同条件注解的条件判断结果，以及 Spring 如何根据这些结果决定是否创建 Bean。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>条件装配在 Spring Boot 中的实现和 Spring 有什么不同？</strong>\n      提示：对比 Spring Boot 的自动配置特性和 Spring 的传统配置方式，看条件装配在两者中的应用差异。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>条件装配对 Bean 的生命周期有什么影响？</strong>\n      提示：思考条件装配决定 Bean 是否创建，这对 Bean 的初始化、销毁等生命周期阶段的影响。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Spring 条件装配))\n    定义\n      满足特定条件才将 Bean 定义加载到 Spring 容器\n    类型\n      @Conditional 注解\n        基础注解，用于类或方法\n        指定实现 Condition 接口的类\n        根据 matches 方法布尔值决定装配\n      @ConditionalOnClass 和 @ConditionalOnMissingClass\n        @ConditionalOnClass\n          类路径存在指定类时装配 Bean\n        @ConditionalOnMissingClass\n          类路径不存在指定类时装配 Bean\n      @ConditionalOnBean 和 @ConditionalOnMissingBean\n        @ConditionalOnBean\n          Spring 容器存在指定类型 Bean 时装配当前 Bean\n        @ConditionalOnMissingBean\n          Spring 容器不存在指定类型 Bean 时装配当前 Bean\n      @ConditionalOnProperty\n        根据配置文件属性值决定 Bean 装配\n        可指定属性名、属性值等条件\n      @ConditionalOnResource\n        类路径存在指定资源时装配 Bean",
    "keynote": "Spring 条件装配：满足特定条件将 Bean 定义加载到 Spring 容器\n- @Conditional 注解：基础注解，指定实现 Condition 接口类，依 matches 方法布尔值决定装配\n- @ConditionalOnClass：类路径存在指定类时装配 Bean\n- @ConditionalOnMissingClass：类路径不存在指定类时装配 Bean\n- @ConditionalOnBean：Spring 容器存在指定类型 Bean 时装配当前 Bean\n- @ConditionalOnMissingBean：Spring 容器不存在指定类型 Bean 时装配当前 Bean\n- @ConditionalOnProperty：根据配置文件属性值决定 Bean 装配，可指定属性名、值\n- @ConditionalOnResource：类路径存在指定资源时装配 Bean",
    "group_id": 17,
    "kps": [
      "高级特性"
    ],
    "years": [
      2024
    ],
    "corps": [
      "小米"
    ]
  }
}