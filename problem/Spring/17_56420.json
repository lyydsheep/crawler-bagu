{
  "success": true,
  "data": {
    "id": 56420,
    "name": "<p>三级缓存解决循环依赖中，三级缓存每一级是存什么的</p>",
    "options": null,
    "answer": "<p>在 Spring 中，三级缓存的命名和实际作用如下：</p>\n<h4>一级缓存：<code>singletonObjects</code></h4>\n<ul>\n  <li><strong>存储内容</strong>：完全初始化的单例Bean实例（完成所有生命周期流程）。</li>\n  <li><strong>作用</strong>：提供全局唯一的可用Bean，避免重复创建。</li>\n</ul>\n<h4>二级缓存：<code>earlySingletonObjects</code></h4>\n<ul>\n  <li><strong>存储内容</strong>：已实例化但未完成属性填充和初始化的Bean早期引用。</li>\n  <li><strong>作用</strong>：缓存早期生成的Bean实例，避免同一Bean的早期引用被多次创建（例如，在循环依赖中确保引用唯一）。</li>\n</ul>\n<h4>三级缓存：<code>singletonFactories</code></h4>\n<ul>\n  <li><strong>存储内容</strong>：<code>ObjectFactory&#x3C;Bean></code>函数式对象，用于生成Bean的早期引用。</li>\n  <li><strong>作用</strong>：\n    <ol>\n      <li><strong>延迟代理生成</strong>：仅在循环依赖需要时通过<code>getObject()</code>生成代理对象（若存在AOP），避免提前代理破坏初始化逻辑。</li>\n      <li><strong>动态创建早期引用</strong>：通过函数式接口按需生成实例，而非直接存储实例，提高灵活性。</li>\n    </ol>\n  </li>\n</ul>\n<h3>循环依赖完整流程（以A→B→A为例）</h3>\n<ol>\n  <li><strong>创建Bean A</strong>：\n    <ul>\n      <li>实例化A，生成原始对象<code>a</code>，将<code>() -> a</code>存入三级缓存。</li>\n    </ul>\n  </li>\n  <li><strong>注入A的属性时发现依赖B</strong>：\n    <ul>\n      <li>触发Bean B的创建。</li>\n    </ul>\n  </li>\n  <li><strong>创建Bean B</strong>：\n    <ul>\n      <li>实例化B，生成原始对象<code>b</code>，将<code>() -> b</code>存入三级缓存。</li>\n    </ul>\n  </li>\n  <li><strong>注入B的属性时发现依赖A</strong>：\n    <ul>\n      <li>从三级缓存获取A的ObjectFactory，调用<code>getObject()</code>获取<code>earlyA</code>（可能是代理对象）。</li>\n      <li>将<code>earlyA</code>存入二级缓存，移除三级缓存中的A的ObjectFactory。</li>\n      <li>完成B的初始化，将B存入一级缓存。</li>\n    </ul>\n  </li>\n  <li><strong>A继续初始化</strong>：\n    <ul>\n      <li>从一级缓存获取B实例，注入到A中。</li>\n      <li>完成A的初始化后，将A存入一级缓存，移除二级缓存中的<code>earlyA</code>。</li>\n    </ul>\n  </li>\n</ol>\n<h3>核心原理总结</h3>\n<ul>\n  <li><strong>三级缓存的本质</strong>：通过\"延迟代理+早期引用缓存\"解决循环依赖，其中三级缓存负责动态生成代理，二级缓存负责缓存结果，一级缓存负责存储最终实例。</li>\n  <li><strong>AOP与循环依赖的关系</strong>：三级缓存的ObjectFactory是处理AOP代理的关键，确保代理仅在循环依赖场景中按需生成，避免初始化阶段的逻辑冲突。</li>\n</ul>",
    "type": 6,
    "level": 2,
    "freq": 0.0007806401,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Spring三级缓存每一级存什么。</li>\n  <li><strong>考察点</strong>：对Spring解决循环依赖机制的理解，特别是三级缓存的作用和存储内容。</li>\n</ul>\n<h3>2. 背景知识</h3>\n<ul>\n  <li><strong>循环依赖</strong>：在Spring中，当两个或多个Bean相互依赖时，就会出现循环依赖问题。例如，Bean A依赖Bean B，而Bean B又依赖Bean A。</li>\n  <li><strong>三级缓存</strong>：Spring使用三级缓存来解决循环依赖问题，分别是singletonObjects、singletonFactories和earlySingletonObjects。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）一级缓存：singletonObjects</h4>\n<ul>\n  <li><strong>存储内容</strong>：存储已经完全初始化好的单例Bean实例。这些Bean已经完成了所有的属性注入和初始化方法调用，可以直接使用。</li>\n  <li><strong>作用</strong>：是Spring容器中最终存储单例Bean的地方，当需要获取一个单例Bean时，首先会从这个缓存中查找。</li>\n</ul>\n<h4>（2）二级缓存：earlySingletonObjects</h4>\n<ul>\n  <li><strong>存储内容</strong>：存储提前曝光的单例Bean实例。这些Bean还没有完成所有的属性注入和初始化方法调用，但已经创建了实例对象。</li>\n  <li><strong>作用</strong>：用于解决循环依赖问题，当一个Bean在创建过程中被其他Bean引用时，可以先将其提前曝光到这个缓存中，让其他Bean可以引用到这个未完全初始化的实例。</li>\n</ul>\n<h4>（3）三级缓存：singletonFactories</h4>\n<ul>\n  <li><strong>存储内容</strong>：存储单例Bean的工厂对象。这些工厂对象可以用来创建单例Bean的早期引用。</li>\n  <li><strong>作用</strong>：在Bean创建过程中，将一个ObjectFactory对象放入这个缓存中，当其他Bean需要引用这个Bean时，可以通过这个工厂对象获取到这个Bean的早期引用。这样可以在不破坏Bean创建流程的前提下，解决循环依赖问题。</li>\n</ul>\n<h3>4. 示例代码及流程说明</h3>\n<pre><code class=\"language-java\">// 模拟Spring的三级缓存\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nclass BeanFactory {\n    // 一级缓存：存储完全初始化的单例Bean\n    private final Map&#x3C;String, Object> singletonObjects = new ConcurrentHashMap&#x3C;>();\n    // 二级缓存：存储提前曝光的单例Bean\n    private final Map&#x3C;String, Object> earlySingletonObjects = new HashMap&#x3C;>();\n    // 三级缓存：存储单例Bean的工厂对象\n    private final Map&#x3C;String, ObjectFactory&#x3C;?>> singletonFactories = new HashMap&#x3C;>();\n\n    public Object getBean(String beanName) {\n        // 先从一级缓存中查找\n        Object singletonObject = singletonObjects.get(beanName);\n        if (singletonObject == null) {\n            // 再从二级缓存中查找\n            singletonObject = earlySingletonObjects.get(beanName);\n            if (singletonObject == null) {\n                // 最后从三级缓存中查找\n                ObjectFactory&#x3C;?> singletonFactory = singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    // 通过工厂对象获取早期引用\n                    singletonObject = singletonFactory.getObject();\n                    // 将早期引用放入二级缓存\n                    earlySingletonObjects.put(beanName, singletonObject);\n                    // 从三级缓存中移除\n                    singletonFactories.remove(beanName);\n                }\n            }\n        }\n        return singletonObject;\n    }\n\n    public void addSingletonFactory(String beanName, ObjectFactory&#x3C;?> singletonFactory) {\n        // 将工厂对象放入三级缓存\n        singletonFactories.put(beanName, singletonFactory);\n    }\n\n    public void addSingleton(String beanName, Object singletonObject) {\n        // 将完全初始化的Bean放入一级缓存\n        singletonObjects.put(beanName, singletonObject);\n        // 从二级缓存中移除\n        earlySingletonObjects.remove(beanName);\n        // 从三级缓存中移除\n        singletonFactories.remove(beanName);\n    }\n}\n\ninterface ObjectFactory&#x3C;T> {\n    T getObject();\n}\n\n// 测试代码\npublic class Main {\n    public static void main(String[] args) {\n        BeanFactory beanFactory = new BeanFactory();\n        // 模拟创建Bean的过程\n        String beanName = \"testBean\";\n        ObjectFactory&#x3C;Object> factory = () -> new Object();\n        beanFactory.addSingletonFactory(beanName, factory);\n        Object bean = beanFactory.getBean(beanName);\n        beanFactory.addSingleton(beanName, bean);\n        System.out.println(beanFactory.getBean(beanName));\n    }\n}\n</code></pre>\n<ul>\n  <li>在这个示例中，<code>singletonObjects</code>存储完全初始化的Bean，<code>earlySingletonObjects</code>存储提前曝光的Bean，<code>singletonFactories</code>存储Bean的工厂对象。当需要获取一个Bean时，会按照一级缓存、二级缓存、三级缓存的顺序查找。</li>\n</ul>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆三级缓存的作用</h4>\n<ul>\n  <li>误区：不清楚每一级缓存的具体作用，认为它们的功能是一样的。</li>\n  <li>纠正：明确一级缓存存储完全初始化的Bean，二级缓存存储提前曝光的Bean，三级缓存存储Bean的工厂对象。</li>\n</ul>\n<h4>（2）忽略三级缓存的使用顺序</h4>\n<ul>\n  <li>误区：在获取Bean时，不按照一级缓存、二级缓存、三级缓存的顺序查找。</li>\n  <li>纠正：按照正确的顺序查找，先从一级缓存中查找，再从二级缓存中查找，最后从三级缓存中查找。</li>\n</ul>\n<h4>（3）不理解三级缓存解决循环依赖的原理</h4>\n<ul>\n  <li>误区：只知道三级缓存可以解决循环依赖问题，但不理解具体的原理。</li>\n  <li>纠正：理解三级缓存通过提前曝光Bean的早期引用，让其他Bean可以引用到未完全初始化的实例，从而解决循环依赖问题。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>Spring的三级缓存分别是singletonObjects、singletonFactories和earlySingletonObjects。一级缓存singletonObjects存储已经完全初始化好的单例Bean实例，这些Bean可以直接使用；二级缓存earlySingletonObjects存储提前曝光的单例Bean实例，这些Bean还未完成所有初始化步骤，但可用于解决循环依赖时被其他Bean引用；三级缓存singletonFactories存储单例Bean的工厂对象，通过这些工厂对象能获取到Bean的早期引用，在不破坏Bean创建流程的情况下解决循环依赖。在获取Bean时，会先从一级缓存查找，若未找到则从二级缓存查找，最后从三级缓存查找。</p>",
    "more_ask": "<h3>1. 三级缓存解决循环依赖时，创建 Bean 过程中是如何使用这三级缓存的？</h3>\n<p>提示：思考 Bean 创建的各个阶段，如实例化、属性填充、初始化等，以及在这些阶段中三级缓存是如何配合使用来解决循环依赖问题的。</p>\n<h3>2. 为什么需要三级缓存，二级缓存是否可以解决循环依赖问题？</h3>\n<p>提示：分析二级缓存和三级缓存的区别，考虑在没有三级缓存的情况下，使用二级缓存会遇到什么问题，以及三级缓存中第三级缓存的独特作用。</p>\n<h3>3. 三级缓存解决循环依赖是否有局限性，在哪些场景下无法解决？</h3>\n<p>提示：思考 Spring 中 Bean 的不同作用域（如单例、原型等）、Bean 的创建过程中的特殊情况（如 AOP 代理），分析这些情况对循环依赖解决的影响。</p>\n<h3>4. 当存在多个循环依赖时，三级缓存是如何处理的？</h3>\n<p>提示：假设有多个 Bean 之间形成了复杂的循环依赖关系，考虑三级缓存的存储和获取机制如何应对这种情况，以及在处理过程中是否有顺序要求。</p>\n<h3>5. 在三级缓存解决循环依赖的过程中，AOP 代理是如何参与的？</h3>\n<p>提示：了解 AOP 代理的创建时机和方式，思考在 Bean 创建过程中，当涉及 AOP 代理时，三级缓存如何保证循环依赖的解决和代理对象的正确创建。</p>",
    "mindmap": "mindmap\n  root((Spring三级缓存解决Bean循环依赖))\n    一级缓存：singletonObjects\n      存储内容：完成创建、初始化且经所有BeanPostProcessor处理的单例Bean实例\n      作用：常用缓存，获取单例Bean时优先查找，避免重复创建\n    二级缓存：singletonFactories\n      存储内容：单例Bean的ObjectFactory工厂对象\n      作用：解决循环依赖，提前获取早期Bean引用\n    三级缓存：earlySingletonObjects\n      存储内容：提前暴露的早期单例Bean实例\n      作用：避免重复调用ObjectFactory的getObject()方法\n    总结\n      解决单例Bean循环依赖，不影响正常创建流程",
    "keynote": "Spring三级缓存解决Bean循环依赖\n一级缓存singletonObjects：存完成创建等处理的单例Bean实例，获取单例Bean优先查找\n二级缓存singletonFactories：存单例Bean的ObjectFactory工厂对象，解决循环依赖\n三级缓存earlySingletonObjects：存提前暴露的早期单例Bean实例，避免重复调用工厂方法\n总结：解决单例Bean循环依赖，不影响正常创建流程",
    "group_id": 17,
    "kps": [
      "控制反转（IoC）与依赖注入（DI）",
      "框架中的设计模式"
    ],
    "years": [
      2024
    ],
    "corps": [
      "中科微至"
    ]
  }
}