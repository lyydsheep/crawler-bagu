{"success":true,"data":{"id":15417,"name":"<p>请阐述@Transactional的底层原理</p>","options":null,"answer":"<p><code>@Transactional</code> 是 Spring 框架中用于实现声明式事务管理的注解，其底层主要基于 Spring AOP（面向切面编程）和动态代理机制，结合事务管理器来实现事务的管理，下面详细阐述其原理：</p>\n<h3>1. Spring AOP 和动态代理</h3>\n<p>Spring AOP 是一种编程范式，它允许开发者在不修改原有业务逻辑的基础上，对程序进行增强。<code>@Transactional</code> 利用 AOP 实现了事务的自动管理，具体通过动态代理来创建代理对象。Spring 提供了两种动态代理方式：</p>\n<h4>JDK 动态代理</h4>\n<ul>\n  <li>当目标对象实现了至少一个接口时，Spring 会使用 JDK 动态代理。JDK 动态代理通过 <code>java.lang.reflect.Proxy</code> 类和 <code>java.lang.reflect.InvocationHandler</code> 接口来创建代理对象。</li>\n  <li>在运行时，Spring 会生成一个实现了目标对象所有接口的代理类，该代理类会拦截目标方法的调用，并在方法调用前后添加事务管理逻辑。</li>\n</ul>\n<h4>CGLIB 动态代理</h4>\n<ul>\n  <li>当目标对象没有实现任何接口时，Spring 会使用 CGLIB 动态代理。CGLIB 是一个强大的、高性能的代码生成库，它通过继承目标对象来创建代理对象。</li>\n  <li>CGLIB 会在运行时生成一个目标对象的子类，并重写目标对象的方法，在方法调用前后添加事务管理逻辑。</li>\n</ul>\n<h3>2. 事务管理器</h3>\n<p>Spring 提供了多种事务管理器，如 <code>DataSourceTransactionManager</code> 用于 JDBC 事务管理，<code>JpaTransactionManager</code> 用于 JPA 事务管理等。事务管理器负责实际的事务操作，如开启事务、提交事务、回滚事务等。</p>\n<h3>3. 底层执行流程</h3>\n<p>下面是 <code>@Transactional</code> 注解在方法调用时的详细执行流程：</p>\n<h4>1. 解析注解</h4>\n<ul>\n  <li>Spring 在启动时会扫描带有 <code>@Transactional</code> 注解的类和方法，将这些注解信息解析并存储在 <code>TransactionAttribute</code> 对象中，该对象包含了事务的属性，如传播行为、隔离级别、超时时间等。</li>\n</ul>\n<h4>2. 创建代理对象</h4>\n<ul>\n  <li>根据目标对象是否实现接口，选择 JDK 动态代理或 CGLIB 动态代理创建代理对象。代理对象会拦截目标方法的调用。</li>\n</ul>\n<h4>3. 方法调用</h4>\n<ul>\n  <li>当调用带有 <code>@Transactional</code> 注解的方法时，实际上是调用代理对象的方法。</li>\n</ul>\n<h4>4. 事务拦截器处理</h4>\n<ul>\n  <li>代理对象会将方法调用委托给 <code>TransactionInterceptor</code> 进行处理。<code>TransactionInterceptor</code> 是 Spring 提供的一个拦截器，它负责事务的管理。</li>\n</ul>\n<h4>5. 开启事务</h4>\n<ul>\n  <li><code>TransactionInterceptor</code> 会根据 <code>TransactionAttribute</code> 中的事务属性，调用事务管理器的 <code>getTransaction</code> 方法开启一个新的事务或加入一个已有的事务。</li>\n</ul>\n<h4>6. 执行目标方法</h4>\n<ul>\n  <li>开启事务后，<code>TransactionInterceptor</code> 会调用目标对象的实际方法。</li>\n</ul>\n<h4>7. 提交或回滚事务</h4>\n<ul>\n  <li>如果目标方法正常执行完毕，<code>TransactionInterceptor</code> 会调用事务管理器的 <code>commit</code> 方法提交事务。</li>\n  <li>如果目标方法抛出异常，<code>TransactionInterceptor</code> 会根据 <code>@Transactional</code> 注解的 <code>rollbackFor</code> 和 <code>noRollbackFor</code> 属性判断是否需要回滚事务。如果需要回滚，会调用事务管理器的 <code>rollback</code> 方法回滚事务。</li>\n</ul>\n<h3>示例代码</h3>\n<p>下面是一个简单的示例，展示了 <code>@Transactional</code> 的使用：</p>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\npublic class UserService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Transactional\n    public void saveUser(User user) {\n        userRepository.save(user);\n        // 模拟异常\n        if (user.getName().equals(\"error\")) {\n            throw new RuntimeException(\"模拟异常\");\n        }\n    }\n}\n</code></pre>\n<p>在上述示例中，<code>saveUser</code> 方法使用了 <code>@Transactional</code> 注解，当方法正常执行时，事务会提交；当方法抛出 <code>RuntimeException</code> 时，事务会回滚。</p>","type":6,"level":3,"freq":0.005464481,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：阐述@Transactional的底层原理。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Spring AOP（面向切面编程）的理解。</li>\n      <li>Spring事务管理机制。</li>\n      <li>动态代理的应用。</li>\n      <li>事务传播行为和隔离级别的实现。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Spring AOP</h4>\n<ul>\n  <li>AOP是一种编程范式，它允许开发者在不修改原有业务逻辑的基础上，对程序进行增强。</li>\n  <li>Spring AOP通过代理模式实现，有JDK动态代理和CGLIB代理两种方式。</li>\n</ul>\n<h4>（2）Spring事务管理</h4>\n<ul>\n  <li>Spring提供了声明式和编程式两种事务管理方式，@Transactional是声明式事务管理的注解。</li>\n  <li>事务管理涉及事务的开启、提交、回滚等操作。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）@Transactional的工作流程</h4>\n<ul>\n  <li><strong>解析注解</strong>：Spring容器在启动时，会扫描带有@Transactional注解的类和方法，将这些信息存储在一个事务元数据中。</li>\n  <li><strong>创建代理对象</strong>：Spring利用AOP为带有@Transactional注解的类或方法创建代理对象。如果目标对象实现了接口，使用JDK动态代理；如果没有实现接口，使用CGLIB代理。</li>\n  <li><strong>拦截方法调用</strong>：当调用带有@Transactional注解的方法时，实际上是调用代理对象的方法。代理对象会拦截该方法的调用。</li>\n  <li><strong>事务管理</strong>：在方法调用前后，代理对象会根据事务元数据进行事务管理操作。\n    <ul>\n      <li><strong>开启事务</strong>：在方法执行前，根据事务传播行为和隔离级别开启一个新的事务。</li>\n      <li><strong>执行方法</strong>：调用目标对象的实际方法。</li>\n      <li><strong>提交或回滚事务</strong>：如果方法正常执行结束，代理对象会提交事务；如果方法抛出异常，代理对象会根据异常类型决定是否回滚事务。</li>\n    </ul>\n  </li>\n</ul>\n<h4>（2）事务传播行为</h4>\n<ul>\n  <li>事务传播行为定义了多个事务方法相互调用时，事务如何传播。例如，REQUIRED表示如果当前没有事务，就创建一个新事务；如果已经存在事务，就加入该事务。</li>\n  <li>Spring通过在代理对象中维护一个事务上下文来实现事务传播行为。</li>\n</ul>\n<h4>（3）事务隔离级别</h4>\n<ul>\n  <li>事务隔离级别定义了一个事务对其他事务的可见性。例如，READ_COMMITTED表示一个事务只能读取已经提交的数据。</li>\n  <li>Spring在开启事务时，会根据@Transactional注解中指定的隔离级别，设置数据库连接的隔离级别。</li>\n</ul>\n<h4>（4）异常处理</h4>\n<ul>\n  <li>@Transactional注解可以指定哪些异常会触发事务回滚。默认情况下，RuntimeException和Error会触发回滚。</li>\n  <li>代理对象在捕获到异常后，会根据配置决定是否回滚事务。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">import org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\npublic class UserService {\n\n    @Transactional\n    public void saveUser() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<ul>\n  <li>在这个例子中，<code>saveUser</code>方法被@Transactional注解标记，Spring会为<code>UserService</code>创建代理对象，在调用<code>saveUser</code>方法时进行事务管理。</li>\n</ul>\n<h3>5. 常见误区</h3>\n<h4>（1）认为@Transactional注解可以在任何方法上使用</h4>\n<ul>\n  <li>误区：在非公共方法上使用@Transactional注解，认为也能生效。</li>\n  <li>纠正：@Transactional注解只能在公共方法上使用，因为Spring AOP的代理机制只能拦截公共方法。</li>\n</ul>\n<h4>（2）忽略事务传播行为和隔离级别的配置</h4>\n<ul>\n  <li>误区：使用默认的事务传播行为和隔离级别，不考虑业务需求。</li>\n  <li>纠正：根据具体业务场景，合理配置事务传播行为和隔离级别。</li>\n</ul>\n<h4>（3）认为异常一定会触发事务回滚</h4>\n<ul>\n  <li>误区：认为只要方法抛出异常，事务就一定会回滚。</li>\n  <li>纠正：只有在@Transactional注解中指定的异常类型才会触发回滚，默认是RuntimeException和Error。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“@Transactional是Spring提供的声明式事务管理注解，其底层原理基于Spring AOP和事务管理机制。</p>\n<p>Spring容器在启动时会扫描带有@Transactional注解的类和方法，为其创建代理对象。当调用这些方法时，实际上是调用代理对象的方法，代理对象会拦截方法调用并进行事务管理。</p>\n<p>在方法执行前，代理对象会根据事务传播行为和隔离级别开启一个新的事务；方法执行过程中，会调用目标对象的实际方法；方法执行结束后，如果没有异常，代理对象会提交事务；如果抛出指定类型的异常，代理对象会回滚事务。</p>\n<p>需要注意的是，@Transactional注解只能在公共方法上使用，并且要根据具体业务场景合理配置事务传播行为和隔离级别。同时，只有指定类型的异常才会触发事务回滚。”</p>","more_ask":"<ol>\n  <li>\n    <p>\n      <strong>@Transactional的传播行为有哪些，在嵌套事务场景下不同传播行为是如何工作的？</strong>\n      提示：回顾Spring定义的7种传播行为，思考在一个事务方法调用另一个事务方法时，不同传播行为对事务的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>@Transactional的隔离级别有哪些，分别解决了哪些并发问题？</strong>\n      提示：了解Spring中对应数据库的4种隔离级别，分析每种隔离级别如何应对脏读、不可重复读、幻读等并发问题。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在使用@Transactional时，哪些情况下事务会失效，如何避免这些失效情况？</strong>\n      提示：考虑方法调用、异常处理、代理机制等方面，思考哪些因素会导致事务注解不起作用。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>@Transactional注解的方法中，如果抛出了自定义异常，事务会回滚吗，如何控制？</strong>\n      提示：关注@Transactional注解的rollbackFor和noRollbackFor属性，思考如何根据异常类型控制事务回滚。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>@Transactional底层使用了AOP，能详细说明AOP是如何实现事务管理的吗？</strong>\n      提示：从AOP的切面、通知、切点概念入手，分析在事务方法执行前后AOP是如何进行事务开启、提交、回滚等操作的。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在多数据源环境下，@Transactional如何指定使用哪个数据源的事务？</strong>\n      提示：思考如何通过配置和注解来区分不同数据源的事务管理器。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>@Transactional注解的方法中调用了非事务方法，非事务方法中的异常会影响事务吗？</strong>\n      提示：结合事务传播行为和异常处理机制，分析非事务方法异常对当前事务的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>@Transactional的超时属性有什么作用，如何设置和生效？</strong>\n      提示：了解超时属性的含义，思考在事务执行时间超过设定值时会发生什么，以及如何正确设置该属性。\n    </p>\n  </li>\n</ol>","mindmap":"mindmap\n  root((@Transactional注解原理))\n    Spring AOP和动态代理\n      JDK动态代理\n        适用条件：目标对象实现至少一个接口\n        创建方式：通过java.lang.reflect.Proxy类和InvocationHandler接口\n        代理逻辑：生成实现目标对象所有接口的代理类，拦截方法调用并添加事务逻辑\n      CGLIB动态代理\n        适用条件：目标对象未实现任何接口\n        创建方式：通过继承目标对象\n        代理逻辑：生成目标对象子类，重写方法并添加事务逻辑\n    事务管理器\n      多种类型：如DataSourceTransactionManager、JpaTransactionManager\n      职责：负责实际事务操作（开启、提交、回滚）\n    底层执行流程\n      解析注解\n        扫描注解类和方法\n        存储注解信息到TransactionAttribute对象\n      创建代理对象\n        根据目标对象是否实现接口选择代理方式\n      方法调用\n        调用代理对象方法\n      事务拦截器处理\n        委托给TransactionInterceptor处理\n      开启事务\n        根据TransactionAttribute调用事务管理器getTransaction方法\n      执行目标方法\n        调用目标对象实际方法\n      提交或回滚事务\n        正常执行：调用事务管理器commit方法\n        抛出异常：根据注解属性判断是否回滚，调用rollback方法","keynote":"@Transactional：Spring声明式事务管理注解，基于AOP和动态代理，结合事务管理器\nSpring AOP和动态代理\n  JDK动态代理：目标对象有接口，用Proxy和InvocationHandler创建代理类\n  CGLIB动态代理：目标对象无接口，通过继承创建子类代理\n事务管理器：多种类型，负责事务操作\n底层执行流程\n  解析注解：扫描存储注解信息\n  创建代理对象：依接口情况选代理方式\n  方法调用：调代理对象方法\n  事务拦截器处理：委托TransactionInterceptor\n  开启事务：依属性调用getTransaction\n  执行目标方法：调实际方法\n  提交或回滚事务：正常commit，异常依属性判断是否rollback","group_id":17,"kps":["事务管理","面向切面编程（AOP）","框架中的设计模式"],"years":[2025,2024,2022],"corps":["杭州中小厂","数新智能","字节抖音","腾讯","拼多多","恒生电子","淘天集团"]}}