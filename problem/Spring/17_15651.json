{"success":true,"data":{"id":15651,"name":"<p>项目启动过程中循环依赖是什么，是如何产生的，如何避免和解决</p>","options":null,"answer":"<h3>循环依赖的定义</h3>\n<p>在项目启动过程中，循环依赖指的是多个 Bean 之间相互依赖，形成一个闭环。例如，Bean A 依赖于 Bean B，而 Bean B 又依赖于 Bean A，或者更复杂的情况，如 Bean A 依赖 Bean B，Bean B 依赖 Bean C，而 Bean C 又依赖 Bean A。这种循环依赖可能会导致 Bean 创建过程陷入死循环，使得 Spring 容器无法正常完成 Bean 的初始化。</p>\n<h3>循环依赖产生的原因</h3>\n<p>Spring 容器在创建 Bean 时，会根据 Bean 的依赖关系来依次创建所需的 Bean。当存在循环依赖时，就会出现问题。以 Bean A 依赖 Bean B，Bean B 依赖 Bean A 为例：</p>\n<ol>\n  <li>Spring 容器开始创建 Bean A，在创建过程中发现需要注入 Bean B。</li>\n  <li>于是 Spring 容器开始创建 Bean B，在创建 Bean B 时又发现需要注入 Bean A。</li>\n  <li>此时 Bean A 还未创建完成，又要重新创建 Bean A，如此反复，形成循环。</li>\n</ol>\n<h3>避免循环依赖的方法</h3>\n<ol>\n  <li><strong>重构代码</strong>：对代码的设计进行优化，重新梳理 Bean 之间的依赖关系，避免出现循环依赖。可以通过引入中间层或者调整业务逻辑，将原本相互依赖的 Bean 解耦。例如，将 Bean A 和 Bean B 共同依赖的部分提取到一个新的 Bean C 中，让 A 和 B 分别依赖 C，而不是相互依赖。</li>\n  <li><strong>使用依赖注入的替代方式</strong>：可以考虑使用依赖查找（Dependency Lookup）来替代部分依赖注入。依赖查找是指在需要使用某个 Bean 时，主动从 Spring 容器中获取该 Bean，而不是通过依赖注入的方式在创建时就注入。不过这种方式会增加代码的耦合度，需要谨慎使用。</li>\n</ol>\n<h3>解决循环依赖的方法</h3>\n<ol>\n  <li>\n    <p><strong>Spring 的三级缓存机制</strong>：Spring 内部通过三级缓存来解决单例 Bean 的循环依赖问题。</p>\n    <ul>\n      <li><strong>一级缓存（singletonObjects）</strong>：用于存储已经完全创建好的单例 Bean，这些 Bean 可以直接使用。</li>\n      <li><strong>二级缓存（singletonFactories）</strong>：存储单例 Bean 的工厂对象，当需要解决循环依赖时，可以通过这些工厂对象提前获取到一个半成品的 Bean。</li>\n      <li><strong>三级缓存（earlySingletonObjects）</strong>：存储提前暴露的单例 Bean，这些 Bean 还未完成初始化，但可以用于解决循环依赖。</li>\n    </ul>\n    <p>以 Bean A 依赖 Bean B，Bean B 依赖 Bean A 为例，具体过程如下：</p>\n    <ul>\n      <li>Spring 容器开始创建 Bean A，将 Bean A 的工厂对象放入三级缓存 singletonFactories 中。</li>\n      <li>在创建 Bean A 的过程中，发现需要注入 Bean B，于是开始创建 Bean B。</li>\n      <li>创建 Bean B 时，将 Bean B 的工厂对象放入三级缓存 singletonFactories 中，在创建过程中发现需要注入 Bean A。</li>\n      <li>此时从三级缓存 singletonFactories 中获取 Bean A 的工厂对象，通过工厂对象创建一个半成品的 Bean A 放入二级缓存 earlySingletonObjects 中，并从三级缓存中移除。</li>\n      <li>将这个半成品的 Bean A 注入到 Bean B 中，完成 Bean B 的创建，并将 Bean B 放入一级缓存 singletonObjects 中。</li>\n      <li>继续完成 Bean A 的创建，将 Bean A 从二级缓存 earlySingletonObjects 中移除，并放入一级缓存 singletonObjects 中。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>使用 @Lazy 注解</strong>：在 Bean 的依赖注入处使用 @Lazy 注解，该注解会使 Bean 的创建延迟到第一次使用时。例如：</p>\n  </li>\n</ol>\n<pre><code class=\"language-java\">@Component\npublic class A {\n    @Autowired\n    @Lazy\n    private B b;\n    // 其他代码\n}\n\n@Component\npublic class B {\n    @Autowired\n    private A a;\n    // 其他代码\n}\n</code></pre>\n<p>这样在创建 Bean A 时，不会立即创建 Bean B，而是在第一次使用 Bean B 时才创建，从而避免了循环依赖的问题。</p>","type":6,"level":2,"freq":0.005464481,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：项目启动过程中循环依赖是什么，是如何产生的，如何避免和解决。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Spring循环依赖概念的理解。</li>\n      <li>掌握循环依赖产生的原因。</li>\n      <li>了解避免和解决循环依赖的方法。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Spring Bean的生命周期</h4>\n<p>Spring容器负责创建和管理Bean，其生命周期包含实例化、属性注入、初始化等阶段。实例化是创建Bean对象，属性注入是为Bean的属性赋值，初始化是调用初始化方法。</p>\n<h4>（2）依赖注入</h4>\n<p>Spring通过依赖注入实现Bean之间的依赖关系。当一个Bean需要另一个Bean时，Spring会将所需的Bean注入到该Bean中。</p>\n<h3>3. 解析</h3>\n<h4>（1）循环依赖是什么</h4>\n<p>循环依赖指的是多个Bean之间相互依赖，形成一个闭环。例如，Bean A依赖Bean B，Bean B又依赖Bean A，这样就产生了循环依赖。</p>\n<h4>（2）循环依赖产生的原因</h4>\n<ul>\n  <li><strong>构造器注入</strong>：当使用构造器进行依赖注入时，如果两个或多个Bean的构造器相互引用，就会导致循环依赖。因为在创建Bean时，需要先实例化对象，而构造器注入要求在实例化时就完成依赖注入，这就会陷入死循环。</li>\n  <li><strong>属性注入</strong>：在属性注入时，如果多个Bean之间相互依赖，也可能产生循环依赖。不过Spring对单例Bean的属性注入循环依赖有一定的解决机制。</li>\n</ul>\n<h4>（3）Spring解决循环依赖的原理</h4>\n<p>Spring通过三级缓存来解决单例Bean的属性注入循环依赖问题：</p>\n<ul>\n  <li><strong>一级缓存（singletonObjects）</strong>：存储已经完全初始化好的单例Bean。</li>\n  <li><strong>二级缓存（singletonFactories）</strong>：存储单例Bean的工厂对象，用于提前暴露Bean的引用。</li>\n  <li><strong>三级缓存（earlySingletonObjects）</strong>：存储提前暴露的单例Bean的早期引用。</li>\n</ul>\n<p>当创建一个Bean时，会先将其对应的工厂对象放入三级缓存。如果其他Bean依赖该Bean，会从三级缓存获取其早期引用，避免了循环依赖问题。</p>\n<h4>（4）避免和解决循环依赖的方法</h4>\n<ul>\n  <li><strong>避免循环依赖</strong>\n    <ul>\n      <li><strong>重构代码</strong>：重新设计Bean之间的依赖关系，避免形成循环。可以通过引入中间层或调整业务逻辑来实现。</li>\n      <li><strong>使用接口和抽象类</strong>：通过接口和抽象类解耦Bean之间的依赖，减少直接依赖。</li>\n    </ul>\n  </li>\n  <li><strong>解决循环依赖</strong>\n    <ul>\n      <li><strong>使用setter方法注入</strong>：Spring对单例Bean的setter方法注入循环依赖有较好的解决机制。</li>\n      <li><strong>使用@Lazy注解</strong>：在依赖的Bean上使用@Lazy注解，延迟加载Bean，避免在创建时就进行依赖注入。</li>\n    </ul>\n  </li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\nclass BeanA {\n    private BeanB beanB;\n\n    @Autowired\n    public BeanA(BeanB beanB) {\n        this.beanB = beanB;\n    }\n}\n\n@Component\nclass BeanB {\n    private BeanA beanA;\n\n    @Autowired\n    public BeanB(BeanA beanA) {\n        this.beanA = beanA;\n    }\n}\n</code></pre>\n<p>上述代码使用构造器注入，会产生循环依赖。可以将构造器注入改为setter方法注入来解决：</p>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\nclass BeanA {\n    private BeanB beanB;\n\n    @Autowired\n    public void setBeanB(BeanB beanB) {\n        this.beanB = beanB;\n    }\n}\n\n@Component\nclass BeanB {\n    private BeanA beanA;\n\n    @Autowired\n    public void setBeanA(BeanA beanA) {\n        this.beanA = beanA;\n    }\n}\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）认为Spring能解决所有循环依赖</h4>\n<p>\n  误区：认为Spring可以解决所有类型的循环依赖。\n  纠正：Spring只能解决单例Bean的属性注入循环依赖，对于原型Bean和构造器注入的循环依赖无法解决。\n</p>\n<h4>（2）忽视循环依赖的危害</h4>\n<p>\n  误区：不重视循环依赖问题，认为不会影响系统正常运行。\n  纠正：循环依赖会导致项目启动失败或出现难以调试的问题，应尽量避免。\n</p>\n<h4>（3）滥用@Lazy注解</h4>\n<p>\n  误区：遇到循环依赖就使用@Lazy注解，而不考虑代码的设计问题。\n  纠正：@Lazy注解只是一种临时解决方案，应优先考虑重构代码，避免循环依赖。\n</p>\n<h3>6. 总结回答</h3>\n<p>“项目启动过程中的循环依赖指的是多个Bean之间相互依赖，形成一个闭环。它主要由构造器注入和属性注入时Bean之间的相互引用产生。</p>\n<p>Spring通过三级缓存机制解决单例Bean的属性注入循环依赖问题。但对于原型Bean和构造器注入的循环依赖无法解决。</p>\n<p>避免循环依赖可以通过重构代码、使用接口和抽象类解耦等方式。解决循环依赖可以使用setter方法注入或@Lazy注解。不过，应优先考虑避免循环依赖，因为它可能导致项目启动失败或出现难以调试的问题。同时，要注意Spring解决循环依赖的局限性，不能滥用@Lazy注解。”</p>","more_ask":"<ol>\n  <li>\n    <p>\n      <strong>三级缓存解决循环依赖时，每个缓存具体存储的是什么对象，为什么要这样设计？</strong>\n      提示：思考三级缓存各自的用途和存储对象的特点，以及这样分层存储对解决循环依赖的作用。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如果项目中存在多例Bean的循环依赖，Spring会如何处理，为什么不能像单例Bean那样解决？</strong>\n      提示：对比单例Bean和多例Bean的创建和管理机制，分析多例Bean循环依赖处理的难点。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在Spring Boot项目中，循环依赖的检测和解决机制有什么不同？</strong>\n      提示：考虑Spring Boot的自动配置、嵌入式容器等特性对循环依赖处理的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>当循环依赖涉及到AOP代理时，Spring是如何保证代理对象正确注入的？</strong>\n      提示：结合AOP的代理创建过程和循环依赖的解决流程，思考代理对象的注入时机和方式。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如果手动配置了Spring的BeanPostProcessor，这会对循环依赖的解决产生什么影响？</strong>\n      提示：分析BeanPostProcessor在Bean创建过程中的作用，以及它如何与循环依赖的解决机制相互作用。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在分布式系统中，多个Spring应用之间的循环依赖如何检测和解决？</strong>\n      提示：考虑分布式系统的网络通信、服务注册与发现等特点，思考如何检测和解决跨应用的循环依赖。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>Spring的循环依赖解决机制是否存在性能问题，如何优化？</strong>\n      提示：分析循环依赖解决过程中的操作和开销，思考可能的优化点。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如果循环依赖发生在不同的Spring上下文之间，会出现什么情况，如何解决？</strong>\n      提示：了解Spring上下文的层次结构和隔离性，思考不同上下文之间循环依赖的处理方式。\n    </p>\n  </li>\n</ol>","mindmap":"mindmap\n  root((循环依赖))\n    定义\n      多个 Bean 相互依赖成闭环\n      可能导致 Bean 创建死循环\n    产生原因\n      Spring 按依赖关系创建 Bean\n      示例：A 依赖 B，B 依赖 A 形成循环\n    避免方法\n      重构代码\n        优化设计解耦\n        引入中间层\n      使用依赖查找替代注入\n    解决方法\n      Spring 三级缓存机制\n        一级缓存（singletonObjects）\n        二级缓存（singletonFactories）\n        三级缓存（earlySingletonObjects）\n        示例流程\n      使用 @Lazy 注解\n        延迟 Bean 创建","keynote":"循环依赖定义：多个 Bean 相互依赖成闭环，可能致 Bean 创建死循环\n产生原因：Spring 按依赖关系创建 Bean，循环依赖会形成创建循环\n避免方法：重构代码解耦，使用依赖查找替代注入\n解决方法：Spring 三级缓存机制，使用 @Lazy 注解延迟 Bean 创建","group_id":17,"kps":["高级特性","框架中的设计模式"],"years":[2025,2024,2023,2022],"corps":["好未来","字节跳动","青岛小厂","思特奇（成都）","OPPO","用友","欢聚集团"]}}