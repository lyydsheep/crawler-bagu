{"success":true,"data":{"id":16908,"name":"<p>请说明@Transactional的失效场景和事务传播方式</p>","options":null,"answer":"<h3>@Transactional的失效场景</h3>\n<h4>1. 非public方法使用@Transactional</h4>\n<p>Spring AOP 基于代理模式实现事务管理，默认情况下，只有 public 方法才能被 Spring 代理增强，非 public 方法上使用 @Transactional 注解不会生效。</p>\n<pre><code class=\"language-java\">class Service {\n    // 该方法上的 @Transactional 不会生效\n    @Transactional\n    private void privateMethod() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<h4>2. 异常类型不匹配</h4>\n<p>@Transactional 默认只对 RuntimeException 及其子类和 Error 类型的异常进行回滚，如果抛出的是其他类型的异常，事务不会回滚。</p>\n<pre><code class=\"language-java\">@Service\npublic class UserService {\n    @Transactional\n    public void updateUser() throws Exception {\n        try {\n            // 业务逻辑\n            throw new Exception(\"自定义异常\");\n        } catch (Exception e) {\n            throw e;\n        }\n    }\n}\n</code></pre>\n<p>在上述代码中，抛出的是 Exception 异常，不是 RuntimeException 及其子类，事务不会回滚。可以通过设置 <code>rollbackFor</code> 属性来指定需要回滚的异常类型。</p>\n<pre><code class=\"language-java\">@Transactional(rollbackFor = Exception.class)\npublic void updateUser() throws Exception {\n    // 业务逻辑\n    throw new Exception(\"自定义异常\");\n}\n</code></pre>\n<h4>3. 同一类中方法调用</h4>\n<p>在同一个类中，一个非事务方法调用另一个有 @Transactional 注解的方法，事务不会生效。因为 Spring 是通过代理来实现事务管理的，同一类中的方法调用不会经过代理对象。</p>\n<pre><code class=\"language-java\">@Service\npublic class UserService {\n    public void nonTransactionalMethod() {\n        this.transactionalMethod();\n    }\n\n    @Transactional\n    public void transactionalMethod() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<h4>4. 数据库不支持事务</h4>\n<p>如果使用的数据库不支持事务，如 MySQL 的 MyISAM 存储引擎，即使使用了 @Transactional 注解，事务也不会生效。建议使用支持事务的存储引擎，如 InnoDB。</p>\n<h4>5. 未开启事务管理</h4>\n<p>在 Spring Boot 项目中，如果没有在主类上添加 <code>@EnableTransactionManagement</code> 注解，Spring 不会开启事务管理功能，@Transactional 注解也不会生效。</p>\n<pre><code class=\"language-java\">@SpringBootApplication\n@EnableTransactionManagement\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre>\n<h3>事务传播方式</h3>\n<h4>1. PROPAGATION_REQUIRED（默认）</h4>\n<p>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>\n<pre><code class=\"language-java\">@Service\npublic class ServiceA {\n    @Autowired\n    private ServiceB serviceB;\n\n    @Transactional\n    public void methodA() {\n        // 业务逻辑\n        serviceB.methodB();\n    }\n}\n\n@Service\npublic class ServiceB {\n    @Transactional(propagation = Propagation.REQUIRED)\n    public void methodB() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<p>在上述代码中，当 methodA 调用 methodB 时，methodB 会加入 methodA 的事务中。</p>\n<h4>2. PROPAGATION_SUPPORTS</h4>\n<p>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</p>\n<pre><code class=\"language-java\">@Service\npublic class ServiceC {\n    @Autowired\n    private ServiceD serviceD;\n\n    public void methodC() {\n        // 非事务方法\n        serviceD.methodD();\n    }\n}\n\n@Service\npublic class ServiceD {\n    @Transactional(propagation = Propagation.SUPPORTS)\n    public void methodD() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<p>在上述代码中，methodC 是非事务方法，调用 methodD 时，methodD 也会以非事务方式执行。</p>\n<h4>3. PROPAGATION_MANDATORY</h4>\n<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p>\n<pre><code class=\"language-java\">@Service\npublic class ServiceE {\n    @Autowired\n    private ServiceF serviceF;\n\n    public void methodE() {\n        // 非事务方法\n        try {\n            serviceF.methodF();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n@Service\npublic class ServiceF {\n    @Transactional(propagation = Propagation.MANDATORY)\n    public void methodF() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<p>在上述代码中，methodE 是非事务方法，调用 methodF 时会抛出异常。</p>\n<h4>4. PROPAGATION_REQUIRES_NEW</h4>\n<p>无论当前是否存在事务，都会创建一个新的事务。如果当前存在事务，则将当前事务挂起。</p>\n<pre><code class=\"language-java\">@Service\npublic class ServiceG {\n    @Autowired\n    private ServiceH serviceH;\n\n    @Transactional\n    public void methodG() {\n        // 业务逻辑\n        try {\n            serviceH.methodH();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n@Service\npublic class ServiceH {\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void methodH() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<p>在上述代码中，methodG 有事务，调用 methodH 时，methodH 会创建一个新的事务，并且 methodG 的事务会被挂起。</p>\n<h4>5. PROPAGATION_NOT_SUPPORTED</h4>\n<p>以非事务方式执行操作，如果当前存在事务，则将当前事务挂起。</p>\n<pre><code class=\"language-java\">@Service\npublic class ServiceI {\n    @Autowired\n    private ServiceJ serviceJ;\n\n    @Transactional\n    public void methodI() {\n        // 业务逻辑\n        serviceJ.methodJ();\n    }\n}\n\n@Service\npublic class ServiceJ {\n    @Transactional(propagation = Propagation.NOT_SUPPORTED)\n    public void methodJ() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<p>在上述代码中，methodI 有事务，调用 methodJ 时，methodJ 会以非事务方式执行，并且 methodI 的事务会被挂起。</p>\n<h4>6. PROPAGATION_NEVER</h4>\n<p>以非事务方式执行，如果当前存在事务，则抛出异常。</p>\n<pre><code class=\"language-java\">@Service\npublic class ServiceK {\n    @Autowired\n    private ServiceL serviceL;\n\n    @Transactional\n    public void methodK() {\n        // 业务逻辑\n        try {\n            serviceL.methodL();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n@Service\npublic class ServiceL {\n    @Transactional(propagation = Propagation.NEVER)\n    public void methodL() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<p>在上述代码中，methodK 有事务，调用 methodL 时会抛出异常。</p>\n<h4>7. PROPAGATION_NESTED</h4>\n<p>如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则创建一个新的事务。嵌套事务是外部事务的一部分，外部事务回滚时，嵌套事务也会回滚，但嵌套事务回滚不会影响外部事务。</p>\n<pre><code class=\"language-java\">@Service\npublic class ServiceM {\n    @Autowired\n    private ServiceN serviceN;\n\n    @Transactional\n    public void methodM() {\n        // 业务逻辑\n        try {\n            serviceN.methodN();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n@Service\npublic class ServiceN {\n    @Transactional(propagation = Propagation.NESTED)\n    public void methodN() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<p>在上述代码中，methodM 有事务，调用 methodN 时，methodN 会在嵌套事务内执行。</p>","type":6,"level":2,"freq":0.03512881,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：说明<code>@Transactional</code>的失效场景和事务传播方式。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对<code>@Transactional</code>注解在Spring框架中使用的理解。</li>\n      <li>事务失效的原因及场景。</li>\n      <li>事务传播方式的种类和作用。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）<code>@Transactional</code>注解</h4>\n<p><code>@Transactional</code>是Spring框架提供的用于管理事务的注解，可用于类或方法上，能简化事务管理代码。</p>\n<h4>（2）事务传播</h4>\n<p>事务传播定义了多个事务方法相互调用时，事务如何在这些方法间传播，即一个事务方法调用另一个事务方法时，新事务如何开启、与原事务如何关联等。</p>\n<h3>3. 解析</h3>\n<h4>（1）<code>@Transactional</code>失效场景</h4>\n<ul>\n  <li><strong>非public方法使用</strong>：Spring通过AOP代理实现事务管理，默认只对public方法生效。非public方法使用<code>@Transactional</code>注解，事务不会生效。</li>\n  <li><strong>异常类型不匹配</strong>：<code>@Transactional</code>默认只对<code>RuntimeException</code>和<code>Error</code>类型的异常回滚。若抛出的是其他类型异常，且未指定<code>rollbackFor</code>属性，事务不会回滚。</li>\n  <li><strong>自调用问题</strong>：同一个类中，一个非事务方法调用另一个有<code>@Transactional</code>注解的方法，事务会失效。因为Spring AOP是基于代理模式，自调用时不会经过代理对象，事务注解不生效。</li>\n  <li><strong>数据库不支持事务</strong>：如使用MySQL的MyISAM存储引擎，它不支持事务，即使使用<code>@Transactional</code>注解，事务也不会生效。</li>\n  <li><strong>未开启事务管理</strong>：在Spring配置中，若未开启事务管理功能，<code>@Transactional</code>注解不会起作用。例如，在Spring Boot中未添加<code>@EnableTransactionManagement</code>注解。</li>\n</ul>\n<h4>（2）事务传播方式</h4>\n<ul>\n  <li><strong>PROPAGATION_REQUIRED（默认）</strong>：如果当前存在事务，就加入该事务；如果当前没有事务，就创建一个新事务。</li>\n  <li><strong>PROPAGATION_SUPPORTS</strong>：如果当前存在事务，就加入该事务；如果当前没有事务，就以非事务方式执行。</li>\n  <li><strong>PROPAGATION_MANDATORY</strong>：如果当前存在事务，就加入该事务；如果当前没有事务，就抛出异常。</li>\n  <li><strong>PROPAGATION_REQUIRES_NEW</strong>：无论当前是否存在事务，都会创建一个新事务，原事务挂起，新事务执行完后，原事务继续执行。</li>\n  <li><strong>PROPAGATION_NOT_SUPPORTED</strong>：以非事务方式执行，如果当前存在事务，就将当前事务挂起。</li>\n  <li><strong>PROPAGATION_NEVER</strong>：以非事务方式执行，如果当前存在事务，就抛出异常。</li>\n  <li><strong>PROPAGATION_NESTED</strong>：如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，就创建一个新事务。嵌套事务是外部事务的子事务，有独立的回滚点，外部事务回滚会导致嵌套事务回滚，但嵌套事务回滚不会影响外部事务。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<h4>（1）自调用问题示例</h4>\n<pre><code class=\"language-java\">@Service\npublic class UserService {\n\n    public void nonTransactionalMethod() {\n        // 自调用\n        this.transactionalMethod();\n    }\n\n    @Transactional\n    public void transactionalMethod() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<p>在上述代码中，<code>nonTransactionalMethod</code>调用<code>transactionalMethod</code>，事务会失效。</p>\n<h4>（2）事务传播方式示例</h4>\n<pre><code class=\"language-java\">@Service\npublic class OrderService {\n\n    @Transactional(propagation = Propagation.REQUIRED)\n    public void methodA() {\n        // 业务逻辑\n        methodB();\n    }\n\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void methodB() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<p>在<code>methodA</code>中调用<code>methodB</code>，<code>methodB</code>会创建一个新事务，<code>methodA</code>的事务会挂起。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）忽略方法访问修饰符</h4>\n<p>只关注注解使用，忽略方法必须是public的要求，导致事务失效。</p>\n<h4>（2）异常处理不当</h4>\n<p>不清楚<code>@Transactional</code>默认的回滚异常类型，未正确指定<code>rollbackFor</code>属性，造成事务不回滚。</p>\n<h4>（3）混淆事务传播方式</h4>\n<p>对不同事务传播方式的作用理解不清晰，在实际使用中选择错误的传播方式。</p>\n<h3>6. 总结回答</h3>\n<p><code>@Transactional</code>的失效场景主要有：非public方法使用该注解、异常类型不匹配（未指定<code>rollbackFor</code>）、自调用问题、数据库不支持事务以及未开启事务管理。</p>\n<p>事务传播方式有七种：</p>\n<ul>\n  <li><code>PROPAGATION_REQUIRED</code>：默认方式，有事务则加入，无事务则创建新事务。</li>\n  <li><code>PROPAGATION_SUPPORTS</code>：有事务则加入，无事务则非事务执行。</li>\n  <li><code>PROPAGATION_MANDATORY</code>：有事务则加入，无事务则抛异常。</li>\n  <li><code>PROPAGATION_REQUIRES_NEW</code>：无论有无事务，都创建新事务，原事务挂起。</li>\n  <li><code>PROPAGATION_NOT_SUPPORTED</code>：非事务执行，有事务则挂起。</li>\n  <li><code>PROPAGATION_NEVER</code>：非事务执行，有事务则抛异常。</li>\n  <li><code>PROPAGATION_NESTED</code>：有事务则在嵌套事务内执行，无事务则创建新事务。</li>\n</ul>\n<p>在使用<code>@Transactional</code>时，要注意方法访问修饰符、异常处理和事务传播方式的选择，避免事务失效问题。</p>","more_ask":"<h3>关于 @Transactional 失效场景</h3>\n<ol>\n  <li>\n    <strong>私有方法使用 @Transactional 失效，那受保护方法呢？</strong>\n    提示：思考受保护方法的访问权限范围以及 Spring AOP 对不同访问权限方法的代理机制。\n  </li>\n  <li>\n    <strong>在同一个类中，非事务方法调用事务方法，事务失效，如何解决这个问题？</strong>\n    提示：考虑 Spring 代理机制的原理，以及如何绕过同一个类中方法调用不经过代理的问题。\n  </li>\n  <li>\n    <strong>数据库引擎不支持事务，除了 MySQL 的 MyISAM 还有哪些常见情况会导致这种问题？</strong>\n    提示：了解不同数据库的不同存储引擎及其对事务的支持情况。\n  </li>\n</ol>\n<h3>关于事务传播方式</h3>\n<ol>\n  <li>\n    <strong>在 REQUIRES_NEW 传播行为下，如果内层事务抛出异常回滚，外层事务会怎样？</strong>\n    提示：结合 REQUIRES_NEW 传播行为的特点，分析内层事务和外层事务的独立性。\n  </li>\n  <li>\n    <strong>NESTED 传播行为和 REQUIRES_NEW 传播行为在回滚时有什么本质区别？</strong>\n    提示：从事务的嵌套关系、保存点机制以及对外部事务的影响等方面思考。\n  </li>\n  <li>\n    <strong>如果一个方法的事务传播行为设置为 SUPPORTS，在没有事务的环境下调用它，会有什么性能影响？</strong>\n    提示：考虑 SUPPORTS 传播行为的特性以及数据库在无事务和有事务环境下的操作差异。\n  </li>\n</ol>","mindmap":"mindmap\n  root((@Transactional相关内容))\n    @Transactional的失效场景\n      非public方法使用\n      异常类型不匹配\n      同一类中方法调用\n      数据库不支持事务\n      未开启事务管理\n    事务传播方式\n      PROPAGATION_REQUIRED（默认）\n      PROPAGATION_SUPPORTS\n      PROPAGATION_MANDATORY\n      PROPAGATION_REQUIRES_NEW\n      PROPAGATION_NOT_SUPPORTED\n      PROPAGATION_NEVER\n      PROPAGATION_NESTED","keynote":"@Transactional失效场景：\n- 非public方法使用，Spring AOP默认只增强public方法\n- 异常类型不匹配，默认只对RuntimeException及其子类和Error回滚，可设rollbackFor指定\n- 同一类中方法调用，不经过代理对象\n- 数据库不支持事务，如MyISAM，建议用InnoDB\n- 未开启事务管理，Spring Boot主类需加@EnableTransactionManagement\n\n事务传播方式：\n- PROPAGATION_REQUIRED：有事务加入，无则创建\n- PROPAGATION_SUPPORTS：有事务加入，无则非事务执行\n- PROPAGATION_MANDATORY：有事务加入，无则抛异常\n- PROPAGATION_REQUIRES_NEW：无论有无事务都创建新事务，挂起当前事务\n- PROPAGATION_NOT_SUPPORTED：非事务执行，挂起当前事务\n- PROPAGATION_NEVER：非事务执行，有事务抛异常\n- PROPAGATION_NESTED：有事务在嵌套事务内执行，无则创建新事务，外部回滚嵌套回滚，嵌套回滚不影响外部","group_id":17,"kps":["事务管理"],"years":[2025,2024,2023,2022],"corps":["杭州中小厂","字节跳动","上海丰益信息","腾讯云智","京东","算力大陆","TikTok","唯品会","小米","卓望","4399","某游戏中厂","网易","理想","美团","收钱吧","淘天集团","杭州阿信网络科技","百度","快手","滴滴","贝壳","用友","去哪儿旅行","微众银行","浩鲸科技","B站","深圳某医疗公司","顺丰"]}}