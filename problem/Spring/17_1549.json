{
  "success": true,
  "data": {
    "id": 1549,
    "name": "<p>JDK动态代理和CGLIB动态代理的区别？</p>",
    "options": null,
    "answer": "<p>在Spring中，JDK动态代理和CGLIB（Code Generation Library）动态代理是实现AOP（面向切面编程）的两种主要方式。它们之间有几个关键的区别：</p>\n<h3>1. <strong>代理方式</strong>：</h3>\n<ul>\n  <li><strong>JDK动态代理</strong>：基于接口的代理，只能为实现了接口的类创建代理对象。使用<code>java.lang.reflect.Proxy</code>类来生成代理。</li>\n  <li><strong>CGLIB动态代理</strong>：基于类的代理，可以直接对类进行代理，不需要实现接口。CGLIB使用字节码生成库（如ASM）动态生成代理类。</li>\n</ul>\n<h3>2. <strong>性能</strong>：</h3>\n<ul>\n  <li><strong>JDK动态代理</strong>：由于需要通过接口进行调用，性能略低，但一般情况下足够满足需求。</li>\n  <li><strong>CGLIB动态代理</strong>：因为是直接生成子类代理，通常在性能上稍优于JDK动态代理，尤其是在调用频繁的场景中。</li>\n</ul>\n<h3>3. <strong>使用场景</strong>：</h3>\n<ul>\n  <li><strong>JDK动态代理</strong>：当目标对象实现了一个或多个接口时，推荐使用JDK动态代理。</li>\n  <li><strong>CGLIB动态代理</strong>：当目标对象没有实现接口或者当代理方法不在接口上时，可以采用CGLIB。</li>\n</ul>\n<h3>4. <strong>织入方式</strong>：</h3>\n<ul>\n  <li><strong>JDK动态代理</strong>：通过方法拦截器（<code>InvocationHandler</code>）方式实现方法调用前后的操作。</li>\n  <li><strong>CGLIB动态代理</strong>：通过子类的方式，可以重写目标方法，直接在目标方法上进行织入。</li>\n</ul>\n<h3>5. <strong>限制</strong>：</h3>\n<ul>\n  <li><strong>JDK动态代理</strong>：不能代理没有实现接口的类。</li>\n  <li><strong>CGLIB动态代理</strong>：不能对<code>final</code>类和<code>final</code>方法进行代理，因为这些类和方法不能被继承和重写。</li>\n</ul>\n<h3>6. <strong>配置方式</strong>：</h3>\n<p>在Spring中，选择使用哪种代理方式可以通过配置来控制：</p>\n<ul>\n  <li>如果类实现了接口，Spring默认使用JDK动态代理。</li>\n  <li>如果没有接口，Spring会自动使用CGLIB。</li>\n</ul>\n<h3>总结</h3>\n<p>选择哪种代理方式取决于具体需求和场景。如果目标类实现了接口，可以优先选择JDK动态代理；如果需要对具体类进行代理，或者目标类没有实现接口，则使用CGLIB。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.007025761,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：JDK动态代理和CGLIB动态代理的区别是什么？</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对JDK动态代理和CGLIB动态代理原理的理解。</li>\n      <li>两种代理方式的使用场景差异。</li>\n      <li>两种代理方式在性能、功能等方面的不同表现。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）动态代理的概念</h4>\n<p>动态代理是一种在运行时创建代理对象的机制，通过代理对象可以在不修改目标对象代码的情况下，对目标对象的方法进行增强，常用于AOP（面向切面编程）等场景。</p>\n<h4>（2）JDK动态代理</h4>\n<p>JDK动态代理是Java原生提供的动态代理机制，它基于接口实现。代理对象需要实现和目标对象相同的接口，通过<code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口来创建和管理代理对象。</p>\n<h4>（3）CGLIB动态代理</h4>\n<p>CGLIB（Code Generation Library）是一个强大的、高性能的代码生成库，它可以在运行时扩展Java类与实现Java接口。CGLIB动态代理基于继承机制，通过生成目标类的子类来实现代理。</p>\n<h3>3. 解析</h3>\n<h4>（1）代理机制不同</h4>\n<ul>\n  <li><strong>JDK动态代理</strong>：基于接口。目标对象必须实现至少一个接口，代理对象会实现相同的接口，通过反射调用目标对象的方法。</li>\n  <li><strong>CGLIB动态代理</strong>：基于继承。代理对象是目标类的子类，通过重写目标类的方法来实现代理逻辑。</li>\n</ul>\n<h4>（2）使用场景不同</h4>\n<ul>\n  <li><strong>JDK动态代理</strong>：适用于目标对象实现了接口的情况。在Spring中，如果目标对象实现了接口，默认会使用JDK动态代理。</li>\n  <li><strong>CGLIB动态代理</strong>：适用于目标对象没有实现接口的情况。在Spring中，如果目标对象没有实现接口，会使用CGLIB动态代理；也可以通过配置强制使用CGLIB动态代理。</li>\n</ul>\n<h4>（3）性能表现不同</h4>\n<ul>\n  <li><strong>JDK动态代理</strong>：创建代理对象的速度相对较快，但在调用方法时，由于使用反射机制，性能会稍低一些，尤其是在频繁调用的场景下。</li>\n  <li><strong>CGLIB动态代理</strong>：创建代理对象的速度相对较慢，因为需要生成子类字节码，但在方法调用时性能较高，因为它是通过继承和方法重写实现的，避免了反射调用的开销。</li>\n</ul>\n<h4>（4）功能限制不同</h4>\n<ul>\n  <li><strong>JDK动态代理</strong>：只能代理实现了接口的类，无法代理没有实现接口的类。</li>\n  <li><strong>CGLIB动态代理</strong>：不能代理被<code>final</code>修饰的类和方法，因为<code>final</code>类和方法不能被继承和重写。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<h4>（1）JDK动态代理示例</h4>\n<pre><code class=\"language-java\">import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\n// 定义接口\ninterface Subject {\n    void request();\n}\n\n// 实现接口的目标类\nclass RealSubject implements Subject {\n    @Override\n    public void request() {\n        System.out.println(\"RealSubject: Handling request.\");\n    }\n}\n\n// 实现InvocationHandler接口\nclass JdkProxyHandler implements InvocationHandler {\n    private final Object target;\n\n    public JdkProxyHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"Before method call\");\n        Object result = method.invoke(target, args);\n        System.out.println(\"After method call\");\n        return result;\n    }\n}\n\npublic class JdkProxyExample {\n    public static void main(String[] args) {\n        RealSubject realSubject = new RealSubject();\n        JdkProxyHandler handler = new JdkProxyHandler(realSubject);\n        Subject proxy = (Subject) Proxy.newProxyInstance(\n                Subject.class.getClassLoader(),\n                new Class&#x3C;?>[]{Subject.class},\n                handler\n        );\n        proxy.request();\n    }\n}\n</code></pre>\n<h4>（2）CGLIB动态代理示例</h4>\n<pre><code class=\"language-java\">import net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\n// 目标类\nclass TargetClass {\n    public void doSomething() {\n        System.out.println(\"TargetClass: Doing something.\");\n    }\n}\n\n// 实现MethodInterceptor接口\nclass CglibProxyInterceptor implements MethodInterceptor {\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\"Before method call\");\n        Object result = proxy.invokeSuper(obj, args);\n        System.out.println(\"After method call\");\n        return result;\n    }\n}\n\npublic class CglibProxyExample {\n    public static void main(String[] args) {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(TargetClass.class);\n        enhancer.setCallback(new CglibProxyInterceptor());\n        TargetClass proxy = (TargetClass) enhancer.create();\n        proxy.doSomething();\n    }\n}\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）认为两种代理方式可以随意互换</h4>\n<ul>\n  <li>误区：不考虑目标对象是否实现接口，随意选择代理方式。</li>\n  <li>纠正：根据目标对象是否实现接口来选择合适的代理方式，目标对象实现了接口优先考虑JDK动态代理，未实现接口则使用CGLIB动态代理。</li>\n</ul>\n<h4>（2）忽视CGLIB的功能限制</h4>\n<ul>\n  <li>误区：使用CGLIB代理<code>final</code>类或<code>final</code>方法。</li>\n  <li>纠正：CGLIB不能代理<code>final</code>类和<code>final</code>方法，遇到这种情况应考虑其他解决方案。</li>\n</ul>\n<h4>（3）只关注性能不考虑使用场景</h4>\n<ul>\n  <li>误区：只根据性能选择代理方式，不考虑目标对象的结构。</li>\n  <li>纠正：要综合考虑目标对象的结构和使用场景，在不同场景下选择合适的代理方式。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>JDK动态代理和CGLIB动态代理存在多方面区别。从代理机制看，JDK动态代理基于接口，目标对象需实现接口，代理对象实现相同接口；CGLIB动态代理基于继承，代理对象是目标类的子类。使用场景上，JDK动态代理适用于目标对象实现接口的情况，Spring默认采用；CGLIB动态代理适用于目标对象未实现接口的情况，也可配置强制使用。性能方面，JDK动态代理创建代理对象快，但方法调用因反射性能稍低；CGLIB动态代理创建慢，但方法调用性能高。功能限制上，JDK动态代理只能代理实现接口的类，CGLIB不能代理<code>final</code>类和方法。</p>\n<p>因此，在实际应用中，应根据目标对象的结构和使用场景选择合适的代理方式。如果目标对象实现了接口，优先考虑JDK动态代理；如果目标对象未实现接口，则使用CGLIB动态代理。同时，也要注意CGLIB的功能限制。</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>请解释Spring中的AOP（面向切面编程）的基本概念。</strong></p>\n    <ul>\n      <li>提示：想想AOP的核心组件和用法。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在使用JDK动态代理时，代理类要求实现哪些条件？</strong></p>\n    <ul>\n      <li>提示：考虑代理目标类的接口和实现。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>CGLIB动态代理是如何实现的？它与JDK动态代理的内部机制有什么不同？</strong></p>\n    <ul>\n      <li>提示：探讨字节码生成和类继承的方法。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在什么情况下会选择CGLIB而不是JDK动态代理？</strong></p>\n    <ul>\n      <li>提示：考虑到代理目标类的特性和接口实现。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何处理动态代理中的方法调用顺序问题？</strong></p>\n    <ul>\n      <li>提示：想一下切面和连接点的概念。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>谈谈Spring中的@Aspect注解的使用。</strong></p>\n    <ul>\n      <li>提示：考虑AOP的切面定义和应用场景。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何解决因动态代理带来的性能问题？</strong></p>\n    <ul>\n      <li>提示：考虑代理的开销以及如何择优选择代理方式。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在多线程环境中，使用动态代理时可能会遇到哪些问题？</strong></p>\n    <ul>\n      <li>提示：讨论线程安全和共享资源的问题。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如果你想给某个方法添加多个切面，应该如何处理？</strong></p>\n    <ul>\n      <li>提示：考虑切面的执行顺序和优先级。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>请解释ProxyFactoryBean和AspectJ的区别。</strong></p>\n    <ul>\n      <li>提示：比较使用场景和性能等方面的差异。</li>\n    </ul>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Spring AOP代理方式))\n    JDK动态代理\n      基于接口的代理\n      使用java.lang.reflect.Proxy生成代理\n      性能略低但足够满足需求\n      推荐用于实现了一个或多个接口的目标对象\n      通过方法拦截器(InvocationHandler)实现织入\n      不能代理没有实现接口的类\n    CGLIB动态代理\n      基于类的代理\n      直接对类进行代理无需实现接口\n      使用字节码生成库如ASM生成代理\n      性能通常优于JDK动态代理\n      适用于没有实现接口或者代理方法不在接口上的目标对象\n      通过子类方式重写目标方法进行织入\n      不能代理final类和final方法\n    选择依据\n      实现了接口->优先使用JDK\n      需要对具体类代理或无接口->使用CGLIB",
    "keynote": "- Spring AOP主要使用JDK动态代理和CGLIB动态代理。\n- JDK动态代理基于接口，需要目标对象实现至少一个接口；性能较低但一般足够；通过`InvocationHandler`实现织入。\n- CGLIB动态代理基于类，直接对类生成代理；不需要目标对象实现接口；性能较好；通过生成子类的方式实现织入。\n- JDK动态代理无法处理未实现任何接口的类；CGLIB不能代理final修饰的类或方法。\n- 在Spring中，默认为实现了接口的类使用JDK动态代理，对于没有实现接口的情况自动切换至CGLIB。",
    "group_id": 17,
    "kps": [
      "高级特性",
      "控制反转（IoC）与依赖注入（DI）"
    ],
    "years": [
      2024,
      2023,
      2022
    ],
    "corps": [
      "美团",
      "合思",
      "快手",
      "联想集团",
      "用友",
      "百度",
      "中国移动",
      "腾讯"
    ]
  }
}