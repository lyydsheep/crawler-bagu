{"success":true,"data":{"id":3383,"name":"<p>Spring 是如何解决循环依赖的?</p>","options":null,"answer":"<p>在Spring框架中，循环依赖问题主要发生在单例bean（singleton beans）之间。当两个bean互相依赖时，Spring通过以下两种机制来解决这个问题：</p>\n<ol>\n  <li>\n    <p>\n      <strong>三级缓存机制</strong>：\n      Spring使用了一个三级缓存（也称为早期引用，early reference）来解决循环依赖问题。具体步骤如下：\n    </p>\n    <ul>\n      <li><strong>第一级缓存</strong>：用来存储已完成初始化的bean。</li>\n      <li><strong>第二级缓存</strong>：用于存储正在创建中的bean，以便在循环依赖发生时，可以提供早期引用。</li>\n      <li><strong>第三方缓存</strong>：主要存储已经实例化但尚未完全初始化的bean的引用。</li>\n    </ul>\n    <p>当一个bean正在被创建时，它会被放入第二级缓存中。如果在创建过程中需要另一个bean（且这个bean尚未被创建），Spring会从第二级缓存中获取这个bean的早期引用，这样就可以打破循环依赖。</p>\n  </li>\n  <li>\n    <p><strong>构造注入 versus Setter注入</strong>：</p>\n    <ul>\n      <li><strong>构造注入</strong>：这种方式在创建bean时就需要所有依赖项，因此如果出现循环依赖，在创建过程中会导致异常。</li>\n      <li><strong>Setter注入</strong>：Setter注入可以在bean实例化后再注入依赖，允许轮询中的某个bean先实例化，然后再通过setter方法注入依赖项，因此在处理循环依赖时更加灵活。</li>\n    </ul>\n  </li>\n</ol>\n<h3>总结</h3>\n<p>Spring通过三级缓存机制和注入方式的选择（构造注入与Setter注入）来解决循环依赖问题。具体使用时，通常推荐使用Setter注入来避免因构造注入而导致的循环依赖问题。</p>","type":6,"level":2,"freq":0.05074161,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Spring 是如何解决循环依赖的。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对 Spring 容器创建 Bean 流程的理解。</li>\n      <li>三级缓存的概念及作用。</li>\n      <li>循环依赖产生的原因。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）循环依赖的产生</h4>\n<p>当两个或多个 Bean 之间相互依赖，形成一个闭环时，就会产生循环依赖。例如，Bean A 依赖 Bean B，而 Bean B 又依赖 Bean A。如果没有合适的解决方案，创建 Bean 的过程会陷入无限循环。</p>\n<h4>（2）Spring 创建 Bean 的基本流程</h4>\n<p>大致包括实例化（创建对象）、属性填充（注入依赖）、初始化（调用初始化方法）等步骤。</p>\n<h4>（3）三级缓存</h4>\n<p>Spring 中使用了三级缓存来解决循环依赖问题，具体如下：</p>\n<ul>\n  <li><code>singletonObjects</code>：一级缓存，用于存放完全初始化好的单例 Bean。</li>\n  <li><code>singletonFactories</code>：三级缓存，存放创建 Bean 的工厂对象，用于解决循环依赖。</li>\n  <li><code>earlySingletonObjects</code>：二级缓存，存放提前曝光的 Bean，即已经实例化但还未完成属性填充和初始化的 Bean。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）解决循环依赖的过程</h4>\n<p>假设存在 Bean A 和 Bean B 相互依赖。</p>\n<ul>\n  <li><strong>创建 Bean A</strong>：\n    <ul>\n      <li>实例化 Bean A，将 Bean A 的工厂对象放入三级缓存 <code>singletonFactories</code> 中。此时 Bean A 处于提前曝光状态。</li>\n      <li>进行属性填充，发现需要注入 Bean B。</li>\n    </ul>\n  </li>\n  <li><strong>创建 Bean B</strong>：\n    <ul>\n      <li>实例化 Bean B，将 Bean B 的工厂对象放入三级缓存 <code>singletonFactories</code> 中。</li>\n      <li>进行属性填充，发现需要注入 Bean A。</li>\n      <li>从三级缓存 <code>singletonFactories</code> 中获取 Bean A 的工厂对象，通过工厂对象创建一个提前曝光的 Bean A 实例，将其放入二级缓存 <code>earlySingletonObjects</code> 中，并从三级缓存移除。</li>\n      <li>将提前曝光的 Bean A 实例注入到 Bean B 中。</li>\n      <li>完成 Bean B 的属性填充和初始化，将 Bean B 放入一级缓存 <code>singletonObjects</code> 中。</li>\n    </ul>\n  </li>\n  <li><strong>继续完成 Bean A</strong>：\n    <ul>\n      <li>由于 Bean B 已经创建完成，将 Bean B 注入到 Bean A 中。</li>\n      <li>完成 Bean A 的属性填充和初始化，将 Bean A 从二级缓存移除，放入一级缓存 <code>singletonObjects</code> 中。</li>\n    </ul>\n  </li>\n</ul>\n<h4>（2）三级缓存的作用</h4>\n<ul>\n  <li><strong>三级缓存 <code>singletonFactories</code></strong>：在 Bean 实例化后，将其工厂对象放入该缓存，主要用于提前曝光 Bean，以便在其他 Bean 依赖它时可以获取到一个提前创建的实例。</li>\n  <li><strong>二级缓存 <code>earlySingletonObjects</code></strong>：当从三级缓存获取 Bean 工厂对象并创建提前曝光的 Bean 后，将其放入二级缓存，避免重复创建。</li>\n  <li><strong>一级缓存 <code>singletonObjects</code></strong>：存放完全初始化好的单例 Bean，是最终使用的 Bean 缓存。</li>\n</ul>\n<h4>（3）局限性</h4>\n<p>Spring 只能解决单例 Bean 的循环依赖，对于原型 Bean（每次请求都创建新实例）和 <code>@Scope(\"prototype\")</code> 的 Bean，无法解决循环依赖问题，因为 Spring 不会对原型 Bean 进行缓存。</p>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">@Component\npublic class BeanA {\n    @Autowired\n    private BeanB beanB;\n\n    // Getters and Setters\n}\n\n@Component\npublic class BeanB {\n    @Autowired\n    private BeanA beanA;\n\n    // Getters and Setters\n}\n</code></pre>\n<p>在 Spring 配置类上添加 <code>@ComponentScan</code> 注解来扫描上述组件。当 Spring 容器启动时，会自动创建 Bean A 和 Bean B，并利用三级缓存解决它们之间的循环依赖问题。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）认为 Spring 能解决所有类型 Bean 的循环依赖</h4>\n<ul>\n  <li>误区：认为 Spring 对所有作用域的 Bean 都能解决循环依赖。</li>\n  <li>纠正：Spring 只能解决单例 Bean 的循环依赖，对于原型 Bean 无法解决。</li>\n</ul>\n<h4>（2）混淆三级缓存的作用</h4>\n<ul>\n  <li>误区：不清楚三级缓存各自的作用和使用顺序。</li>\n  <li>纠正：明确三级缓存分别用于存放不同状态的 Bean，三级缓存用于提前曝光，二级缓存用于避免重复创建，一级缓存存放最终的 Bean。</li>\n</ul>\n<h4>（3）忽视 Bean 创建流程</h4>\n<ul>\n  <li>误区：只关注缓存，忽略了 Bean 实例化、属性填充和初始化的流程。</li>\n  <li>纠正：理解 Bean 创建流程与三级缓存的配合，才能真正理解 Spring 解决循环依赖的原理。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>Spring 通过三级缓存来解决单例 Bean 的循环依赖问题。当创建一个 Bean 时，在实例化后会将其工厂对象放入三级缓存 <code>singletonFactories</code> 中进行提前曝光。在属性填充时，如果发现依赖的 Bean 正在创建中，会从三级缓存获取其工厂对象创建一个提前曝光的实例，放入二级缓存 <code>earlySingletonObjects</code> 中，并完成依赖注入。最后，将完全初始化好的 Bean 放入一级缓存 <code>singletonObjects</code> 中。</p>\n<p>需要注意的是，Spring 只能解决单例 Bean 的循环依赖，对于原型 Bean 无法解决。因为原型 Bean 每次请求都创建新实例，Spring 不会对其进行缓存。</p>","more_ask":"<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>你能具体描述一下Spring中的工作模式吗？</strong></p>\n    <ul>\n      <li>提示：关注Spring的容器的生命周期和Bean的创建方式。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在什么情况下会导致循环依赖的发生？</strong></p>\n    <ul>\n      <li>提示：考虑不同的Bean之间的依赖关系和作用域。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>Spring如何处理原型Bean和单例Bean之间的循环依赖？</strong></p>\n    <ul>\n      <li>提示：考虑要点包括初始化时机和对象的创建过程。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>除了循环依赖，Spring还有哪些默默解决的依赖注入问题？</strong></p>\n    <ul>\n      <li>提示：考虑如依赖注入的Bean未找到、Bean的创建顺序等。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>请讲解一下Spring中的BeanFactory和ApplicationContext之间的区别？</strong></p>\n    <ul>\n      <li>提示：关注两者的功能、特性和适用场景。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>Spring是如何支持不同类型的依赖注入的（构造器注入、Setter注入等）？</strong></p>\n    <ul>\n      <li>提示：讨论各自的优缺点及适用场景。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你知道Spring的@Lazy注解吗？它如何帮助解决循环依赖的问题？</strong></p>\n    <ul>\n      <li>提示：了解@Lazy的使用场景和效果。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>请解释一下Spring的AOP（面向切面编程）以及它与依赖注入的关系。</strong></p>\n    <ul>\n      <li>提示：考虑AOP如何影响Bean的初始化和依赖注入。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在开发中，如何检测和避免循环依赖的问题？</strong></p>\n    <ul>\n      <li>提示：考虑设计模式、架构原则等方面的预防措施。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>可否分享一个你在项目中遇到的实际循环依赖问题及解决方案？</strong></p>\n    <ul>\n      <li>提示：关注具体的场景、分析过程及最终解决的方式。</li>\n    </ul>\n  </li>\n</ol>","mindmap":"mindmap\n  root((Spring循环依赖解决方案))\n    三级缓存机制\n      第一级缓存\n      第二级缓存\n      第三方缓存\n    构造注入 versus Setter注入\n      构造注入\n      Setter注入","keynote":"- 循环依赖主要发生在单例bean之间。\n- Spring使用三级缓存解决循环依赖问题。\n- 第一级缓存存储已完成初始化的bean。\n- 第二级缓存用于存储正在创建中的bean，提供早期引用。\n- 第三方缓存存储已实例化但未完全初始化的bean。\n- 构造注入要求在创建bean时所有依赖项都准备好，容易导致异常。\n- Setter注入允许先实例化bean后注入依赖，更灵活地处理循环依赖。\n- 推荐使用Setter注入避免构造注入带来的循环依赖问题。","group_id":17,"kps":["容器","框架中的设计模式"],"years":[2025,2024,2023,2022],"corps":["字节跳动","上海丰益信息","数字马力","百度","合肥科大国创","美团优选","京东","中科全安","小米","滴滴","盛趣游戏","米哈游","收钱吧","曹操出行","58同城","美团","阿里巴巴","快手","科大讯飞","好未来","联想集团","钉钉","中兴通讯","贝壳","浙江大华","大华","B站","用友","恒生电子","同程旅行","货拉拉","深圳市优必选科技","闪送科技","携程","腾讯云"]}}