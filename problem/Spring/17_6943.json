{
  "success": true,
  "data": {
    "id": 6943,
    "name": "<p>Spring是如何解决Bean的循环依赖？</p>",
    "options": null,
    "answer": "<p>Spring 框架通过以下几种方式解决 Bean 的循环依赖问题：</p>\n<ol>\n  <li>\n    <p><strong>构造器注入 vs. Setter 注入</strong>：</p>\n    <ul>\n      <li><strong>构造器注入</strong>：如果两个 Bean 之间存在构造器循环依赖，Spring 无法解决，因为在实例化一个 Bean 时，它需要另一个 Bean 的实例，然后后者也需要第一个 Bean，这导致了死循环。</li>\n      <li><strong>Setter 注入</strong>：Spring 使用 Setter 方法注入，可以在 Bean 的实例化之后解决循环依赖。即 Spring 会先创建 Bean 的实例，然后再进行 Setter 注入，这样可以避免构造器循环依赖的问题。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>三级缓存机制</strong>：</p>\n    <ul>\n      <li>Spring 在处理循环依赖时，还会使用一个三级缓存机制：\n        <ul>\n          <li><strong>单例池（Singleton Objects Cache）</strong>：最终的单例 Bean。</li>\n          <li><strong>早期引用（Early References）</strong>：尚未初始化完成的 Bean 的半成品，允许其他 Bean 引用。</li>\n          <li><strong>单例指定的 Bean 定义（Singleton Object Definition）</strong>：用于存储 Bean 的定义信息。</li>\n        </ul>\n      </li>\n      <li>具体步骤：\n        <ol>\n          <li>当一个 Bean 的实例化调用发生时，首先创建该 Bean 的早期引用并将其放入早期引用缓存中。</li>\n          <li>当其他 Bean 需要引用这个尚未完全初始化的 Bean 时，Spring 会从早期引用缓存中获取。</li>\n        </ol>\n      </li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>基于 AOP 的代理</strong>：</p>\n    <ul>\n      <li>在使用 AOP 的场景中，Spring 会为 Bean 创建动态代理，代理对象会替代原始 Bean 进行注入，这样也能一定程度上减轻循环依赖的问题。</li>\n    </ul>\n  </li>\n</ol>\n<p>总的来说，Spring 通过对构造器和 Setter 注入的有效组合、三级缓存的策略以及代理机制来处理 Bean 循环依赖的问题，从而确保应用的正常运行。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.00312256,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Spring如何解决Bean的循环依赖。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Spring Bean生命周期的理解。</li>\n      <li>对Spring三级缓存机制的理解。</li>\n      <li>对循环依赖场景及解决方案的理解。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Bean的循环依赖</h4>\n<p>当两个或多个Bean之间相互引用，形成一个闭环时，就产生了循环依赖。例如，Bean A依赖Bean B，而Bean B又依赖Bean A。如果处理不当，会导致创建Bean时出现死循环。</p>\n<h4>（2）Spring Bean的生命周期</h4>\n<p>Spring中Bean的创建过程较为复杂，大致包括实例化、属性填充、初始化等步骤。实例化是创建对象的过程，属性填充是为对象的属性赋值，初始化是调用一些初始化方法。</p>\n<h4>（3）Spring的三级缓存</h4>\n<p>Spring使用三级缓存来解决循环依赖问题，分别是：</p>\n<ul>\n  <li><code>singletonObjects</code>：一级缓存，存储已经完全初始化好的单例Bean。</li>\n  <li><code>singletonFactories</code>：三级缓存，存储创建Bean的工厂对象。</li>\n  <li><code>earlySingletonObjects</code>：二级缓存，存储提前暴露的单例Bean（仅完成实例化，未完成属性填充和初始化）。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）三级缓存的工作原理</h4>\n<ul>\n  <li>当Spring容器开始创建一个单例Bean时，首先会将一个创建该Bean的工厂对象放入<code>singletonFactories</code>中。这个工厂对象可以在需要时提前获取到该Bean的早期引用。</li>\n  <li>在创建过程中，如果发现该Bean依赖其他Bean，就会去创建依赖的Bean。如果依赖的Bean正在创建中，说明出现了循环依赖。此时，会从<code>singletonFactories</code>中获取该Bean的早期引用，将其放入<code>earlySingletonObjects</code>中，并从<code>singletonFactories</code>中移除。</li>\n  <li>当Bean完成属性填充和初始化后，将其从<code>earlySingletonObjects</code>中移除，并放入<code>singletonObjects</code>中。</li>\n</ul>\n<h4>（2）具体解决循环依赖的过程</h4>\n<p>假设存在循环依赖的Bean A和Bean B：</p>\n<ul>\n  <li>Spring开始创建Bean A，先将创建Bean A的工厂对象放入<code>singletonFactories</code>。</li>\n  <li>在填充Bean A的属性时，发现依赖Bean B，于是开始创建Bean B。</li>\n  <li>创建Bean B时，同样将创建Bean B的工厂对象放入<code>singletonFactories</code>。</li>\n  <li>在填充Bean B的属性时，发现依赖Bean A，此时Bean A正在创建中，从<code>singletonFactories</code>中获取Bean A的早期引用，将其放入<code>earlySingletonObjects</code>，并将该早期引用注入到Bean B中。</li>\n  <li>Bean B完成属性填充和初始化后，放入<code>singletonObjects</code>。</li>\n  <li>继续完成Bean A的属性填充，由于Bean B已经在<code>singletonObjects</code>中，直接从该缓存中获取Bean B注入到Bean A中。</li>\n  <li>Bean A完成属性填充和初始化后，放入<code>singletonObjects</code>。</li>\n</ul>\n<h4>（3）三级缓存的必要性</h4>\n<ul>\n  <li>一级缓存<code>singletonObjects</code>用于存储最终可用的单例Bean，确保全局唯一性。</li>\n  <li>二级缓存<code>earlySingletonObjects</code>用于存储提前暴露的早期引用，避免重复创建。</li>\n  <li>三级缓存<code>singletonFactories</code>用于存储创建Bean的工厂对象，允许在出现循环依赖时提前获取早期引用，同时也为AOP等功能提供支持。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">@Component\npublic class BeanA {\n    @Autowired\n    private BeanB beanB;\n\n    // 构造函数、getter和setter方法\n}\n\n@Component\npublic class BeanB {\n    @Autowired\n    private BeanA beanA;\n\n    // 构造函数、getter和setter方法\n}\n\n@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig {\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n        BeanA beanA = context.getBean(BeanA.class);\n        BeanB beanB = context.getBean(BeanB.class);\n        System.out.println(beanA);\n        System.out.println(beanB);\n    }\n}\n</code></pre>\n<p>在上述代码中，<code>BeanA</code>和<code>BeanB</code>存在循环依赖，Spring会使用三级缓存机制来解决这个问题。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）认为所有循环依赖都能解决</h4>\n<ul>\n  <li>误区：认为Spring可以解决所有类型的循环依赖。</li>\n  <li>纠正：Spring只能解决单例Bean的属性注入的循环依赖，对于原型Bean和构造函数注入的循环依赖无法解决。</li>\n</ul>\n<h4>（2）混淆三级缓存的作用</h4>\n<ul>\n  <li>误区：不清楚每个缓存的具体作用和使用场景。</li>\n  <li>纠正：明确一级缓存存储最终可用的Bean，二级缓存存储早期引用，三级缓存存储创建Bean的工厂对象。</li>\n</ul>\n<h4>（3）忽视AOP对循环依赖的影响</h4>\n<ul>\n  <li>误区：只关注循环依赖的解决，没有考虑AOP对循环依赖的影响。</li>\n  <li>纠正：三级缓存的存在为AOP提供了支持，在获取早期引用时可以进行AOP代理。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>Spring通过三级缓存机制解决单例Bean的属性注入的循环依赖问题。三级缓存分别是<code>singletonObjects</code>（一级缓存，存储完全初始化好的单例Bean）、<code>singletonFactories</code>（三级缓存，存储创建Bean的工厂对象）和<code>earlySingletonObjects</code>（二级缓存，存储提前暴露的单例Bean的早期引用）。</p>\n<p>当创建一个单例Bean时，先将创建该Bean的工厂对象放入<code>singletonFactories</code>。在创建过程中，如果出现循环依赖，会从<code>singletonFactories</code>中获取早期引用，放入<code>earlySingletonObjects</code>。当Bean完成属性填充和初始化后，将其从<code>earlySingletonObjects</code>移除，放入<code>singletonObjects</code>。</p>\n<p>需要注意的是，Spring只能解决单例Bean的属性注入的循环依赖，对于原型Bean和构造函数注入的循环依赖无法解决。同时，三级缓存也为AOP等功能提供了支持。</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>什么是Spring的bean生命周期？</strong><br>提示：可以讲一下bean的创建、初始化、销毁等过程。</p>\n  </li>\n  <li>\n    <p><strong>如何使用不同的Scope来管理Bean的生命周期？</strong><br>提示：讨论Singleton、Prototype等作用域的区别和适用场景。</p>\n  </li>\n  <li>\n    <p><strong>你能详细解释一下Spring的自动装配方式吗？</strong><br>提示：了解@Autowire、@Inject和@Resource的用法及其差异。</p>\n  </li>\n  <li>\n    <p><strong>Spring如何处理Bean后处理器？</strong><br>提示：可以讲讲BeanPostProcessor接口以及具体如何应用它。</p>\n  </li>\n  <li>\n    <p><strong>在Spring中如何确保Bean的线程安全？</strong><br>提示：谈谈作用域、同步机制和原子操作等。</p>\n  </li>\n  <li>\n    <p><strong>Spring是如何管理AOP（面向切面编程）的？</strong><br>提示：关注切面、通知、连接点和代理的概念。</p>\n  </li>\n  <li>\n    <p><strong>你如何调试Spring的Bean注入问题？</strong><br>提示：可以提到使用日志、配置问题检查、调试工具等。</p>\n  </li>\n  <li>\n    <p><strong>什么是Spring的条件装配（@Conditional）？</strong><br>提示：讨论如何根据不同条件加载Bean的场景。</p>\n  </li>\n  <li>\n    <p><strong>Spring中如何进行事务管理？</strong><br>提示：可以讲讲@Transactional注解的作用和工作原理。</p>\n  </li>\n  <li>\n    <p><strong>你了解Spring Cloud吗？它与Spring框架有什么关系？</strong><br>提示：探讨Spring Cloud如何扩展Spring的功能以支持微服务架构。</p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Spring 解决 Bean 循环依赖))\n    构造器注入 vs. Setter 注入\n      构造器注入\n      Setter 注入\n    三级缓存机制\n      单例池\n      早期引用\n      单例指定的 Bean 定义\n    基于 AOP 的代理",
    "keynote": "- 构造器注入无法解决循环依赖问题，因为实例化时需要另一个Bean的实例。\n- 使用Setter注入可以解决循环依赖，通过先创建Bean实例再进行属性设置。\n- Spring使用三级缓存机制处理循环依赖：单例池、早期引用和单例指定的Bean定义。\n- 早期引用允许其他Bean引用尚未完全初始化完成的Bean。\n- 在AOP场景中，Spring为Bean创建动态代理来减轻循环依赖问题。",
    "group_id": 17,
    "kps": [
      "容器",
      "框架中的设计模式"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "百联全渠道",
      "网易",
      "百度",
      "元戎启行"
    ]
  }
}