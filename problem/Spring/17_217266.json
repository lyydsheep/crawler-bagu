{"success":true,"data":{"id":217266,"name":"<p>请介绍一下 Spring 拦截器</p>","options":null,"answer":"<p>Spring 拦截器是 Spring 框架提供的一种强大机制，用于在请求处理的前后执行特定的操作，它类似于 Servlet 中的过滤器，但功能更为强大和灵活，常用于权限验证、日志记录、性能监控等场景。下面从几个方面详细介绍 Spring 拦截器：</p>\n<h3>基本概念</h3>\n<p>Spring 拦截器是基于 AOP（面向切面编程）思想实现的，它允许开发者在请求处理的不同阶段插入自定义逻辑。拦截器可以对控制器方法的调用进行拦截，在方法执行前后或异常抛出时执行额外的操作。</p>\n<h3>实现方式</h3>\n<p>在 Spring 中，实现拦截器通常有两种方式：</p>\n<ul>\n  <li><strong>实现 <code>HandlerInterceptor</code> 接口</strong>：这是最常用的方式，<code>HandlerInterceptor</code> 接口定义了三个方法：\n    <ul>\n      <li><code>preHandle</code>：在请求处理之前调用，返回值为 <code>boolean</code> 类型。如果返回 <code>true</code>，则继续执行后续的拦截器和控制器方法；如果返回 <code>false</code>，则请求处理流程终止，后续的拦截器和控制器方法将不会被执行。</li>\n      <li><code>postHandle</code>：在控制器方法执行之后、视图渲染之前调用，可以对模型数据或视图进行修改。</li>\n      <li><code>afterCompletion</code>：在整个请求处理完成之后调用，通常用于资源清理等操作。</li>\n    </ul>\n  </li>\n</ul>\n<p>以下是一个简单的示例：</p>\n<pre><code class=\"language-java\">import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\npublic class MyInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        System.out.println(\"Pre-handle method is called\");\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        System.out.println(\"Post-handle method is called\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        System.out.println(\"After-completion method is called\");\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>继承 <code>HandlerInterceptorAdapter</code> 类</strong>：<code>HandlerInterceptorAdapter</code> 是一个抽象类，实现了 <code>HandlerInterceptor</code> 接口，并提供了默认的方法实现。开发者可以继承该类，只重写需要的方法。</li>\n</ul>\n<h3>配置拦截器</h3>\n<p>要使拦截器生效，需要在 Spring 配置文件或 Java 配置类中进行配置。以下是使用 Java 配置类的示例：</p>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new MyInterceptor())\n                .addPathPatterns(\"/**\") // 拦截所有请求\n                .excludePathPatterns(\"/login\"); // 排除登录请求\n    }\n}\n</code></pre>\n<h3>拦截器的执行顺序</h3>\n<p>当配置了多个拦截器时，它们的执行顺序遵循以下规则：</p>\n<ul>\n  <li><code>preHandle</code> 方法按照拦截器注册的顺序依次执行。</li>\n  <li><code>postHandle</code> 方法按照拦截器注册的顺序逆序执行。</li>\n  <li><code>afterCompletion</code> 方法按照拦截器注册的顺序逆序执行。</li>\n</ul>\n<h3>与过滤器的区别</h3>\n<ul>\n  <li><strong>应用范围</strong>：过滤器是 Servlet 规范的一部分，可用于所有的 Web 请求；而拦截器是 Spring 框架的一部分，只能用于 Spring MVC 应用。</li>\n  <li><strong>执行时机</strong>：过滤器在 Servlet 容器接收请求后、Servlet 处理请求之前执行；拦截器在 Spring MVC 框架处理请求的过程中执行。</li>\n  <li><strong>功能特性</strong>：过滤器主要用于对请求进行预处理和后处理，如字符编码转换、请求过滤等；拦截器可以更深入地参与 Spring MVC 的请求处理流程，如对控制器方法进行拦截、对模型数据进行修改等。</li>\n</ul>","type":6,"level":2,"freq":0.00156128,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：介绍Spring拦截器。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>Spring拦截器的概念。</li>\n      <li>Spring拦截器的作用。</li>\n      <li>Spring拦截器的实现方式。</li>\n      <li>Spring拦截器的执行流程。</li>\n      <li>Spring拦截器的应用场景。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Spring框架</h4>\n<p>Spring是一个轻量级的Java开发框架，提供了IoC（控制反转）和AOP（面向切面编程）等功能，帮助开发者更高效地构建企业级应用。</p>\n<h4>（2）拦截器概念</h4>\n<p>拦截器是一种在请求处理过程中进行拦截和处理的机制，可在请求到达目标处理器之前或之后执行特定操作。</p>\n<h3>3. 解析</h3>\n<h4>（1）Spring拦截器的概念</h4>\n<p>Spring拦截器是Spring MVC框架提供的一种机制，用于在请求处理的不同阶段进行拦截和处理。它可以对请求进行预处理、后处理以及完成处理后的操作。</p>\n<h4>（2）Spring拦截器的作用</h4>\n<ul>\n  <li><strong>权限验证</strong>：在请求到达处理器之前，检查用户是否具有访问权限，若没有则阻止请求继续处理。</li>\n  <li><strong>日志记录</strong>：记录请求的相关信息，如请求的URL、参数、处理时间等，方便后续的问题排查和性能分析。</li>\n  <li><strong>性能监控</strong>：统计请求的处理时间，分析系统的性能瓶颈。</li>\n  <li><strong>请求预处理</strong>：对请求参数进行统一的处理，如编码转换、数据验证等。</li>\n</ul>\n<h4>（3）Spring拦截器的实现方式</h4>\n<p>在Spring中，实现拦截器需要实现<code>HandlerInterceptor</code>接口，该接口定义了三个方法：</p>\n<ul>\n  <li><code>preHandle</code>：在请求处理之前调用，返回<code>true</code>表示继续执行后续的拦截器和处理器，返回<code>false</code>则中断请求处理。</li>\n  <li><code>postHandle</code>：在请求处理之后、视图渲染之前调用，可以对模型和视图进行修改。</li>\n  <li><code>afterCompletion</code>：在整个请求处理完成后调用，通常用于资源清理等操作。</li>\n</ul>\n<h4>（4）Spring拦截器的执行流程</h4>\n<ul>\n  <li>客户端发送请求。</li>\n  <li>前端控制器（<code>DispatcherServlet</code>）接收到请求后，会根据配置的拦截器链依次调用<code>preHandle</code>方法。</li>\n  <li>如果所有<code>preHandle</code>方法都返回<code>true</code>，则请求会到达目标处理器进行处理。</li>\n  <li>处理器处理完请求后，会依次调用拦截器链的<code>postHandle</code>方法。</li>\n  <li>最后，视图渲染完成后，会依次调用拦截器链的<code>afterCompletion</code>方法。</li>\n</ul>\n<h4>（5）Spring拦截器的应用场景</h4>\n<ul>\n  <li><strong>登录验证</strong>：在用户访问需要登录的页面时，拦截请求并检查用户是否已登录。</li>\n  <li><strong>接口限流</strong>：对接口的访问频率进行限制，防止恶意攻击。</li>\n  <li><strong>跨域处理</strong>：在请求处理之前，添加跨域相关的响应头。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<h4>（1）实现拦截器</h4>\n<pre><code class=\"language-java\">import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\npublic class MyInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n            throws Exception {\n        System.out.println(\"Pre-handle method is called\");\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n            ModelAndView modelAndView) throws Exception {\n        System.out.println(\"Post-handle method is called\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)\n            throws Exception {\n        System.out.println(\"After-completion method is called\");\n    }\n}\n</code></pre>\n<h4>（2）配置拦截器</h4>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\");\n    }\n}\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆拦截器和过滤器</h4>\n<ul>\n  <li>误区：认为拦截器和过滤器功能相同，可随意使用。</li>\n  <li>纠正：过滤器是Servlet规范的一部分，主要用于对请求和响应进行过滤和处理，而拦截器是Spring MVC框架的一部分，主要用于对请求处理过程进行拦截和处理。过滤器的执行时机比拦截器更早。</li>\n</ul>\n<h4>（2）错误使用拦截器方法</h4>\n<ul>\n  <li>误区：在<code>preHandle</code>方法中返回<code>false</code>后，仍然期望后续的<code>postHandle</code>和<code>afterCompletion</code>方法被调用。</li>\n  <li>纠正：当<code>preHandle</code>方法返回<code>false</code>时，请求处理流程会中断，后续的<code>postHandle</code>和<code>afterCompletion</code>方法不会被调用。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>Spring拦截器是Spring MVC框架提供的一种机制，用于在请求处理的不同阶段进行拦截和处理。它可以实现权限验证、日志记录、性能监控等功能。</p>\n<p>实现Spring拦截器需要实现<code>HandlerInterceptor</code>接口，重写<code>preHandle</code>、<code>postHandle</code>和<code>afterCompletion</code>方法。其执行流程是：请求到达后，依次调用拦截器的<code>preHandle</code>方法，若都返回<code>true</code>则请求到达处理器，处理器处理完后依次调用<code>postHandle</code>方法，视图渲染完成后依次调用<code>afterCompletion</code>方法。</p>\n<p>Spring拦截器适用于登录验证、接口限流、跨域处理等场景。不过要注意，不要混淆拦截器和过滤器，并且正确使用拦截器的方法，避免出现逻辑错误。</p>","more_ask":"<ol>\n  <li>\n    <p>\n      Spring 拦截器和过滤器有什么区别？\n      提示：从应用范围、使用场景、执行顺序、实现原理等方面思考。\n    </p>\n  </li>\n  <li>\n    <p>\n      如何在 Spring 拦截器中获取请求的参数？\n      提示：可以关注拦截器方法的参数，思考从哪个对象中能获取请求参数。\n    </p>\n  </li>\n  <li>\n    <p>\n      多个 Spring 拦截器的执行顺序是怎样的，如何控制？\n      提示：考虑配置文件或者注解的设置，以及拦截器的 preHandle 方法返回值的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      Spring 拦截器的 preHandle 方法返回 false 会有什么影响？\n      提示：从请求的后续处理流程，如其他拦截器和控制器方法是否执行等方面考虑。\n    </p>\n  </li>\n  <li>\n    <p>\n      怎样在 Spring 拦截器中进行日志记录？\n      提示：思考在拦截器的不同方法中记录不同阶段的信息，以及使用的日志框架。\n    </p>\n  </li>\n  <li>\n    <p>\n      Spring 拦截器可以拦截静态资源吗，如何配置？\n      提示：关注 Spring 的配置文件或者 Java 配置类，思考静态资源的映射规则。\n    </p>\n  </li>\n  <li>\n    <p>\n      如何在 Spring 拦截器中实现权限验证？\n      提示：可以结合用户登录信息、角色信息等，在拦截器中进行判断。\n    </p>\n  </li>\n  <li>\n    <p>\n      Spring 拦截器和 AOP 有什么联系和区别？\n      提示：从功能、实现方式、应用场景等方面对比两者。\n    </p>\n  </li>\n</ol>","mindmap":"mindmap\n  root((Spring 拦截器))\n    基本概念\n      基于 AOP 思想\n      可在请求处理不同阶段插入自定义逻辑\n      拦截控制器方法调用并执行额外操作\n    实现方式\n      实现 HandlerInterceptor 接口\n        preHandle\n        postHandle\n        afterCompletion\n      继承 HandlerInterceptorAdapter 类\n    配置拦截器\n      在 Spring 配置文件或 Java 配置类中配置\n    拦截器的执行顺序\n      preHandle 按注册顺序执行\n      postHandle 按注册顺序逆序执行\n      afterCompletion 按注册顺序逆序执行\n    与过滤器的区别\n      应用范围\n      执行时机\n      功能特性","keynote":"Spring 拦截器基于 AOP 思想，用于请求处理前后操作，应用于权限验证等场景\n实现方式：实现 HandlerInterceptor 接口（preHandle、postHandle、afterCompletion）；继承 HandlerInterceptorAdapter 类\n配置：在 Spring 配置文件或 Java 配置类中配置\n执行顺序：preHandle 顺序执行，postHandle 和 afterCompletion 逆序执行\n与过滤器区别：应用范围、执行时机、功能特性不同","group_id":17,"kps":["面向切面编程（AOP）","框架中的设计模式"],"years":[2024,2022],"corps":["招商银行","百度"]}}