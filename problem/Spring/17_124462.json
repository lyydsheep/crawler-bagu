{"success":true,"data":{"id":124462,"name":"<p>使用 @Transactional 注解有什么注意事项</p>","options":null,"answer":"<p>在使用 <code>@Transactional</code> 注解时，有以下这些需要注意的方面：</p>\n<h3>注解使用范围</h3>\n<ul>\n  <li><strong>方法层面</strong>：<code>@Transactional</code> 注解可以应用在方法上，不过该方法必须是 <code>public</code> 的。因为 Spring AOP 是基于代理模式实现的，而代理模式只能对 <code>public</code> 方法进行增强。如果将其用在非 <code>public</code> 方法上，注解会失效。例如：</li>\n</ul>\n<pre><code class=\"language-java\">public class UserService {\n    // 正确使用，public 方法\n    @Transactional\n    public void saveUser(User user) {\n        // 业务逻辑\n    }\n\n    // 错误使用，非 public 方法，注解会失效\n    @Transactional\n    private void updateUser(User user) {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>类层面</strong>：此注解也能用在类上，这样类中的所有 <code>public</code> 方法都会具有事务特性。不过要注意，若类中的某个方法单独加了 <code>@Transactional</code> 注解，会覆盖类级别的事务配置。</li>\n</ul>\n<h3>事务传播行为</h3>\n<p><code>@Transactional</code> 注解的 <code>propagation</code> 属性用于指定事务的传播行为，常见的传播行为有：</p>\n<ul>\n  <li><strong>REQUIRED（默认）</strong>：如果当前存在事务，就加入该事务；如果不存在，则创建一个新事务。例如，在一个服务类中有两个方法，方法 A 调用方法 B，若方法 A 有事务，方法 B 会加入该事务；若方法 A 没有事务，方法 B 会创建一个新事务。</li>\n</ul>\n<pre><code class=\"language-java\">@Service\npublic class OrderService {\n    @Transactional\n    public void createOrder(Order order) {\n        // 调用另一个有事务的方法\n        updateInventory(order);\n    }\n\n    @Transactional\n    public void updateInventory(Order order) {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>REQUIRES_NEW</strong>：无论当前是否存在事务，都会创建一个新事务，并且挂起当前事务（如果存在）。</li>\n  <li><strong>SUPPORTS</strong>：如果当前存在事务，就加入该事务；如果不存在，则以非事务方式执行。</li>\n</ul>\n<h3>事务隔离级别</h3>\n<p><code>@Transactional</code> 注解的 <code>isolation</code> 属性用于指定事务的隔离级别，常见的隔离级别有：</p>\n<ul>\n  <li><strong>READ_UNCOMMITTED</strong>：允许读取未提交的数据，可能会出现脏读、不可重复读和幻读问题。</li>\n  <li><strong>READ_COMMITTED</strong>：只能读取已提交的数据，可避免脏读，但可能出现不可重复读和幻读。</li>\n  <li><strong>REPEATABLE_READ</strong>：确保在同一个事务中多次读取同一数据的结果是相同的，可避免脏读和不可重复读，但可能出现幻读。</li>\n  <li><strong>SERIALIZABLE</strong>：最高的隔离级别，可避免脏读、不可重复读和幻读，但会影响性能，因为事务会串行执行。</li>\n</ul>\n<h3>异常处理</h3>\n<ul>\n  <li><strong>默认情况</strong>：<code>@Transactional</code> 注解默认只对 <code>RuntimeException</code> 及其子类和 <code>Error</code> 进行回滚。如果抛出的是受检异常（如 <code>IOException</code>），事务不会回滚。例如：</li>\n</ul>\n<pre><code class=\"language-java\">@Service\npublic class ProductService {\n    @Transactional\n    public void updateProduct(Product product) throws IOException {\n        // 业务逻辑\n        if (product.getStock() &#x3C; 0) {\n            throw new IOException(\"库存不足\"); // 不会触发事务回滚\n        }\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>自定义回滚异常</strong>：可以通过 <code>rollbackFor</code> 属性指定需要回滚的异常类型，通过 <code>noRollbackFor</code> 属性指定不需要回滚的异常类型。例如：</li>\n</ul>\n<pre><code class=\"language-java\">@Service\npublic class ProductService {\n    @Transactional(rollbackFor = IOException.class)\n    public void updateProduct(Product product) throws IOException {\n        // 业务逻辑\n        if (product.getStock() &#x3C; 0) {\n            throw new IOException(\"库存不足\"); // 会触发事务回滚\n        }\n    }\n}\n</code></pre>\n<h3>代理机制</h3>\n<p>Spring 的事务管理是基于 AOP 代理实现的，有 JDK 动态代理和 CGLIB 代理两种方式。</p>\n<ul>\n  <li><strong>JDK 动态代理</strong>：基于接口实现，只能代理实现了接口的类。</li>\n  <li><strong>CGLIB 代理</strong>：通过继承的方式实现，可代理没有实现接口的类。在使用时要注意，如果使用 JDK 动态代理，调用类内部方法时，事务注解会失效，因为没有经过代理对象。例如：</li>\n</ul>\n<pre><code class=\"language-java\">@Service\npublic class UserService {\n    public void outerMethod() {\n        innerMethod(); // 这里调用内部方法，事务注解会失效\n    }\n\n    @Transactional\n    public void innerMethod() {\n        // 业务逻辑\n    }\n}\n</code></pre>\n<h3>数据源配置</h3>\n<p>使用 <code>@Transactional</code> 注解时，要确保数据源配置正确，并且事务管理器与数据源关联。例如，在 Spring Boot 项目中，需要正确配置 <code>DataSource</code> 和 <code>PlatformTransactionManager</code>。</p>\n<pre><code class=\"language-java\">@Configuration\npublic class DataSourceConfig {\n    @Bean\n    public DataSource dataSource() {\n        // 配置数据源\n        return DataSourceBuilder.create().url(\"jdbc:mysql://localhost:3306/test\").username(\"root\").password(\"password\").build();\n    }\n\n    @Bean\n    public PlatformTransactionManager transactionManager(DataSource dataSource) {\n        return new DataSourceTransactionManager(dataSource);\n    }\n}\n</code></pre>","type":6,"level":2,"freq":0.0007806401,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：使用 @Transactional 注解的注意事项。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对 Spring 事务管理机制的理解。</li>\n      <li>注解的使用范围和生效条件。</li>\n      <li>事务传播行为和隔离级别的影响。</li>\n      <li>异常处理对事务的影响。</li>\n      <li>代理机制对注解的影响。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Spring 事务管理</h4>\n<p>Spring 提供了声明式事务管理，@Transactional 注解是声明式事务管理的一种方式，它可以简化事务管理代码，通过 AOP 实现事务的自动开启、提交和回滚。</p>\n<h4>（2）事务传播行为</h4>\n<p>定义了多个事务方法相互调用时，事务如何传播，如 REQUIRED、REQUIRES_NEW 等。</p>\n<h4>（3）事务隔离级别</h4>\n<p>定义了事务之间的隔离程度，如 READ_UNCOMMITTED、READ_COMMITTED 等，用于解决脏读、不可重复读、幻读等问题。</p>\n<h3>3. 解析</h3>\n<h4>（1）注解使用范围</h4>\n<ul>\n  <li>@Transactional 注解可以用于类或方法上。用于类上时，该类的所有公共方法都将具有事务属性；用于方法上时，仅该方法具有事务属性。</li>\n  <li>注解只能应用于公共方法，因为 Spring 的 AOP 代理是基于公共方法的。</li>\n</ul>\n<h4>（2）事务传播行为</h4>\n<ul>\n  <li>需要根据业务需求选择合适的事务传播行为。例如，REQUIRED 表示如果当前存在事务，则加入该事务；如果不存在，则创建一个新事务。而 REQUIRES_NEW 表示总是创建一个新事务，挂起当前事务。</li>\n</ul>\n<h4>（3）事务隔离级别</h4>\n<ul>\n  <li>要根据业务场景选择合适的事务隔离级别。较高的隔离级别可以避免数据不一致问题，但会降低并发性能；较低的隔离级别则相反。</li>\n</ul>\n<h4>（4）异常处理</h4>\n<ul>\n  <li>默认情况下，@Transactional 注解只对 RuntimeException 及其子类和 Error 进行回滚。如果需要对其他异常进行回滚，可以通过 rollbackFor 属性指定异常类。</li>\n  <li>手动捕获异常而不抛出，可能会导致事务无法回滚。</li>\n</ul>\n<h4>（5）代理机制</h4>\n<ul>\n  <li>Spring 的事务管理是基于 AOP 代理实现的。如果在同一个类中，一个非事务方法调用另一个有 @Transactional 注解的方法，事务不会生效，因为这种调用没有经过代理。</li>\n</ul>\n<h4>（6）嵌套事务</h4>\n<ul>\n  <li>嵌套事务需要谨慎使用，不同的事务传播行为会导致不同的嵌套效果。例如，NESTED 表示在当前事务中创建一个嵌套事务，嵌套事务可以独立回滚。</li>\n</ul>\n<h4>（7）性能影响</h4>\n<ul>\n  <li>事务会带来一定的性能开销，尤其是在高并发场景下。应尽量减少事务的范围和时长，避免在事务中进行耗时操作。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">import org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\npublic class UserService {\n\n    @Transactional(rollbackFor = Exception.class)\n    public void updateUser() {\n        // 业务逻辑\n    }\n\n    public void nonTransactionalMethod() {\n        // 调用有事务的方法，事务不会生效\n        this.updateUser(); \n    }\n}\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）注解使用范围错误</h4>\n<ul>\n  <li>误区：将 @Transactional 注解用于非公共方法。</li>\n  <li>纠正：确保注解应用于公共方法，因为 Spring 的 AOP 代理基于公共方法。</li>\n</ul>\n<h4>（2）异常处理不当</h4>\n<ul>\n  <li>误区：手动捕获异常而不抛出，导致事务无法回滚。</li>\n  <li>纠正：如果需要回滚，应抛出异常或通过 rollbackFor 属性指定异常类。</li>\n</ul>\n<h4>（3）忽略代理机制</h4>\n<ul>\n  <li>误区：在同一个类中，非事务方法调用事务方法，认为事务会生效。</li>\n  <li>纠正：这种调用没有经过代理，事务不会生效。可以通过注入自身 Bean 来解决。</li>\n</ul>\n<h4>（4）事务传播行为和隔离级别选择不当</h4>\n<ul>\n  <li>误区：不根据业务需求选择合适的事务传播行为和隔离级别。</li>\n  <li>纠正：根据具体业务场景选择合适的传播行为和隔离级别。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>使用 @Transactional 注解时，需要注意以下几点：</p>\n<ul>\n  <li>注解只能用于公共方法，可应用于类或方法上。用于类上时，该类的所有公共方法都具有事务属性。</li>\n  <li>根据业务需求选择合适的事务传播行为和隔离级别，不同的传播行为和隔离级别会影响事务的执行和数据的一致性。</li>\n  <li>默认情况下，注解只对 RuntimeException 及其子类和 Error 进行回滚，可通过 rollbackFor 属性指定其他需要回滚的异常类。手动捕获异常而不抛出会导致事务无法回滚。</li>\n  <li>Spring 的事务管理基于 AOP 代理，同一个类中非事务方法调用事务方法，事务不会生效。</li>\n  <li>嵌套事务需要谨慎使用，不同的传播行为会导致不同的嵌套效果。</li>\n  <li>事务会带来性能开销，应尽量减少事务的范围和时长，避免在事务中进行耗时操作。</li>\n</ul>","more_ask":"<h3>1. 在不同传播行为下，<code>@Transactional</code> 注解嵌套调用会有什么不同表现？</h3>\n<p>提示：回顾 Spring 中 <code>@Transactional</code> 支持的几种传播行为，如 <code>REQUIRED</code>、<code>REQUIRES_NEW</code> 等，思考在嵌套调用时外层和内层事务如何相互影响。</p>\n<h3>2. <code>@Transactional</code> 注解标注的方法中，如果调用了非事务方法，会对事务产生什么影响？</h3>\n<p>提示：考虑非事务方法在事务方法内部调用时，是否会参与当前事务，以及异常处理等情况。</p>\n<h3>3. 当使用 <code>@Transactional</code> 注解时，事务的隔离级别是如何生效的，不同隔离级别会有什么问题？</h3>\n<p>提示：了解 Spring 中事务隔离级别的配置方式，以及不同隔离级别（如 <code>READ_UNCOMMITTED</code>、<code>READ_COMMITTED</code> 等）可能引发的脏读、不可重复读、幻读等问题。</p>\n<h3>4. 在多线程环境下使用 <code>@Transactional</code> 注解会有什么问题，如何解决？</h3>\n<p>提示：思考多线程环境中事务的管理和同步问题，例如不同线程是否共享事务上下文等。</p>\n<h3>5. <code>@Transactional</code> 注解标注的方法抛出异常时，事务一定会回滚吗，为什么？</h3>\n<p>提示：考虑异常的类型，Spring 默认只对 <code>RuntimeException</code> 和 <code>Error</code> 进行回滚，对于受检异常需要特殊配置。</p>\n<h3>6. 如果 <code>@Transactional</code> 注解标注的类实现了接口，Spring 是如何代理该类的，这对事务有什么影响？</h3>\n<p>提示：了解 Spring 的代理机制（JDK 动态代理和 CGLIB 代理），以及不同代理方式对事务方法调用的影响。</p>\n<h3>7. 在使用 <code>@Transactional</code> 注解时，如何手动控制事务的提交和回滚？</h3>\n<p>提示：思考 Spring 提供的编程式事务管理方式，以及如何在注解式事务中结合使用。</p>","mindmap":"mindmap\n  root((@Transactional注解使用注意事项))\n    注解使用范围\n      方法层面\n      类层面\n    事务传播行为\n      REQUIRED（默认）\n      REQUIRES_NEW\n      SUPPORTS\n    事务隔离级别\n      READ_UNCOMMITTED\n      READ_COMMITTED\n      REPEATABLE_READ\n      SERIALIZABLE\n    异常处理\n      默认情况\n      自定义回滚异常\n    代理机制\n      JDK动态代理\n      CGLIB代理\n    数据源配置","keynote":"注解使用范围：\n- 方法层面：注解用于public方法，非public方法注解失效\n- 类层面：注解用于类，类中public方法有事务特性，方法单独注解会覆盖类配置\n\n事务传播行为：\n- REQUIRED（默认）：有事务加入，无事务创建新事务\n- REQUIRES_NEW：创建新事务，挂起当前事务\n- SUPPORTS：有事务加入，无事务非事务执行\n\n事务隔离级别：\n- READ_UNCOMMITTED：允许读未提交数据，有脏读等问题\n- READ_COMMITTED：读已提交数据，避免脏读\n- REPEATABLE_READ：同一事务多次读结果相同，避免脏读和不可重复读\n- SERIALIZABLE：最高隔离级别，避免所有问题，性能受影响\n\n异常处理：\n- 默认：只对RuntimeException及其子类和Error回滚\n- 自定义：用rollbackFor和noRollbackFor指定回滚和不回滚异常\n\n代理机制：\n- JDK动态代理：基于接口，调用类内部方法事务注解失效\n- CGLIB代理：通过继承，可代理无接口类\n\n数据源配置：确保数据源配置正确，事务管理器与数据源关联","group_id":17,"kps":["事务管理"],"years":[2023],"corps":["京东"]}}