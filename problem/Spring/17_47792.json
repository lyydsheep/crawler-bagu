{"success":true,"data":{"id":47792,"name":"<p>请说明@Autowired注入的对象是什么时候创建的</p>","options":null,"answer":"<p>在Spring框架里，使用<code>@Autowired</code>注入的对象创建时机与Spring的Bean生命周期和上下文加载过程紧密相关，下面分不同情况进行说明：</p>\n<h3>单例Bean</h3>\n<p>对于单例作用域（默认作用域）的Bean，在Spring应用上下文启动时就会创建。当Spring容器完成初始化，会扫描所有配置类、XML配置文件等，解析并注册所有的Bean定义。之后，Spring会创建所有单例作用域的Bean实例，并将它们存储在单例Bean缓存中。</p>\n<p>当使用<code>@Autowired</code>注入单例Bean时，注入的对象其实在应用上下文启动时就已经创建好了。例如：</p>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\nclass ServiceA {\n    // 业务逻辑\n}\n\n@Component\nclass ServiceB {\n    @Autowired\n    private ServiceA serviceA;\n\n    // 业务逻辑\n}\n</code></pre>\n<p>在这个例子中，<code>ServiceA</code>和<code>ServiceB</code>默认都是单例Bean。当Spring应用上下文启动时，会先创建<code>ServiceA</code>的实例，然后创建<code>ServiceB</code>的实例，并将之前创建好的<code>ServiceA</code>实例注入到<code>ServiceB</code>中。</p>\n<h3>原型Bean</h3>\n<p>对于原型作用域的Bean，每次请求该Bean时才会创建新的实例。当使用<code>@Autowired</code>注入原型Bean时，在依赖该原型Bean的Bean创建时，Spring会创建一个新的原型Bean实例并注入。</p>\n<p>不过要注意，若依赖原型Bean的Bean是单例的，那么在单例Bean创建时会注入一个原型Bean实例，之后单例Bean不会再获取新的原型Bean实例，因为单例Bean只会创建一次。示例如下：</p>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Scope(\"prototype\")\nclass PrototypeService {\n    // 业务逻辑\n}\n\n@Component\nclass SingletonService {\n    @Autowired\n    private PrototypeService prototypeService;\n\n    // 业务逻辑\n}\n</code></pre>\n<p>在这个例子中，<code>PrototypeService</code>是原型Bean，<code>SingletonService</code>是单例Bean。当Spring应用上下文启动创建<code>SingletonService</code>时，会创建一个新的<code>PrototypeService</code>实例并注入到<code>SingletonService</code>中。后续<code>SingletonService</code>不会再获取新的<code>PrototypeService</code>实例。</p>\n<h3>懒加载Bean</h3>\n<p>对于使用<code>@Lazy</code>注解标记的Bean，会延迟创建。当使用<code>@Autowired</code>注入懒加载的Bean时，在依赖该Bean的对象真正需要使用这个被注入的Bean时才会创建。示例如下：</p>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Lazy\nclass LazyService {\n    // 业务逻辑\n}\n\n@Component\nclass NormalService {\n    @Autowired\n    private LazyService lazyService;\n\n    // 业务逻辑\n    public void doSomething() {\n        // 当调用这个方法时，才会创建LazyService实例\n        lazyService.someMethod();\n    }\n}\n</code></pre>\n<p>在这个例子中，<code>LazyService</code>被标记为懒加载。当<code>NormalService</code>创建时，<code>LazyService</code>实例不会立即创建，直到<code>NormalService</code>的<code>doSomething</code>方法被调用，才会创建<code>LazyService</code>实例。</p>","type":6,"level":2,"freq":0.0007806401,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：@Autowired注入的对象是什么时候创建的。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Spring框架中Bean生命周期的理解。</li>\n      <li>@Autowired注解的工作原理。</li>\n      <li>Spring容器的启动和Bean创建过程。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Spring容器与Bean</h4>\n<p>Spring容器负责管理Bean的生命周期，包括创建、初始化、销毁等操作。Bean是Spring管理的对象，它们在容器中被创建和维护。</p>\n<h4>（2）@Autowired注解</h4>\n<p>@Autowired是Spring框架提供的依赖注入注解，用于自动装配Bean。它可以作用在构造函数、字段、方法上，帮助实现依赖的自动注入。</p>\n<h3>3. 解析</h3>\n<h4>（1）默认情况</h4>\n<p>\n  在Spring中，默认情况下，单例（Singleton）作用域的Bean会在Spring容器启动时创建。当使用@Autowired注入单例Bean时，这些Bean在容器启动阶段就已经被创建好了，然后在需要注入的地方直接将这些已经创建好的Bean注入进去。\n  例如，在配置类中定义一个单例Bean：\n</p>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n    @Bean\n    public MyService myService() {\n        return new MyService();\n    }\n}\n</code></pre>\n<p>在另一个类中使用@Autowired注入这个Bean：</p>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class MyClient {\n    @Autowired\n    private MyService myService;\n}\n</code></pre>\n<p>这里的MyService Bean会在Spring容器启动时创建，然后注入到MyClient类中。</p>\n<h4>（2）非单例作用域</h4>\n<p>\n  对于原型（Prototype）作用域的Bean，每次请求该Bean时才会创建新的实例。当使用@Autowired注入原型作用域的Bean时，在注入的那一刻，如果该Bean还未创建，Spring会创建一个新的实例并注入。\n  例如，将上面的MyService Bean改为原型作用域：\n</p>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Scope;\n\n@Configuration\npublic class AppConfig {\n    @Bean\n    @Scope(\"prototype\")\n    public MyService myService() {\n        return new MyService();\n    }\n}\n</code></pre>\n<p>当MyClient类被创建并注入MyService Bean时，如果MyService Bean之前未创建，Spring会创建一个新的MyService实例并注入。</p>\n<h4>（3）延迟加载</h4>\n<p>如果使用了@Lazy注解进行延迟加载，单例Bean的创建会被推迟到第一次被使用时。例如：</p>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class MyClient {\n    @Autowired\n    @Lazy\n    private MyService myService;\n}\n</code></pre>\n<p>这里的MyService Bean会在第一次被使用时才创建。</p>\n<h3>4. 常见误区</h3>\n<h4>（1）认为所有Bean都在注入时创建</h4>\n<p>\n  误区：以为不管什么作用域的Bean，都是在使用@Autowired注入时才创建。\n  纠正：单例作用域的Bean默认在容器启动时创建，只有原型作用域等非单例Bean才可能在注入时创建。\n</p>\n<h4>（2）忽略延迟加载的影响</h4>\n<p>\n  误区：没有考虑到@Lazy注解对Bean创建时间的影响。\n  纠正：使用@Lazy注解会使单例Bean的创建推迟到第一次使用时。\n</p>\n<h3>5. 总结回答</h3>\n<p>在Spring中，使用@Autowired注入的对象的创建时间取决于Bean的作用域和是否使用了延迟加载。</p>\n<ul>\n  <li>对于单例（Singleton）作用域的Bean，默认情况下会在Spring容器启动时创建，然后在需要注入的地方直接注入这些已经创建好的Bean。但如果使用了@Lazy注解进行延迟加载，单例Bean的创建会推迟到第一次被使用时。</li>\n  <li>对于原型（Prototype）作用域的Bean，每次请求该Bean时才会创建新的实例。当使用@Autowired注入原型作用域的Bean时，在注入的那一刻，如果该Bean还未创建，Spring会创建一个新的实例并注入。</li>\n</ul>","more_ask":"<ol>\n  <li>\n    <p><strong>@Autowired注入对象创建顺序与依赖关系</strong></p>\n    <ul>\n      <li>问题：当一个类中有多个使用@Autowired注入的对象，并且这些对象之间存在依赖关系时，它们的创建顺序是怎样的？</li>\n      <li>提示：思考Spring的依赖注入机制和对象创建流程，以及如何处理循环依赖等情况。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>@Autowired与不同作用域对象的创建</strong></p>\n    <ul>\n      <li>问题：如果使用@Autowired注入一个作用域为prototype的Bean，这个Bean会在什么时候创建？和单例Bean的创建有什么不同？</li>\n      <li>提示：了解Spring中不同作用域（如singleton、prototype）的特点和生命周期。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>@Autowired在不同生命周期阶段的注入情况</strong></p>\n    <ul>\n      <li>问题：在Spring的Bean生命周期中，@Autowired注入对象的操作发生在哪个具体阶段？如果在这个阶段之前尝试访问注入的对象会怎样？</li>\n      <li>提示：熟悉Spring Bean的完整生命周期，包括实例化、属性填充、初始化等阶段。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>@Autowired与构造函数注入的创建时机差异</strong></p>\n    <ul>\n      <li>问题：使用@Autowired进行字段注入和构造函数注入时，对象的创建时机有什么不同？各有什么优缺点？</li>\n      <li>提示：对比两种注入方式的实现原理和执行顺序。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>@Autowired注入对象创建失败的处理</strong></p>\n    <ul>\n      <li>问题：当@Autowired注入的对象创建失败时，Spring会有怎样的处理机制？如何在代码中捕获和处理这种异常？</li>\n      <li>提示：考虑Spring的异常处理机制和依赖注入的错误处理逻辑。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>@Autowired与延迟加载的结合</strong></p>\n    <ul>\n      <li>问题：如果使用@Lazy注解和@Autowired一起使用，注入对象的创建时机有什么变化？延迟加载有什么应用场景？</li>\n      <li>提示：理解@Lazy注解的作用和延迟加载的原理。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>@Autowired在父子容器中的对象创建</strong></p>\n    <ul>\n      <li>问题：在Spring的父子容器环境中，使用@Autowired注入对象时，对象是在哪个容器中创建的？如果父子容器中有同名的Bean会怎样？</li>\n      <li>提示：了解Spring父子容器的关系和Bean的查找顺序。</li>\n    </ul>\n  </li>\n</ol>","mindmap":"mindmap\n  root((Spring框架@Autowired注入对象创建时机))\n    单例Bean\n      应用上下文启动时创建\n      扫描配置解析注册Bean定义\n      创建单例Bean实例存于缓存\n      注入已创建对象\n    原型Bean\n      每次请求创建新实例\n      依赖Bean创建时注入新实例\n      单例依赖时仅创建一次\n    懒加载Bean\n      延迟创建\n      真正使用时创建","keynote":"单例Bean：应用上下文启动时创建，扫描配置注册Bean定义，创建实例存缓存，注入已创建对象\n原型Bean：每次请求创建新实例，依赖Bean创建时注入，单例依赖仅创建一次\n懒加载Bean：延迟创建，真正使用时创建","group_id":17,"kps":["控制反转（IoC）与依赖注入（DI）"],"years":[2024],"corps":["Wind万得"]}}