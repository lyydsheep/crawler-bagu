{
  "success": true,
  "data": {
    "id": 1542,
    "name": "<p>SpringMVC的拦截器和过滤器有什么区别？执行顺序？</p>",
    "options": null,
    "answer": "<p>在Spring框架中，拦截器（Interceptor）和过滤器（Filter）都是用于处理请求的机制，但它们的工作原理、执行顺序和适用范围有所不同。下面是它们的主要区别及执行顺序：</p>\n<h3>主要区别</h3>\n<ol>\n  <li>\n    <p><strong>定义和范围</strong>：</p>\n    <ul>\n      <li><strong>过滤器</strong>：是Servlet规范的一部分，用于对请求和响应进行预处理和后处理。过滤器是针对所有请求的，可以作用于所有类型的Servlet。</li>\n      <li><strong>拦截器</strong>：是Spring框架提供的机制，主要用于处理Spring MVC的请求。它适用于Controller层，可以在请求处理前后进行逻辑处理。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>执行方式</strong>：</p>\n    <ul>\n      <li><strong>过滤器</strong>：在Servlet容器中生效，能够对请求和响应进行过滤，处理任何类型的资源（如图片、CSS、JS等）。它直接和HTTP请求/响应交互。</li>\n      <li><strong>拦截器</strong>：主要工作于控制层，它不直接处理请求，而是通过与Spring MVC的HandlerMapping和HandlerAdapter结合使用，在具体的Controller方法被调用前后进行操作。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>配置方式</strong>：</p>\n    <ul>\n      <li><strong>过滤器</strong>：通过web.xml文件或使用Java配置方式进行配置。</li>\n      <li><strong>拦截器</strong>：通过Spring的配置文件（xml方式）或Java配置类（如使用<code>WebMvcConfigurer</code>接口）进行配置。</li>\n    </ul>\n  </li>\n</ol>\n<h3>执行顺序</h3>\n<ol>\n  <li>\n    <p><strong>过滤器</strong>：在请求到达Servlet之前，首先会经过所有配置的过滤器。过滤器的执行顺序是按其在web.xml中或Spring配置中的顺序进行的。</p>\n  </li>\n  <li>\n    <p><strong>拦截器</strong>：过滤器处理完请求之后，Spring的DispatcherServlet接收请求，并根据请求的URL找到相应的Controller，这时拦截器开始工作。执行顺序如下：</p>\n    <ul>\n      <li>先执行所有的拦截器的 <code>preHandle</code> 方法（在请求处理前）。</li>\n      <li>然后调用目标Controller的方法。</li>\n      <li>最后执行所有的拦截器的 <code>postHandle</code> 和 <code>afterCompletion</code> 方法（在请求处理后）。</li>\n    </ul>\n  </li>\n</ol>\n<h3>总结</h3>\n<ul>\n  <li><strong>过滤器</strong>：适用于Servlet层面，处理所有类型的请求；</li>\n  <li><strong>拦截器</strong>：适用于Controller层面，处理特定的MVC请求；</li>\n  <li>执行顺序：过滤器先行，拦截器随后。</li>\n</ul>",
    "type": 6,
    "level": 2,
    "freq": 0.0007806401,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：SpringMVC的拦截器和过滤器的区别及执行顺序。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对SpringMVC拦截器和过滤器概念的理解。</li>\n      <li>两者在功能、使用范围、生命周期等方面的区别。</li>\n      <li>它们在请求处理流程中的执行顺序。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）过滤器（Filter）</h4>\n<ul>\n  <li>过滤器是Servlet规范中的一部分，用于对请求和响应进行预处理和后处理。</li>\n  <li>它可以对所有请求进行拦截，包括静态资源请求，通常用于字符编码处理、权限验证等。</li>\n</ul>\n<h4>（2）拦截器（Interceptor）</h4>\n<ul>\n  <li>拦截器是SpringMVC框架提供的功能，用于对处理器方法进行拦截。</li>\n  <li>它只能拦截SpringMVC处理的请求，对静态资源请求不进行拦截，常用于日志记录、性能监控等。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）区别</h4>\n<ul>\n  <li><strong>归属不同</strong>：\n    <ul>\n      <li>过滤器属于Servlet规范，是Servlet容器（如Tomcat）管理的组件。</li>\n      <li>拦截器属于SpringMVC框架，是Spring容器管理的组件。</li>\n    </ul>\n  </li>\n  <li><strong>使用范围不同</strong>：\n    <ul>\n      <li>过滤器可以拦截所有请求，包括静态资源请求。</li>\n      <li>拦截器只能拦截SpringMVC处理的请求，对静态资源请求不拦截。</li>\n    </ul>\n  </li>\n  <li><strong>生命周期不同</strong>：\n    <ul>\n      <li>过滤器的生命周期由Servlet容器管理，在Web应用启动时初始化，在Web应用关闭时销毁。</li>\n      <li>拦截器的生命周期由Spring容器管理，在Spring容器启动时创建，在Spring容器关闭时销毁。</li>\n    </ul>\n  </li>\n  <li><strong>拦截深度不同</strong>：\n    <ul>\n      <li>过滤器在Servlet容器级别拦截，在请求进入Servlet之前和响应返回客户端之前进行处理。</li>\n      <li>拦截器在SpringMVC框架级别拦截，在处理器方法执行前后进行处理。</li>\n    </ul>\n  </li>\n  <li><strong>实现方式不同</strong>：\n    <ul>\n      <li>过滤器需要实现<code>javax.servlet.Filter</code>接口，重写<code>init</code>、<code>doFilter</code>和<code>destroy</code>方法。</li>\n      <li>拦截器需要实现<code>org.springframework.web.servlet.HandlerInterceptor</code>接口，重写<code>preHandle</code>、<code>postHandle</code>和<code>afterCompletion</code>方法。</li>\n    </ul>\n  </li>\n</ul>\n<h4>（2）执行顺序</h4>\n<ul>\n  <li>过滤器先于拦截器执行。\n    <ul>\n      <li>当一个请求进入Web应用时，首先会经过过滤器链，过滤器链中的过滤器按照配置的顺序依次对请求进行处理。</li>\n      <li>当请求通过过滤器链后，才会进入SpringMVC框架，此时拦截器开始工作，拦截器会在处理器方法执行前后进行处理。</li>\n      <li>当处理器方法执行完毕后，拦截器的<code>postHandle</code>和<code>afterCompletion</code>方法会依次执行。</li>\n      <li>最后，请求再经过过滤器链中的过滤器进行后处理，然后返回响应给客户端。</li>\n    </ul>\n  </li>\n</ul>\n<h3>4. 示例代码</h3>\n<h4>（1）过滤器示例</h4>\n<pre><code class=\"language-java\">import javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n@WebFilter(urlPatterns = \"/*\")\npublic class MyFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println(\"Filter initialized\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        System.out.println(\"Filter before request\");\n        chain.doFilter(request, response);\n        System.out.println(\"Filter after request\");\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"Filter destroyed\");\n    }\n}\n</code></pre>\n<h4>（2）拦截器示例</h4>\n<pre><code class=\"language-java\">import org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class MyInterceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n            throws Exception {\n        System.out.println(\"Interceptor preHandle\");\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n                           ModelAndView modelAndView) throws Exception {\n        System.out.println(\"Interceptor postHandle\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n                                Exception ex) throws Exception {\n        System.out.println(\"Interceptor afterCompletion\");\n    }\n}\n</code></pre>\n<h4>（3）拦截器配置</h4>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\");\n    }\n}\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆过滤器和拦截器的使用范围</h4>\n<ul>\n  <li>误区：认为拦截器可以拦截所有请求，包括静态资源请求。</li>\n  <li>纠正：拦截器只能拦截SpringMVC处理的请求，对静态资源请求不拦截。</li>\n</ul>\n<h4>（2）不清楚执行顺序</h4>\n<ul>\n  <li>误区：认为拦截器先于过滤器执行。</li>\n  <li>纠正：过滤器先于拦截器执行，请求先经过过滤器链，再进入SpringMVC框架，由拦截器进行处理。</li>\n</ul>\n<h4>（3）不理解生命周期差异</h4>\n<ul>\n  <li>误区：认为过滤器和拦截器的生命周期由相同的容器管理。</li>\n  <li>纠正：过滤器由Servlet容器管理生命周期，拦截器由Spring容器管理生命周期。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“SpringMVC的拦截器和过滤器有以下区别：</p>\n<ul>\n  <li><strong>归属不同</strong>：过滤器属于Servlet规范，由Servlet容器管理；拦截器属于SpringMVC框架，由Spring容器管理。</li>\n  <li><strong>使用范围不同</strong>：过滤器可拦截所有请求，包括静态资源请求；拦截器只拦截SpringMVC处理的请求。</li>\n  <li><strong>生命周期不同</strong>：过滤器的生命周期由Servlet容器管理，拦截器的生命周期由Spring容器管理。</li>\n  <li><strong>拦截深度不同</strong>：过滤器在Servlet容器级别拦截，拦截器在SpringMVC框架级别拦截。</li>\n  <li><strong>实现方式不同</strong>：过滤器需实现<code>javax.servlet.Filter</code>接口，拦截器需实现<code>org.springframework.web.servlet.HandlerInterceptor</code>接口。</li>\n</ul>\n<p>它们的执行顺序是过滤器先于拦截器执行。请求进入Web应用后先经过过滤器链处理，再进入SpringMVC框架，由拦截器在处理器方法执行前后进行处理，最后请求再经过过滤器链后处理，返回响应给客户端。”</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>请解释一下SpringMVC拦截器的生命周期。</strong></p>\n    <ul>\n      <li>提示：可以谈谈拦截器的初始化、执行和销毁阶段。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>过滤器与拦截器在哪些具体场景下适合使用？</strong></p>\n    <ul>\n      <li>提示：考虑不同的需求，例如登陆验证、请求参数处理等。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在使用SpringMVC拦截器时，如何控制拦截的URL模式？</strong></p>\n    <ul>\n      <li>提示：讨论<code>addPathPatterns</code>和<code>excludePathPatterns</code>方法的使用。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>拦截器和过滤器可以相互配合使用吗？如果可以，如何实现？</strong></p>\n    <ul>\n      <li>提示：讨论它们的执行顺序及相互影响。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>Spring中的HandlerInterceptor与Servlet Filter有何代码实现上的区别？</strong></p>\n    <ul>\n      <li>提示：涉及到接口的实现及方法的重写等。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>可以给出一个实际的例子，说明使用拦截器或过滤器的具体实现吗？</strong></p>\n    <ul>\n      <li>提示：分享一个项目中的实际应用场景。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如果拦截器或过滤器抛出异常，系统会如何响应？</strong></p>\n    <ul>\n      <li>提示：讨论异常处理机制以及如何优雅降级。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>SpringMVC中的拦截器和AOP有什么区别？</strong></p>\n    <ul>\n      <li>提示：讨论它们的核心概念和使用目的，及其在应用中的角色。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在多线程环境下，透过拦截器或过滤器处理请求时的注意事项是什么？</strong></p>\n    <ul>\n      <li>提示：考虑共享资源和线程安全问题。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何测试拦截器和过滤器的功能？</strong></p>\n    <ul>\n      <li>提示：分享测试方法及使用的工具与框架。</li>\n    </ul>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Spring框架中的拦截器与过滤器))\n    主要区别\n      定义和范围\n        过滤器\n        拦截器\n      执行方式\n        过滤器\n        拦截器\n      配置方式\n        过滤器\n        拦截器\n    执行顺序\n      过滤器\n      拦截器\n    总结\n      过滤器\n      拦截器\n      执行顺序",
    "keynote": "- 过滤器是Servlet规范的一部分，作用于所有请求；拦截器是Spring MVC机制，针对Controller层。\n- 过滤器处理任何类型的资源，直接与HTTP交互；拦截器通过HandlerMapping等间接操作。\n- 过滤器配置通过web.xml或Java配置；拦截器配置使用Spring配置文件或WebMvcConfigurer接口。\n- 执行时，过滤器先于拦截器执行。拦截器按preHandle -> Controller方法 -> postHandle/afterCompletion顺序工作。",
    "group_id": 17,
    "kps": [
      "容器",
      "MVC"
    ],
    "years": [
      2024
    ],
    "corps": [
      "小米"
    ]
  }
}