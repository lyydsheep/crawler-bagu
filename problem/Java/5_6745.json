{
  "success": true,
  "data": {
    "id": 6745,
    "name": "<p>synchronized的实现原理</p>",
    "options": null,
    "answer": "<p><code>synchronized</code> 是 Java 中实现线程安全的一种机制，用于防止多个线程同时访问某个代码块或对象，以避免数据不一致和竞争条件的发生。它的实现原理主要涉及到监视器（Monitor）的机制，具体可以从以下几个方面理解：</p>\n<h3>1. 监视器锁（Monitor Lock）</h3>\n<p>每个对象都有一个监视器锁，<code>synchronized</code> 关键字通过获取和释放这个锁来实现线程间的互斥。Java 中的每个对象都可以作为一个锁。</p>\n<h3>2. 方法级同步和块级同步</h3>\n<ul>\n  <li><strong>方法级同步</strong>：在方法声明中使用 <code>synchronized</code> 关键字，可以同步实例方法或静态方法。\n    <pre><code class=\"language-java\">public synchronized void instanceMethod() {\n    // 对实例方法加锁\n}\n\npublic static synchronized void staticMethod() {\n    // 对类方法加锁\n}\n</code></pre>\n  </li>\n  <li><strong>块级同步</strong>：在特定的代码块上使用 <code>synchronized</code> 关键字。\n    <pre><code class=\"language-java\">synchronized (this) {\n    // 只有这个代码块是同步的\n}\n</code></pre>\n  </li>\n</ul>\n<h3>3. 锁的获取与释放</h3>\n<ul>\n  <li>当一个线程进入一个被 <code>synchronized</code> 修饰的方法或代码块时，它会尝试获取该对象的监视器锁。</li>\n  <li>如果锁已经被其他线程持有，那么当前线程会被阻塞，直到该锁被释放。</li>\n  <li>当方法或代码块执行完毕，线程会自动释放锁。</li>\n</ul>\n<h3>4. JVM 实现</h3>\n<p>在底层，Java 使用 <code>monitorenter</code> 和 <code>monitorexit</code> 指令来实现 <code>synchronized</code> 机制。具体步骤如下：</p>\n<ul>\n  <li>线程在访问一个 <code>synchronized</code> 方法或代码块时，会调用 <code>monitorenter</code> 指令来获取锁。</li>\n  <li>如果锁被获取成功，线程可以继续执行代码块；否则，线程会阻塞。</li>\n  <li>执行完代码后，线程调用 <code>monitorexit</code> 指令来释放锁。</li>\n</ul>\n<h3>5. 性能开销</h3>\n<p>使用 <code>synchronized</code> 会引入一些性能开销，因为线程在获取和释放锁时会涉及上下文切换和PV操作。不过，JDK 1.6 及以后的版本通过引入了一些优化，比如偏向锁、轻量级锁等，来减少这些开销。</p>\n<h3>6. 其他关键点</h3>\n<ul>\n  <li><strong>可重入性</strong>：同一个线程可以多次获得同一个锁，而不会造成死锁。</li>\n  <li><strong>条件变量</strong>：可以使用 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法来实现更复杂的线程间通信。</li>\n</ul>\n<p>总之，<code>synchronized</code> 是 Java 内置的机制，用于实现简单有效的线程安全，适用于需要保护共享资源的场景。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.001404741,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：synchronized的实现原理是什么。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Java中synchronized关键字的理解。</li>\n      <li>Java对象头的知识。</li>\n      <li>锁的升级机制。</li>\n      <li>底层的Monitor机制。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）synchronized的作用</h4>\n<p>synchronized是Java中的一个关键字，用于实现线程同步，保证在同一时刻只有一个线程可以访问被synchronized修饰的代码块或方法，从而避免多线程并发访问时的数据不一致问题。</p>\n<h4>（2）Java对象头</h4>\n<p>Java对象在内存中由对象头、实例数据和对齐填充三部分组成。对象头包含了一些与对象自身运行时数据相关的信息，如哈希码、分代年龄、锁状态标志等，这些信息对于synchronized的实现至关重要。</p>\n<h4>（3）Monitor机制</h4>\n<p>Monitor（监视器）是Java中实现同步的基础，它是一个同步工具，也可以理解为一种锁的实现。每个Java对象都可以关联一个Monitor，当一个线程尝试访问被synchronized修饰的代码块或方法时，它需要先获得该对象关联的Monitor。</p>\n<h3>3. 解析</h3>\n<h4>（1）synchronized修饰代码块的实现原理</h4>\n<p>当synchronized修饰代码块时，编译后的字节码会在同步代码块的开始位置插入<code>monitorenter</code>指令，在结束位置插入<code>monitorexit</code>指令。</p>\n<ul>\n  <li><code>monitorenter</code>指令：当线程执行到该指令时，会尝试获取该对象关联的Monitor。如果Monitor的计数器为0，表示该Monitor没有被其他线程持有，当前线程可以获得该Monitor，将计数器加1，然后进入同步代码块执行。如果Monitor的计数器不为0，说明该Monitor已被其他线程持有，当前线程会被阻塞，直到持有Monitor的线程释放它。</li>\n  <li><code>monitorexit</code>指令：当线程执行到该指令时，会将Monitor的计数器减1。当计数器减为0时，表示当前线程已经释放了该Monitor，其他被阻塞的线程可以尝试竞争该Monitor。</li>\n</ul>\n<h4>（2）synchronized修饰方法的实现原理</h4>\n<p>当synchronized修饰方法时，编译后的字节码会在方法的访问标志位中设置<code>ACC_SYNCHRONIZED</code>标志。当线程调用该方法时，Java虚拟机（JVM）会检查该方法是否设置了<code>ACC_SYNCHRONIZED</code>标志。如果设置了，线程会先尝试获取该方法所属对象的Monitor，获取成功后才能执行方法体，方法执行完毕后会自动释放Monitor。</p>\n<h4>（3）锁的升级机制</h4>\n<p>为了提高性能，Java中的synchronized锁引入了锁的升级机制，其升级过程为：无锁状态 -> 偏向锁 -> 轻量级锁 -> 重量级锁。</p>\n<ul>\n  <li><strong>偏向锁</strong>：偏向锁是为了在只有一个线程访问同步代码块时提高性能而设计的。当一个线程第一次访问同步代码块并获取锁时，会在对象头中记录该线程的ID，以后该线程再次进入该同步代码块时，无需进行任何同步操作，直接获取锁，这样可以减少锁的获取和释放带来的性能开销。</li>\n  <li><strong>轻量级锁</strong>：当有另一个线程尝试竞争偏向锁时，偏向锁会升级为轻量级锁。轻量级锁使用CAS（Compare and Swap）操作来尝试获取锁，避免了线程的阻塞和唤醒，从而提高了性能。如果CAS操作成功，线程可以获取锁并执行同步代码块；如果CAS操作失败，说明有其他线程也在竞争该锁，轻量级锁会升级为重量级锁。</li>\n  <li><strong>重量级锁</strong>：重量级锁会导致线程的阻塞和唤醒，性能开销较大。当轻量级锁升级为重量级锁后，线程会被放入Monitor的等待队列中，等待持有锁的线程释放锁后再被唤醒。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">public class SynchronizedExample {\n    private int count = 0;\n\n    // synchronized修饰方法\n    public synchronized void increment() {\n        count++;\n    }\n\n    public void incrementBlock() {\n        // synchronized修饰代码块\n        synchronized (this) {\n            count++;\n        }\n    }\n\n    public static void main(String[] args) {\n        SynchronizedExample example = new SynchronizedExample();\n        example.increment();\n        example.incrementBlock();\n    }\n}\n</code></pre>\n<p>在上述代码中，<code>increment</code>方法被synchronized修饰，<code>incrementBlock</code>方法中的代码块被synchronized修饰，它们都实现了线程同步。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）认为synchronized性能很差</h4>\n<p>\n  误区：很多人认为synchronized是一种重量级锁，性能很差。\n  纠正：在JDK 1.6之后，Java对synchronized进行了大量的优化，引入了锁的升级机制，使得synchronized在不同的场景下都能有较好的性能表现。\n</p>\n<h4>（2）混淆不同锁状态的使用场景</h4>\n<p>\n  误区：不清楚偏向锁、轻量级锁和重量级锁的使用场景，在实际开发中不能合理使用synchronized。\n  纠正：偏向锁适用于只有一个线程访问同步代码块的场景；轻量级锁适用于多个线程交替访问同步代码块的场景；重量级锁适用于多个线程同时竞争同步代码块的场景。\n</p>\n<h4>（3）认为synchronized只能修饰方法和代码块</h4>\n<p>\n  误区：只知道synchronized可以修饰方法和代码块，不清楚它还可以修饰静态方法。\n  纠正：synchronized也可以修饰静态方法，此时它锁的是该类的Class对象，而不是实例对象。\n</p>\n<h3>6. 总结回答</h3>\n<p>“在Java中，synchronized用于实现线程同步。其实现原理基于Java对象头和Monitor机制。</p>\n<p>当synchronized修饰代码块时，编译后会在代码块开始处插入<code>monitorenter</code>指令，结束处插入<code>monitorexit</code>指令。线程执行<code>monitorenter</code>时尝试获取对象关联的Monitor，若Monitor计数器为0则可获取并将计数器加1后进入代码块；执行<code>monitorexit</code>时将计数器减1，减为0时释放Monitor。</p>\n<p>当synchronized修饰方法时，编译后的方法访问标志位会设置<code>ACC_SYNCHRONIZED</code>标志，线程调用方法时JVM检查该标志，若有则先获取方法所属对象的Monitor，执行完方法后自动释放。</p>\n<p>此外，为提高性能，synchronized有锁的升级机制，依次为无锁状态、偏向锁、轻量级锁和重量级锁。偏向锁适用于单线程访问，轻量级锁适用于多线程交替访问，重量级锁适用于多线程同时竞争。</p>\n<p>不过，要注意synchronized并非总是性能差，JDK 1.6之后的优化使其在不同场景有较好表现；同时要清楚不同锁状态的使用场景，且synchronized不仅能修饰实例方法和代码块，还能修饰静态方法。”</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>java.util.concurrent包</strong><br>提示：与synchronized相比，使用哪些工具和类来实现线程安全？</p>\n  </li>\n  <li>\n    <p><strong>死锁</strong><br>提示：什么是死锁？如何避免或解决死锁问题？</p>\n  </li>\n  <li>\n    <p><strong>性能影响</strong><br>提示：synchronized在高并发场景下对性能的影响有哪些？能否举例说明？</p>\n  </li>\n  <li>\n    <p><strong>内置锁与显示锁</strong><br>提示：什么是显示锁（ReentrantLock）？和synchronized相比有哪些优缺点？</p>\n  </li>\n  <li>\n    <p><strong>锁的竞争</strong><br>提示：锁竞争是什么？如何可以减少锁竞争带来的性能瓶颈？</p>\n  </li>\n  <li>\n    <p><strong>偏向锁与轻量级锁</strong><br>提示：JVM中如何实现偏向锁和轻量级锁？它们有什么不同？</p>\n  </li>\n  <li>\n    <p><strong>JMM（Java Memory Model）</strong><br>提示：Java内存模型对synchronized的实现有什么影响？</p>\n  </li>\n  <li>\n    <p><strong>可重入性</strong><br>提示：synchronized锁是可重入的吗？如果是，如何理解这个特性？</p>\n  </li>\n  <li>\n    <p><strong>类级锁与实例级锁</strong><br>提示：synchronized锁是如何区分类级锁和实例级锁的？</p>\n  </li>\n  <li>\n    <p><strong>Atomic变量</strong><br>提示：在什么情况下你会选择使用Atomic变量而不是synchronized关键字？</p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  synchronized\n    监视器锁(Monitor Lock)\n    方法级同步和块级同步\n      方法级同步\n      块级同步\n    锁的获取与释放\n    JVM 实现\n    性能开销\n    其他关键点\n      可重入性\n      条件变量",
    "keynote": "- `synchronized` 用于实现线程安全。\n- 每个对象都有一个监视器锁，通过获取和释放这个锁来实现互斥。\n- 方法级同步应用于实例方法或静态方法。\n- 块级同步允许在特定代码块上使用 `synchronized` 关键字。\n- 线程进入 `synchronized` 区域时尝试获取锁，如果锁被占用则阻塞等待。\n- 完成执行后，线程自动释放锁。\n- Java 使用 `monitorenter` 和 `monitorexit` 指令支持 `synchronized` 机制。\n- `synchronized` 引入性能开销，但JDK 1.6+版本进行了优化（如偏向锁、轻量级锁）以减少开销。\n- `synchronized` 支持可重入性。\n- 可利用 `wait()`、`notify()` 和 `notifyAll()` 进行线程间通信。",
    "group_id": 5,
    "kps": [
      "多线程",
      "JVM"
    ],
    "years": [
      2024,
      2023,
      2022
    ],
    "corps": [
      "中国联通",
      "淘天集团",
      "快手",
      "小米",
      "帆软",
      "货拉拉",
      "白龙马",
      "字节跳动"
    ]
  }
}