{
  "success": true,
  "data": {
    "id": 13754,
    "name": "<p>简述 AQS（AbstractQueuedSynchronizer）</p>",
    "options": null,
    "answer": "<p><code>AbstractQueuedSynchronizer</code>（简称 AQS）是 Java 并发包（<code>java.util.concurrent</code>）中一个非常重要的抽象类，它为构建锁和同步器提供了一个通用的框架，许多 Java 并发工具类如 <code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code> 等都是基于 AQS 实现的。以下从几个方面对 AQS 进行简述：</p>\n<h3>1. 核心思想</h3>\n<p>AQS 的核心思想是使用一个 <code>volatile</code> 修饰的整数变量 <code>state</code> 来表示同步状态，通过 CAS（Compare-And-Swap）操作来原子性地修改这个状态值，以此来实现多线程之间的同步。同时，AQS 维护了一个 FIFO（先进先出）的双向队列，用于管理那些获取同步状态失败而被阻塞的线程。</p>\n<h3>2. 主要属性</h3>\n<ul>\n  <li><strong><code>state</code></strong>：一个 <code>volatile</code> 修饰的整数，用于表示同步状态。不同的同步器可以根据自身需求来定义 <code>state</code> 的含义，例如在 <code>ReentrantLock</code> 中，<code>state</code> 表示锁被重入的次数，初始值为 0 表示锁未被持有，每重入一次 <code>state</code> 值加 1，释放锁时 <code>state</code> 值减 1。</li>\n  <li><strong><code>head</code> 和 <code>tail</code></strong>：分别指向 FIFO 队列的头节点和尾节点，用于管理等待获取同步状态的线程。</li>\n</ul>\n<h3>3. 主要方法</h3>\n<h4>3.1 状态操作方法</h4>\n<ul>\n  <li><strong><code>getState()</code></strong>：获取当前同步状态。</li>\n  <li><strong><code>setState(int newState)</code></strong>：设置当前同步状态。</li>\n  <li><strong><code>compareAndSetState(int expect, int update)</code></strong>：使用 CAS 操作将同步状态从期望值 <code>expect</code> 更新为新值 <code>update</code>，如果更新成功则返回 <code>true</code>，否则返回 <code>false</code>。</li>\n</ul>\n<h4>3.2 独占式获取和释放同步状态</h4>\n<ul>\n  <li><strong><code>acquire(int arg)</code></strong>：独占式获取同步状态。如果当前线程获取同步状态成功，则直接返回；否则，将当前线程加入到等待队列中，并阻塞直到获取到同步状态。</li>\n  <li><strong><code>release(int arg)</code></strong>：独占式释放同步状态。释放同步状态后，会唤醒等待队列中第一个等待的线程。</li>\n</ul>\n<h4>3.3 共享式获取和释放同步状态</h4>\n<ul>\n  <li><strong><code>acquireShared(int arg)</code></strong>：共享式获取同步状态。如果当前线程获取同步状态成功，则直接返回；否则，将当前线程加入到等待队列中，并阻塞直到获取到同步状态。</li>\n  <li><strong><code>releaseShared(int arg)</code></strong>：共享式释放同步状态。释放同步状态后，会唤醒等待队列中后续等待的线程。</li>\n</ul>\n<h3>4. 自定义同步器</h3>\n<p>AQS 是一个抽象类，它提供了一些模板方法供子类实现，子类可以通过重写这些方法来实现自定义的同步器。通常需要重写的方法有：</p>\n<ul>\n  <li><strong><code>tryAcquire(int arg)</code></strong>：尝试独占式获取同步状态，需要子类根据自身逻辑实现。</li>\n  <li><strong><code>tryRelease(int arg)</code></strong>：尝试独占式释放同步状态，需要子类根据自身逻辑实现。</li>\n  <li><strong><code>tryAcquireShared(int arg)</code></strong>：尝试共享式获取同步状态，需要子类根据自身逻辑实现。</li>\n  <li><strong><code>tryReleaseShared(int arg)</code></strong>：尝试共享式释放同步状态，需要子类根据自身逻辑实现。</li>\n</ul>\n<h3>5. 示例代码</h3>\n<p>以下是一个简单的自定义同步器示例，实现一个简单的互斥锁：</p>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.AbstractQueuedSynchronizer;\n\n// 自定义同步器\nclass Mutex {\n    private static class Sync extends AbstractQueuedSynchronizer {\n        // 尝试获取同步状态\n        @Override\n        protected boolean tryAcquire(int arg) {\n            if (compareAndSetState(0, 1)) {\n                setExclusiveOwnerThread(Thread.currentThread());\n                return true;\n            }\n            return false;\n        }\n\n        // 尝试释放同步状态\n        @Override\n        protected boolean tryRelease(int arg) {\n            if (getState() == 0) {\n                throw new IllegalMonitorStateException();\n            }\n            setExclusiveOwnerThread(null);\n            setState(0);\n            return true;\n        }\n\n        // 判断是否处于占用状态\n        @Override\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n    }\n\n    private final Sync sync = new Sync();\n\n    // 加锁\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    // 解锁\n    public void unlock() {\n        sync.release(1);\n    }\n}\n\n// 测试代码\npublic class Main {\n    public static void main(String[] args) {\n        Mutex mutex = new Mutex();\n\n        // 线程 1\n        Thread t1 = new Thread(() -> {\n            mutex.lock();\n            try {\n                System.out.println(\"Thread 1 acquired the lock.\");\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                mutex.unlock();\n                System.out.println(\"Thread 1 released the lock.\");\n            }\n        });\n\n        // 线程 2\n        Thread t2 = new Thread(() -> {\n            mutex.lock();\n            try {\n                System.out.println(\"Thread 2 acquired the lock.\");\n            } finally {\n                mutex.unlock();\n                System.out.println(\"Thread 2 released the lock.\");\n            }\n        });\n\n        t1.start();\n        t2.start();\n    }\n}\n</code></pre>\n<p>在上述示例中，我们自定义了一个 <code>Mutex</code> 类，它内部使用了一个继承自 <code>AbstractQueuedSynchronizer</code> 的 <code>Sync</code> 类来实现同步逻辑。通过重写 <code>tryAcquire</code> 和 <code>tryRelease</code> 方法，我们实现了一个简单的互斥锁。</p>\n<h3>6. 总结</h3>\n<p>AQS 是 Java 并发包中一个强大的同步框架，它通过 <code>state</code> 变量和 FIFO 队列，为实现各种同步器提供了统一的基础。通过继承 AQS 并重写相应的方法，我们可以方便地实现自定义的同步器，从而满足不同的并发需求。</p>",
    "type": 6,
    "level": 3,
    "freq": 0.006831319,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：简述 AQS（AbstractQueuedSynchronizer）。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对 AQS 基本概念的理解。</li>\n      <li>AQS 的工作原理。</li>\n      <li>AQS 的使用场景。</li>\n      <li>AQS 在 Java 并发包中的地位和作用。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Java 并发编程</h4>\n<p>在多线程编程中，需要对共享资源进行同步控制，以避免数据不一致等问题。传统的同步方式如<code>synchronized</code>关键字，但它不够灵活。Java 并发包（JUC）提供了更高级的同步工具，AQS 是其中的核心基础组件。</p>\n<h4>（2）同步状态管理</h4>\n<p>同步状态是指用于表示共享资源是否被占用的状态，如锁的状态（锁定或解锁）。对同步状态的管理是实现同步控制的关键。</p>\n<h3>3. 解析</h3>\n<h4>（1）AQS 基本概念</h4>\n<p>AQS 是一个抽象类，位于<code>java.util.concurrent.locks</code>包下，是 Java 并发包中实现锁和其他同步组件的基础框架。它通过一个<code>int</code>类型的状态变量（<code>state</code>）来表示同步状态，并提供了一系列方法来操作这个状态，如<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code>。</p>\n<h4>（2）工作原理</h4>\n<ul>\n  <li><strong>同步状态管理</strong>：AQS 使用<code>state</code>变量来表示同步状态，通过 CAS（Compare-And-Swap）操作来保证对<code>state</code>的原子性更新。例如，当一个线程尝试获取锁时，会通过 CAS 操作将<code>state</code>从 0 变为 1，如果成功则表示获取锁成功。</li>\n  <li><strong>队列管理</strong>：AQS 内部维护了一个 FIFO（先进先出）的双向队列，用于管理那些获取同步状态失败的线程。当一个线程获取同步状态失败时，会被封装成一个节点加入到队列中，并进入阻塞状态。当持有同步状态的线程释放状态时，会从队列中唤醒一个等待的线程。</li>\n</ul>\n<h4>（3）使用场景</h4>\n<p>AQS 可以用来实现各种同步组件，如<code>ReentrantLock</code>（可重入锁）、<code>CountDownLatch</code>（倒计时门闩）、<code>Semaphore</code>（信号量）等。这些同步组件都是基于 AQS 实现的，通过重写 AQS 的一些方法来实现不同的同步逻辑。</p>\n<h4>（4）在 Java 并发包中的地位和作用</h4>\n<p>AQS 是 Java 并发包的核心基础，它为并发包中的各种同步组件提供了统一的实现框架，使得开发者可以方便地实现自定义的同步组件。通过继承 AQS 并重写其部分方法，开发者可以根据自己的需求实现不同的同步策略。</p>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.AbstractQueuedSynchronizer;\n\n// 自定义一个简单的独占锁\nclass SimpleLock {\n    private final Sync sync = new Sync();\n\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    public void unlock() {\n        sync.release(1);\n    }\n\n    private static class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire(int arg) {\n            if (compareAndSetState(0, 1)) {\n                setExclusiveOwnerThread(Thread.currentThread());\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        protected boolean tryRelease(int arg) {\n            if (getState() == 0) {\n                throw new IllegalMonitorStateException();\n            }\n            setExclusiveOwnerThread(null);\n            setState(0);\n            return true;\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        SimpleLock lock = new SimpleLock();\n        lock.lock();\n        try {\n            // 临界区代码\n            System.out.println(\"进入临界区\");\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n</code></pre>\n<p>在这个例子中，我们自定义了一个简单的独占锁<code>SimpleLock</code>，它基于 AQS 实现。<code>Sync</code>类继承自 AQS，并重写了<code>tryAcquire</code>和<code>tryRelease</code>方法来实现锁的获取和释放逻辑。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）认为 AQS 就是锁</h4>\n<p>\n  误区：将 AQS 等同于锁，忽略了 AQS 是一个基础框架，可以用来实现各种同步组件。\n  纠正：AQS 是一个基础框架，锁只是它的一种应用场景，还可以用来实现其他同步组件。\n</p>\n<h4>（2）不理解 AQS 的队列管理</h4>\n<p>\n  误区：不清楚 AQS 内部的队列是如何管理等待线程的。\n  纠正：AQS 内部维护了一个 FIFO 的双向队列，用于管理获取同步状态失败的线程，当持有同步状态的线程释放状态时，会从队列中唤醒一个等待的线程。\n</p>\n<h4>（3）重写 AQS 方法时不遵循规范</h4>\n<p>\n  误区：在重写 AQS 的方法时，没有遵循其规范，导致同步逻辑出现问题。\n  纠正：在重写 AQS 的方法时，需要遵循其规范，如<code>tryAcquire</code>和<code>tryRelease</code>方法需要保证原子性和正确性。\n</p>\n<h3>6. 总结回答</h3>\n<p>AQS（AbstractQueuedSynchronizer）是 Java 并发包中实现锁和其他同步组件的基础框架，位于<code>java.util.concurrent.locks</code>包下。它通过一个<code>int</code>类型的状态变量<code>state</code>来表示同步状态，并使用 CAS 操作保证对<code>state</code>的原子性更新。</p>\n<p>AQS 内部维护了一个 FIFO 的双向队列，用于管理获取同步状态失败的线程。当一个线程获取同步状态失败时，会被封装成一个节点加入到队列中并进入阻塞状态；当持有同步状态的线程释放状态时，会从队列中唤醒一个等待的线程。</p>\n<p>AQS 可以用来实现各种同步组件，如<code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code>等。开发者可以通过继承 AQS 并重写其部分方法来实现自定义的同步策略。</p>\n<p>不过，需要注意的是，AQS 是一个基础框架，不等同于锁；在重写 AQS 的方法时，需要遵循其规范，以保证同步逻辑的正确性。</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      AQS 中 state 变量的作用是什么，它是如何保证线程安全的？\n      提示：思考 state 变量在同步状态管理中的角色，以及 AQS 采用的原子操作。\n    </p>\n  </li>\n  <li>\n    <p>\n      简述 AQS 中独占模式和共享模式的区别，在代码实现上有哪些不同？\n      提示：从获取和释放资源的逻辑、等待队列的处理等方面对比两种模式。\n    </p>\n  </li>\n  <li>\n    <p>\n      AQS 的等待队列是如何实现的，节点在队列中有哪些状态？\n      提示：关注队列的结构（如双向链表），以及节点状态（如初始化、等待中、取消等）。\n    </p>\n  </li>\n  <li>\n    <p>\n      当多个线程同时竞争 AQS 资源时，是如何进行排队和唤醒的？\n      提示：考虑线程入队和出队的逻辑，以及唤醒机制（如头节点唤醒后继节点）。\n    </p>\n  </li>\n  <li>\n    <p>\n      如何基于 AQS 实现一个自定义的同步器，简述主要步骤。\n      提示：思考需要重写的方法（如 tryAcquire、tryRelease 等）和状态管理。\n    </p>\n  </li>\n  <li>\n    <p>\n      AQS 中自旋锁和阻塞锁是如何结合使用的，有什么好处？\n      提示：分析在不同场景下自旋和阻塞的切换，以及对性能的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      在 AQS 中，中断是如何处理的，对同步操作有什么影响？\n      提示：关注线程中断时的状态变化和资源释放逻辑。\n    </p>\n  </li>\n  <li>\n    <p>\n      AQS 的公平锁和非公平锁在实现上有什么差异，分别适用于什么场景？\n      提示：对比获取资源时是否考虑队列顺序，以及不同场景下的性能表现。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((AbstractQueuedSynchronizer（AQS）简述))\n    核心思想\n      使用volatile修饰的state表示同步状态\n      通过CAS操作原子性修改状态值\n      维护FIFO双向队列管理阻塞线程\n    主要属性\n      state\n      head和tail\n    主要方法\n      状态操作方法\n        getState()\n        setState(int newState)\n        compareAndSetState(int expect, int update)\n      独占式获取和释放同步状态\n        acquire(int arg)\n        release(int arg)\n      共享式获取和释放同步状态\n        acquireShared(int arg)\n        releaseShared(int arg)\n    自定义同步器\n      tryAcquire(int arg)\n      tryRelease(int arg)\n      tryAcquireShared(int arg)\n      tryReleaseShared(int arg)\n    总结\n      强大同步框架\n      提供统一基础\n      方便实现自定义同步器",
    "keynote": "AQS是Java并发包重要抽象类，为构建锁和同步器提供通用框架\n核心思想：用volatile修饰的state表示同步状态，通过CAS操作修改，维护FIFO双向队列管理阻塞线程\n主要属性：state、head和tail\n主要方法：状态操作（getState、setState、compareAndSetState）；独占式（acquire、release）；共享式（acquireShared、releaseShared）\n自定义同步器：重写tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared\n总结：强大同步框架，提供统一基础，方便实现自定义同步器",
    "group_id": 5,
    "kps": [
      "高级特性"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "小红书",
      "运去哪",
      "百度",
      "得物",
      "4399",
      "用友",
      "首约科技",
      "货拉拉",
      "小米",
      "武汉某小厂",
      "阿里国际",
      "曹操出行",
      "58同城",
      "美团",
      "阿里巴巴",
      "奈雪的茶",
      "京东",
      "快手",
      "OPPO",
      "Shopee虾皮",
      "携程",
      "贝壳",
      "欢聚集团",
      "同程旅行",
      "帆软",
      "腾讯"
    ]
  }
}