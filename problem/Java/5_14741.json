{
  "success": true,
  "data": {
    "id": 14741,
    "name": "<p>列举你使用过的Java集合</p>",
    "options": null,
    "answer": "<p>在 Java 中，集合框架提供了一套用于存储和操作数据的接口和类，主要分为 <code>Collection</code> 和 <code>Map</code> 两大体系。以下是一些常用的 Java 集合及其使用场景和示例代码。</p>\n<h3><code>Collection</code> 体系</h3>\n<h4>1. <code>List</code> 接口</h4>\n<p><code>List</code> 是一个有序的集合，允许存储重复的元素。</p>\n<ul>\n  <li><strong><code>ArrayList</code></strong>\n    <ul>\n      <li><strong>特点</strong>：基于动态数组实现，随机访问速度快，插入和删除操作在末尾效率高，在中间或开头效率低。</li>\n      <li><strong>使用场景</strong>：适用于需要频繁随机访问元素的场景。</li>\n      <li><strong>示例代码</strong>：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-java\">import java.util.ArrayList;\nimport java.util.List;\n\npublic class ArrayListExample {\n    public static void main(String[] args) {\n        List&#x3C;String> list = new ArrayList&#x3C;>();\n        list.add(\"apple\");\n        list.add(\"banana\");\n        list.add(\"cherry\");\n        System.out.println(list.get(1)); // 输出: banana\n    }\n}\n</code></pre>\n<ul>\n  <li><strong><code>LinkedList</code></strong>\n    <ul>\n      <li><strong>特点</strong>：基于双向链表实现，插入和删除操作效率高，随机访问速度慢。</li>\n      <li><strong>使用场景</strong>：适用于需要频繁插入和删除元素的场景。</li>\n      <li><strong>示例代码</strong>：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-java\">import java.util.LinkedList;\nimport java.util.List;\n\npublic class LinkedListExample {\n    public static void main(String[] args) {\n        List&#x3C;String> list = new LinkedList&#x3C;>();\n        list.add(\"apple\");\n        list.add(\"banana\");\n        list.add(\"cherry\");\n        list.add(1, \"date\");\n        System.out.println(list); // 输出: [apple, date, banana, cherry]\n    }\n}\n</code></pre>\n<h4>2. <code>Set</code> 接口</h4>\n<p><code>Set</code> 是一个不允许存储重复元素的集合。</p>\n<ul>\n  <li><strong><code>HashSet</code></strong>\n    <ul>\n      <li><strong>特点</strong>：基于哈希表实现，不保证元素的顺序，插入、删除和查找操作的时间复杂度为 O(1)。</li>\n      <li><strong>使用场景</strong>：适用于需要快速查找元素是否存在的场景。</li>\n      <li><strong>示例代码</strong>：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-java\">import java.util.HashSet;\nimport java.util.Set;\n\npublic class HashSetExample {\n    public static void main(String[] args) {\n        Set&#x3C;String> set = new HashSet&#x3C;>();\n        set.add(\"apple\");\n        set.add(\"banana\");\n        set.add(\"apple\"); // 重复元素，不会被添加\n        System.out.println(set.contains(\"banana\")); // 输出: true\n    }\n}\n</code></pre>\n<ul>\n  <li><strong><code>TreeSet</code></strong>\n    <ul>\n      <li><strong>特点</strong>：基于红黑树实现，元素会按照自然顺序或指定的比较器进行排序。</li>\n      <li><strong>使用场景</strong>：适用于需要对元素进行排序的场景。</li>\n      <li><strong>示例代码</strong>：</li>\n    </ul>\n  </li>\n</ul>\n<pre><code class=\"language-java\">import java.util.TreeSet;\nimport java.util.Set;\n\npublic class TreeSetExample {\n    public static void main(String[] args) {\n        Set&#x3C;Integer> set = new TreeSet&#x3C;>();\n        set.add(3);\n        set.add(1);\n        set.add(2);\n        System.out.println(set); // 输出: [1, 2, 3]\n    }\n}\n</code></pre>\n<h3><code>Map</code> 体系</h3>\n<h4>1. <code>HashMap</code></h4>\n<ul>\n  <li><strong>特点</strong>：基于哈希表实现，键不允许重复，键和值都可以为 <code>null</code>，不保证元素的顺序。</li>\n  <li><strong>使用场景</strong>：适用于需要快速根据键查找值的场景。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.HashMap;\nimport java.util.Map;\n\npublic class HashMapExample {\n    public static void main(String[] args) {\n        Map&#x3C;String, Integer> map = new HashMap&#x3C;>();\n        map.put(\"apple\", 1);\n        map.put(\"banana\", 2);\n        System.out.println(map.get(\"banana\")); // 输出: 2\n    }\n}\n</code></pre>\n<h4>2. <code>TreeMap</code></h4>\n<ul>\n  <li><strong>特点</strong>：基于红黑树实现，键会按照自然顺序或指定的比较器进行排序，键不允许为 <code>null</code>。</li>\n  <li><strong>使用场景</strong>：适用于需要对键进行排序的场景。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.TreeMap;\nimport java.util.Map;\n\npublic class TreeMapExample {\n    public static void main(String[] args) {\n        Map&#x3C;String, Integer> map = new TreeMap&#x3C;>();\n        map.put(\"banana\", 2);\n        map.put(\"apple\", 1);\n        System.out.println(map); // 输出: {apple=1, banana=2}\n    }\n}\n</code></pre>",
    "type": 6,
    "level": 1,
    "freq": 0.01086005,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：列举使用过的Java集合。</li>\n  <li><strong>考察点</strong>：对Java集合框架的了解，包括不同集合类型的特点和使用场景。</li>\n</ul>\n<h3>2. 背景知识</h3>\n<p>Java集合框架主要分为两大体系：Collection和Map。Collection是单列集合，存储单个元素；Map是双列集合，存储键值对。</p>\n<h3>3. 解析</h3>\n<h4>（1）Collection体系</h4>\n<ul>\n  <li><strong>List接口</strong>\n    <ul>\n      <li><strong>ArrayList</strong>：基于动态数组实现，支持随机访问，查找元素速度快，但插入和删除元素效率较低，尤其是在数组中间位置操作。适用于需要频繁查找元素的场景。</li>\n      <li><strong>LinkedList</strong>：基于双向链表实现，插入和删除元素效率高，尤其是在链表头部和尾部操作，但随机访问速度慢。适用于需要频繁插入和删除元素的场景。</li>\n      <li><strong>Vector</strong>：和ArrayList类似，也是基于动态数组实现，但它是线程安全的，不过性能相对较低。在多线程环境下，如果对性能要求不高且需要线程安全时可以使用。</li>\n    </ul>\n  </li>\n  <li><strong>Set接口</strong>\n    <ul>\n      <li><strong>HashSet</strong>：基于哈希表实现，不允许存储重复元素，元素无序。它通过元素的hashCode()和equals()方法来判断元素是否重复。适用于需要快速查找元素且不关心元素顺序的场景。</li>\n      <li><strong>TreeSet</strong>：基于红黑树实现，不允许存储重复元素，元素会按照自然顺序或指定的比较器顺序进行排序。适用于需要对元素进行排序的场景。</li>\n      <li><strong>LinkedHashSet</strong>：继承自HashSet，同时使用链表维护元素的插入顺序，保证元素有序。适用于需要保证元素插入顺序的场景。</li>\n    </ul>\n  </li>\n</ul>\n<h4>（2）Map体系</h4>\n<ul>\n  <li><strong>HashMap</strong>：基于哈希表实现，存储键值对，键不允许重复。它通过键的hashCode()和equals()方法来判断键是否重复。查找、插入和删除操作的时间复杂度接近O(1)。适用于需要快速查找键值对的场景。</li>\n  <li><strong>TreeMap</strong>：基于红黑树实现，存储键值对，键会按照自然顺序或指定的比较器顺序进行排序。适用于需要对键进行排序的场景。</li>\n  <li><strong>LinkedHashMap</strong>：继承自HashMap，同时使用链表维护元素的插入顺序或访问顺序。适用于需要保证元素插入顺序或访问顺序的场景。</li>\n  <li><strong>Hashtable</strong>：和HashMap类似，也是存储键值对，但它是线程安全的，不过性能相对较低。在多线程环境下，如果对性能要求不高且需要线程安全时可以使用。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">import java.util.*;\n\npublic class CollectionExample {\n    public static void main(String[] args) {\n        // List示例\n        List&#x3C;String> arrayList = new ArrayList&#x3C;>();\n        arrayList.add(\"apple\");\n        arrayList.add(\"banana\");\n        System.out.println(\"ArrayList: \" + arrayList);\n\n        List&#x3C;String> linkedList = new LinkedList&#x3C;>();\n        linkedList.add(\"cherry\");\n        linkedList.add(\"date\");\n        System.out.println(\"LinkedList: \" + linkedList);\n\n        // Set示例\n        Set&#x3C;String> hashSet = new HashSet&#x3C;>();\n        hashSet.add(\"apple\");\n        hashSet.add(\"banana\");\n        System.out.println(\"HashSet: \" + hashSet);\n\n        Set&#x3C;String> treeSet = new TreeSet&#x3C;>();\n        treeSet.add(\"cherry\");\n        treeSet.add(\"date\");\n        System.out.println(\"TreeSet: \" + treeSet);\n\n        // Map示例\n        Map&#x3C;String, Integer> hashMap = new HashMap&#x3C;>();\n        hashMap.put(\"apple\", 1);\n        hashMap.put(\"banana\", 2);\n        System.out.println(\"HashMap: \" + hashMap);\n\n        Map&#x3C;String, Integer> treeMap = new TreeMap&#x3C;>();\n        treeMap.put(\"cherry\", 3);\n        treeMap.put(\"date\", 4);\n        System.out.println(\"TreeMap: \" + treeMap);\n    }\n}\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆List和Set的特点</h4>\n<ul>\n  <li>误区：认为List和Set都可以存储重复元素。</li>\n  <li>纠正：List可以存储重复元素，而Set不允许存储重复元素。</li>\n</ul>\n<h4>（2）不了解线程安全的集合</h4>\n<ul>\n  <li>误区：在多线程环境下随意使用非线程安全的集合。</li>\n  <li>纠正：在多线程环境下，如果需要线程安全，可以使用Vector、Hashtable或使用Collections工具类将非线程安全的集合转换为线程安全的集合。</li>\n</ul>\n<h4>（3）不考虑集合的性能特点</h4>\n<ul>\n  <li>误区：在需要频繁插入和删除元素的场景中使用ArrayList。</li>\n  <li>纠正：应根据具体的使用场景选择合适的集合，如在需要频繁插入和删除元素的场景中使用LinkedList。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>我使用过的Java集合主要分为Collection和Map两大体系。在Collection体系中，有List接口下的ArrayList、LinkedList、Vector，Set接口下的HashSet、TreeSet、LinkedHashSet；在Map体系中，有HashMap、TreeMap、LinkedHashMap、Hashtable。</p>\n<p>ArrayList基于动态数组，适合频繁查找；LinkedList基于双向链表，适合频繁插入和删除；Vector是线程安全的动态数组。HashSet基于哈希表，元素无序且不重复；TreeSet基于红黑树，元素有序且不重复；LinkedHashSet保证元素插入顺序。HashMap基于哈希表，快速查找键值对；TreeMap基于红黑树，键有序；LinkedHashMap保证键值对插入或访问顺序；Hashtable是线程安全的哈希表。在使用时，要根据具体场景选择合适的集合，同时注意线程安全和性能问题。</p>",
    "more_ask": "<h3>1. 集合线程安全性相关</h3>\n<ul>\n  <li><strong>问题</strong>：你提到的这些集合中，哪些是线程安全的，哪些是非线程安全的？在多线程环境下，非线程安全的集合会出现什么问题，如何解决？</li>\n  <li><strong>提示</strong>：思考集合类的源码或官方文档中关于线程安全的描述，非线程安全集合在多线程操作时数据的一致性问题，解决方法可从 Java 提供的同步机制或线程安全集合类入手。</li>\n</ul>\n<h3>2. 集合性能相关</h3>\n<ul>\n  <li><strong>问题</strong>：以你常用的 <code>ArrayList</code> 和 <code>LinkedList</code> 为例，它们在插入、删除和查找操作上的时间复杂度分别是多少？在什么场景下应该优先选择 <code>ArrayList</code>，什么场景下优先选择 <code>LinkedList</code>？</li>\n  <li><strong>提示</strong>：回顾数据结构中数组和链表的特性，插入和删除操作在不同位置的复杂度差异，根据操作频率和数据量大小来判断使用场景。</li>\n</ul>\n<h3>3. 集合底层实现原理</h3>\n<ul>\n  <li><strong>问题</strong>：<code>HashMap</code> 的底层数据结构是什么？它是如何解决哈希冲突的？</li>\n  <li><strong>提示</strong>：了解 <code>HashMap</code> 在 JDK 不同版本的底层结构变化，哈希冲突的常见解决方法，如链地址法、开放地址法等。</li>\n</ul>\n<h3>4. 集合扩容机制</h3>\n<ul>\n  <li><strong>问题</strong>：<code>ArrayList</code> 的扩容机制是怎样的？扩容时会带来什么性能开销？</li>\n  <li><strong>提示</strong>：查看 <code>ArrayList</code> 源码中关于扩容的方法，思考扩容过程中涉及的数组复制操作对性能的影响。</li>\n</ul>\n<h3>5. 集合迭代器相关</h3>\n<ul>\n  <li><strong>问题</strong>：在使用集合的迭代器时，调用 <code>Iterator.remove()</code> 方法和直接调用集合的 <code>remove()</code> 方法有什么区别？</li>\n  <li><strong>提示</strong>：考虑迭代器的工作原理，以及直接调用集合的 <code>remove()</code> 方法可能对迭代器产生的影响，如 <code>ConcurrentModificationException</code> 异常。</li>\n</ul>\n<h3>6. 集合排序相关</h3>\n<ul>\n  <li><strong>问题</strong>：如何对 <code>List</code> 集合进行排序？<code>Collections.sort()</code> 和 <code>List.sort()</code> 有什么区别？</li>\n  <li><strong>提示</strong>：了解 Java 中排序的两种方式，即实现 <code>Comparable</code> 接口和使用 <code>Comparator</code> 比较器，对比 <code>Collections.sort()</code> 和 <code>List.sort()</code> 的使用场景和底层实现。</li>\n</ul>\n<h3>7. 集合泛型相关</h3>\n<ul>\n  <li><strong>问题</strong>：使用集合时为什么要使用泛型？泛型擦除是怎么回事，会带来什么影响？</li>\n  <li><strong>提示</strong>：思考泛型在类型安全和代码可读性方面的优势，泛型擦除是 Java 泛型实现的一种机制，了解其在运行时的表现和可能引发的问题。</li>\n</ul>",
    "mindmap": "mindmap\n  root((Java集合框架))\n    Collection体系\n      List接口\n        ArrayList\n          特点：基于动态数组，随机访问快，末尾插入删除效率高\n          使用场景：频繁随机访问元素\n        LinkedList\n          特点：基于双向链表，插入删除效率高，随机访问慢\n          使用场景：频繁插入删除元素\n      Set接口\n        HashSet\n          特点：基于哈希表，不保证顺序，插入删除查找O(1)\n          使用场景：快速查找元素是否存在\n        TreeSet\n          特点：基于红黑树，元素排序\n          使用场景：对元素进行排序\n    Map体系\n      HashMap\n        特点：基于哈希表，键不重复，键值可null，不保证顺序\n        使用场景：快速根据键查找值\n      TreeMap\n        特点：基于红黑树，键排序，键不可null\n        使用场景：对键进行排序",
    "keynote": "Java集合框架分Collection和Map两大体系\nCollection体系\n  List接口：有序，可存重复元素\n    ArrayList：动态数组，随机访问快，适用于频繁随机访问\n    LinkedList：双向链表，插入删除快，适用于频繁插入删除\n  Set接口：不允许重复元素\n    HashSet：哈希表，查找快，适用于快速查找元素是否存在\n    TreeSet：红黑树，元素排序，适用于对元素排序\nMap体系\n  HashMap：哈希表，键不重复，键值可null，适用于快速根据键查找值\n  TreeMap：红黑树，键排序，键不可null，适用于对键排序",
    "group_id": 5,
    "kps": [
      "集合框架"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "中科创达",
      "海致科技",
      "比亚迪",
      "华为OD",
      "美团",
      "中金所",
      "网易",
      "字节跳动",
      "东软",
      "金蝶",
      "小西科技",
      "4399",
      "泰豪软件",
      "货拉拉",
      "中科软",
      "杭州盒马",
      "招银网络科技",
      "合思",
      "360",
      "友谊时光",
      "武汉某小厂",
      "数字马力",
      "小米",
      "腾讯",
      "赛轮集团",
      "华为",
      "快手",
      "OPPO",
      "科大讯飞",
      "满帮集团",
      "Shopee虾皮",
      "滴滴",
      "携程",
      "顺丰",
      "大华",
      "B站",
      "用友",
      "交行软开",
      "浩鲸科技",
      "帆软",
      "百度",
      "北大软件"
    ]
  }
}