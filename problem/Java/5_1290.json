{"success":true,"data":{"id":1290,"name":"<p>HashMap的底层数据结构是怎样的？</p>","options":null,"answer":"<p>在Java中，<code>HashMap</code> 的底层数据结构主要是数组和链表（或红黑树）。具体来说，<code>HashMap</code> 的实现可以分为以下几个关键部分：</p>\n<ol>\n  <li>\n    <p><strong>数组</strong>：</p>\n    <ul>\n      <li><code>HashMap</code> 使用一个数组来存储桶（bucket）。每个桶可以存储多个键值对（key-value pairs）。</li>\n      <li>数组的大小是 <code>HashMap</code> 的初始容量，默认情况下为 16。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>桶（Bucket）</strong>：</p>\n    <ul>\n      <li>每个桶通常是一个链表，用于处理哈希冲突（即多个不同键经过哈希函数计算后得到同一个数组索引）。</li>\n      <li>当桶中的键值对数量超过一个阈值（树化阈值，默认是8）时，链表将会转换为红黑树，以提高查找效率。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>哈希函数</strong>：</p>\n    <ul>\n      <li><code>HashMap</code> 使用 <code>hashCode()</code> 方法生成键的哈希值，然后通过一个优化的算法将其映射到数组的索引。</li>\n      <li>这个过程还考虑了数组的长度，以减少哈希冲突的概率。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>容量和负载因子</strong>：</p>\n    <ul>\n      <li><code>HashMap</code> 的容量是指桶的数量，负载因子是一个用来衡量何时需要扩容的值（默认是0.75）。当当前元素数量超过容量与负载因子的乘积时，<code>HashMap</code> 会扩容（一般情况下会将数组大小翻倍）。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>扩容</strong>：</p>\n    <ul>\n      <li>扩容的过程会重新计算每个键的哈希值并重新分配到新的数组索引。在扩容时，原数组中的元素需要被重新哈希并复制到新的数组中。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>红黑树</strong>：</p>\n    <ul>\n      <li>在链表中的元素数量达到一定阈值时（默认8），<code>HashMap</code> 会将链表转换为红黑树，以更高效地处理查找、插入和删除操作。红黑树的查找时间复杂度为 O(log n)，而链表的查找时间复杂度为 O(n)。</li>\n    </ul>\n  </li>\n</ol>\n<p>这种结合数组、链表和红黑树的设计使得 <code>HashMap</code> 在插入、删除和查找操作中保持较高的性能，平均时间复杂度为 O(1)。</p>","type":6,"level":3,"freq":0.04641794,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：HashMap的底层数据结构是怎样的？</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对HashMap底层实现原理的掌握。</li>\n      <li>对哈希表、数组、链表和红黑树等数据结构的理解。</li>\n      <li>不同数据结构在HashMap中的作用和使用场景。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）哈希表</h4>\n<p>哈希表是一种根据键（Key）直接访问内存存储位置的数据结构，它通过哈希函数将键映射到存储桶（Bucket）中，以实现快速的数据查找、插入和删除操作。但哈希函数可能会导致不同的键映射到同一个存储桶，即哈希冲突。</p>\n<h4>（2）数组</h4>\n<p>数组是一种线性数据结构，它在内存中是连续存储的，可以通过索引快速访问元素。在HashMap中，数组用于存储哈希表的存储桶。</p>\n<h4>（3）链表</h4>\n<p>链表是一种动态数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的引用。当发生哈希冲突时，多个键值对可能会存储在同一个存储桶中，此时可以使用链表来解决冲突，将这些键值对连接起来。</p>\n<h4>（4）红黑树</h4>\n<p>红黑树是一种自平衡的二叉搜索树，它通过在每个节点上增加一个颜色属性，确保树的高度始终保持在对数级别，从而保证了插入、删除和查找操作的时间复杂度为O(log n)。在HashMap中，当链表长度达到一定阈值时，会将链表转换为红黑树，以提高查找效率。</p>\n<h3>3. 解析</h3>\n<h4>（1）JDK 7及以前的实现</h4>\n<p>在JDK 7及以前，HashMap的底层数据结构是数组 + 链表。具体来说：</p>\n<ul>\n  <li><strong>数组</strong>：作为哈希表的基础结构，数组的每个元素称为一个桶（Bucket），用于存储链表的头节点。数组的长度通常是2的幂次方，这样可以通过位运算来计算键的哈希值对应的桶索引，提高计算效率。</li>\n  <li><strong>链表</strong>：当发生哈希冲突时，即不同的键通过哈希函数计算得到相同的桶索引，这些键值对会以链表的形式存储在同一个桶中。新插入的键值对会插入到链表的头部，这种方式称为头插法。</li>\n</ul>\n<h4>（2）JDK 8及以后的实现</h4>\n<p>在JDK 8及以后，HashMap的底层数据结构是数组 + 链表 + 红黑树。具体来说：</p>\n<ul>\n  <li><strong>数组</strong>：仍然作为哈希表的基础结构，用于存储桶的头节点。</li>\n  <li><strong>链表</strong>：当发生哈希冲突时，新的键值对会以链表的形式存储在同一个桶中。不同的是，JDK 8采用尾插法插入新的键值对，避免了在多线程环境下可能出现的链表成环问题。</li>\n  <li><strong>红黑树</strong>：当链表的长度达到一定阈值（默认为8），并且数组的长度达到64时，链表会转换为红黑树。这样可以将查找、插入和删除操作的时间复杂度从O(n)降低到O(log n)。当红黑树的节点数量减少到一定阈值（默认为6）时，红黑树会转换回链表。</li>\n</ul>\n<h4>（3）哈希函数和桶索引计算</h4>\n<p>为了将键均匀地分布到数组的各个桶中，HashMap使用了一个哈希函数来计算键的哈希值。在JDK 8中，哈希函数的实现如下：</p>\n<pre><code class=\"language-java\">static final int hash(Object key) {\n    int h;\n    return (key == null)? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n</code></pre>\n<p>通过将键的哈希码与其高16位进行异或运算，可以减少哈希冲突的概率。计算得到哈希值后，再通过取模运算（在HashMap中通常使用位运算 <code>(n - 1) &#x26; hash</code>，其中n是数组的长度）来确定键值对应该存储的桶索引。</p>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">import java.util.HashMap;\n\npublic class HashMapExample {\n    public static void main(String[] args) {\n        // 创建一个HashMap对象\n        HashMap&#x3C;String, Integer> map = new HashMap&#x3C;>();\n\n        // 向HashMap中插入键值对\n        map.put(\"apple\", 1);\n        map.put(\"banana\", 2);\n        map.put(\"cherry\", 3);\n\n        // 获取指定键的值\n        Integer value = map.get(\"banana\");\n        System.out.println(\"Value of 'banana': \" + value);\n    }\n}\n</code></pre>\n<p>在这个示例中，我们创建了一个HashMap对象，并向其中插入了三个键值对。通过调用<code>put</code>方法将键值对插入到HashMap中，调用<code>get</code>方法根据键获取对应的值。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）认为HashMap只使用数组或链表</h4>\n<p>\n  误区：只知道HashMap使用数组或链表中的一种数据结构，而忽略了JDK 8及以后引入的红黑树。\n  纠正：JDK 8及以后的HashMap采用数组 + 链表 + 红黑树的复合数据结构，以提高在哈希冲突严重情况下的性能。\n</p>\n<h4>（2）混淆哈希函数和桶索引计算</h4>\n<p>\n  误区：不清楚哈希函数和桶索引计算的区别，认为它们是同一个概念。\n  纠正：哈希函数用于计算键的哈希值，而桶索引计算是根据哈希值确定键值对应该存储的桶位置，通常使用位运算来实现。\n</p>\n<h4>（3）忽略链表和红黑树的转换条件</h4>\n<p>\n  误区：不知道链表和红黑树之间的转换条件，或者认为只要链表长度达到8就会转换为红黑树。\n  纠正：链表转换为红黑树需要同时满足链表长度达到8和数组长度达到64这两个条件；红黑树转换为链表的条件是节点数量减少到6。\n</p>\n<h3>6. 总结回答</h3>\n<p>在JDK 7及以前，HashMap的底层数据结构是数组 + 链表。数组作为哈希表的基础结构，用于存储链表的头节点，当发生哈希冲突时，不同的键值对会以链表的形式存储在同一个桶中，采用头插法插入新节点。</p>\n<p>在JDK 8及以后，HashMap的底层数据结构是数组 + 链表 + 红黑树。数组依然存储桶的头节点，发生哈希冲突时，新的键值对以链表形式存储，采用尾插法。当链表长度达到8且数组长度达到64时，链表会转换为红黑树，以提高查找效率；当红黑树的节点数量减少到6时，红黑树会转换回链表。</p>\n<p>此外，HashMap使用哈希函数计算键的哈希值，并通过位运算确定键值对存储的桶索引。在实际使用中，需要注意链表和红黑树的转换条件，以及哈希函数和桶索引计算的区别。</p>","more_ask":"<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>HashMap中的哈希冲突是如何解决的？</strong></p>\n    <ul>\n      <li>提示：讨论链表和红黑树的使用场景。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在什么情况下HashMap会从链表变为红黑树？</strong></p>\n    <ul>\n      <li>提示：关注负载因子和阈值。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>HashMap的性能在处理大量元素时会受到哪些因素的影响？</strong></p>\n    <ul>\n      <li>提示：考虑负载因子、初始容量、哈希函数等。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何自定义HashMap的哈希函数？有什么注意事项？</strong></p>\n    <ul>\n      <li>提示：讨论避免哈希冲突和分布均匀性。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在多线程环境下，HashMap存在哪些问题？应该如何解决？</strong></p>\n    <ul>\n      <li>提示：思考线程安全和使用ConcurrentHashMap。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>HashMap的resize过程是怎样的，影响性能吗？</strong></p>\n    <ul>\n      <li>提示：探讨扩容的机制和时间复杂度。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>HashMap的put和get操作的时间复杂度是多少？在什么情况下会变得更复杂？</strong></p>\n    <ul>\n      <li>提示：思考最坏情况和平均情况的表现。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>HashMap在JDK 8和之前的版本有何不同？</strong></p>\n    <ul>\n      <li>提示：主要关注性能和数据结构的变化。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何判断一个对象在HashMap中是否可以作为键？</strong></p>\n    <ul>\n      <li>提示：考虑equals和hashCode方法的重写。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>HashMap的迭代器是如何工作的？是否是fail-fast的？</strong></p>\n    <ul>\n      <li>提示：探讨并发修改的情况。</li>\n    </ul>\n  </li>\n</ol>","mindmap":"mindmap\n  root((HashMap))\n    数组\n      存储桶\n      初始容量16\n    桶（Bucket）\n      链表\n      红黑树\n      树化阈值8\n    哈希函数\n      使用hashCode()\n      映射到数组索引\n    容量和负载因子\n      负载因子0.75\n      扩容条件\n    扩容\n      重新哈希\n      重新分配\n    红黑树\n      查找时间O(log n)\n      提高效率","keynote":"- `HashMap` 结合使用数组、链表和红黑树。\n- 数组用于存储桶，默认初始容量为16。\n- 每个桶通过链表处理哈希冲突，超过8个元素时转换成红黑树。\n- 使用`hashCode()`方法生成键的哈希值，并映射到数组索引。\n- 负载因子默认为0.75，控制何时进行扩容。\n- 扩容时会将所有元素重新哈希并分配至新数组。\n- 红黑树提高查找效率，其操作平均时间复杂度为O(log n)。","group_id":5,"kps":["集合框架"],"years":[2025,2024,2023,2022],"corps":["赛力斯","星环","京东","慧策","蔚来","B站","平安金融","北森","中科创达","快手","亿联","诚迈科技","字节跳动","中国联通","卓望","诺瓦星云","鑫火信息","中科全安","小米","慧点科技","用友","哈啰出行","腾讯云智","苏州百邦达","飞猪","亚信科技","美团","阿里巴巴","比亚迪","同花顺","海信集团","经纬恒润","米哈游","招银网络科技","游卡","淘天集团","浩鲸科技","柠檬微趣","陌陌","华为","武汉某小厂","完美世界","北京某游戏公司","4399","SNK中国","交通银行","北京某小厂","微派网络","睿联技术","同程旅行","MiniMax","腾讯","好未来","vivo","绿盟科技","百度","58同城","字节抖音","字节飞书","元启软件","腾讯云","美团优选","饿了么","科大讯飞","途虎养车","钉钉","满帮集团","联影集团","中兴通讯","Shopee虾皮","Singularity Data","滴滴","深信服","拼多多","携程","蚂蚁集团","贝壳","大华","网易","广联达","去哪儿旅行","网易有道","招商银行","平安科技","酷家乐","唯品会","金山","货拉拉","建信金融科技","Momenta","顺丰","爱奇艺","同程旅游","叠纸游戏","字节今日头条","OPPO","WallTech","美团骑行"]}}