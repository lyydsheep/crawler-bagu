{
  "success": true,
  "data": {
    "id": 3187,
    "name": "<p>谈谈 synchronized 和 ReenTrantLock 的区别？</p>",
    "options": null,
    "answer": "<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是 Java 中用于实现线程同步的工具，但它们之间有一些关键的区别。下面是它们的主要区别和特点：</p>\n<h3>1. 基本概念</h3>\n<ul>\n  <li><strong>synchronized</strong>: 是 Java 的一种内置锁，使用起来比较简单，可以直接关键字来同步方法或代码块。</li>\n  <li><strong>ReentrantLock</strong>: 是 Java 提供的一个更灵活的锁，属于 <code>java.util.concurrent.locks</code> 包。它实现了 <code>Lock</code> 接口，提供了更多的功能。</li>\n</ul>\n<h3>2. 代码结构和易用性</h3>\n<ul>\n  <li>\n    <p><strong>synchronized</strong>:</p>\n    <pre><code class=\"language-java\">synchronized (lockObject) {\n    // 临界区代码\n}\n</code></pre>\n    <p>或者</p>\n    <pre><code class=\"language-java\">public synchronized void method() {\n    // 临界区代码\n}\n</code></pre>\n  </li>\n  <li>\n    <p><strong>ReentrantLock</strong>:</p>\n    <pre><code class=\"language-java\">Lock lock = new ReentrantLock();\nlock.lock(); // 获取锁\ntry {\n    // 临界区代码\n} finally {\n    lock.unlock(); // 一定要在finally中释放锁\n}\n</code></pre>\n  </li>\n</ul>\n<h3>3. 可重入性</h3>\n<ul>\n  <li>两者都支持可重入性，即同一个线程可以多次获得同一把锁。</li>\n</ul>\n<h3>4. 上锁与解锁</h3>\n<ul>\n  <li><strong>synchronized</strong>:\n    <ul>\n      <li>自动释放锁。当方法执行结束或者发生异常时，Java 会自动释放锁。</li>\n    </ul>\n  </li>\n  <li><strong>ReentrantLock</strong>:\n    <ul>\n      <li>必须手动释放锁，通常是在 <code>finally</code> 块中释放锁。如果没有释放锁，会导致死锁问题。</li>\n    </ul>\n  </li>\n</ul>\n<h3>5. 试图获得锁</h3>\n<ul>\n  <li>\n    <p><strong>synchronized</strong> 不支持尝试获取锁。</p>\n  </li>\n  <li>\n    <p><strong>ReentrantLock</strong> 提供了 <code>tryLock()</code> 方法，可以尝试获取锁，如果锁被其他线程占用，可以选择不等待。</p>\n  </li>\n</ul>\n<h3>6. 中断处理</h3>\n<ul>\n  <li>\n    <p><strong>synchronized</strong> 不支持中断，线程在等待锁时无法响应中断。</p>\n  </li>\n  <li>\n    <p><strong>ReentrantLock</strong> 支持中断，可以在尝试获得锁时响应线程的中断。</p>\n  </li>\n</ul>\n<h3>7. Conditions</h3>\n<ul>\n  <li>\n    <p><strong>synchronized</strong> 使用 <code>Object.wait()</code> 和 <code>Object.notify()</code> 或 <code>notifyAll()</code> 进行线程间的协作。</p>\n  </li>\n  <li>\n    <p><strong>ReentrantLock</strong> 提供了 <code>Condition</code> 对象，允许更灵活的线程通知机制，能够实现复杂的线程协作。</p>\n  </li>\n</ul>\n<h3>8. 性能</h3>\n<ul>\n  <li>在高并发情况下，<code>ReentrantLock</code> 通常表现得比 <code>synchronized</code> 更好，但这也依赖于特定的场景。</li>\n</ul>\n<h3>总结</h3>\n<p><code>ReentrantLock</code> 提供了比 <code>synchronized</code> 更丰富和灵活的功能，但使用时也更复杂。选择哪个锁通常取决于具体需求，简单的同步需求可以使用 <code>synchronized</code>，对于需要更灵活控制的场景，则可以使用 <code>ReentrantLock</code>。</p>",
    "type": 6,
    "level": 3,
    "freq": 0.01313715,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：探讨 Java 中 synchronized 和 ReenTrantLock 的区别。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对 synchronized 和 ReenTrantLock 基本概念的理解。</li>\n      <li>二者在使用方式、锁特性、性能等方面的差异。</li>\n      <li>对 Java 并发编程锁机制的掌握。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）synchronized</h4>\n<ul>\n  <li>是 Java 的关键字，用于实现同步机制，它可以修饰方法或代码块。</li>\n  <li>是 Java 早期提供的内置锁，能保证在同一时刻只有一个线程可以访问被锁定的代码。</li>\n</ul>\n<h4>（2）ReenTrantLock</h4>\n<ul>\n  <li>是 Java.util.concurrent.locks 包下的一个类，实现了 Lock 接口。</li>\n  <li>提供了比 synchronized 更灵活、更强大的锁机制。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）使用方式</h4>\n<ul>\n  <li><strong>synchronized</strong>：\n    <ul>\n      <li>修饰实例方法时，锁的是当前对象实例。</li>\n      <li>修饰静态方法时，锁的是当前类的 Class 对象。</li>\n      <li>修饰代码块时，需要指定锁的对象。</li>\n    </ul>\n  </li>\n  <li><strong>ReenTrantLock</strong>：\n    <ul>\n      <li>需要手动调用 lock() 方法加锁，unlock() 方法释放锁，且通常在 finally 块中释放锁以确保锁一定会被释放。</li>\n    </ul>\n  </li>\n</ul>\n<h4>（2）锁的特性</h4>\n<ul>\n  <li><strong>可重入性</strong>：二者都具有可重入性，即同一个线程可以多次获取同一把锁而不会产生死锁。</li>\n  <li><strong>公平性</strong>：\n    <ul>\n      <li><strong>synchronized</strong>：是非公平锁，线程获取锁的顺序是不确定的，可能后请求的线程先获得锁。</li>\n      <li><strong>ReenTrantLock</strong>：可以通过构造函数指定是否为公平锁，公平锁会按照线程请求锁的顺序依次获得锁。</li>\n    </ul>\n  </li>\n  <li><strong>锁的中断</strong>：\n    <ul>\n      <li><strong>synchronized</strong>：一旦线程获取锁，就会一直持有，除非抛出异常或正常执行完代码块，不能被中断。</li>\n      <li><strong>ReenTrantLock</strong>：提供了 lockInterruptibly() 方法，允许线程在等待锁的过程中被中断。</li>\n    </ul>\n  </li>\n  <li><strong>条件变量</strong>：\n    <ul>\n      <li><strong>synchronized</strong>：使用 wait()、notify() 和 notifyAll() 方法实现线程间的协作，功能相对有限。</li>\n      <li><strong>ReenTrantLock</strong>：可以通过 newCondition() 方法创建多个条件变量，每个条件变量都有自己的等待队列，能更精细地控制线程间的协作。</li>\n    </ul>\n  </li>\n</ul>\n<h4>（3）性能</h4>\n<ul>\n  <li><strong>synchronized</strong>：早期性能较差，但在 Java 6 之后进行了大量优化，引入了偏向锁、轻量级锁等机制，在大多数场景下性能与 ReenTrantLock 相近。</li>\n  <li><strong>ReenTrantLock</strong>：在高并发、复杂锁操作场景下性能可能更优，因为它提供了更多的锁控制方式。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<h4>synchronized 示例</h4>\n<pre><code class=\"language-java\">class SynchronizedExample {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n}\n</code></pre>\n<h4>ReenTrantLock 示例</h4>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReentrantLock;\n\nclass ReentrantLockExample {\n    private int count = 0;\n    private final ReentrantLock lock = new ReentrantLock();\n\n    public void increment() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）认为 synchronized 性能一定差</h4>\n<ul>\n  <li>误区：觉得 synchronized 是早期的锁机制，性能不如 ReenTrantLock。</li>\n  <li>纠正：Java 6 之后 synchronized 进行了优化，在大多数场景下性能与 ReenTrantLock 相近。</li>\n</ul>\n<h4>（2）忽视 ReenTrantLock 手动释放锁的问题</h4>\n<ul>\n  <li>误区：使用 ReenTrantLock 时忘记在 finally 块中释放锁，可能导致死锁。</li>\n  <li>纠正：必须在 finally 块中调用 unlock() 方法确保锁被释放。</li>\n</ul>\n<h4>（3）混淆二者的锁特性</h4>\n<ul>\n  <li>误区：不清楚二者在公平性、可中断性、条件变量等方面的差异。</li>\n  <li>纠正：明确二者在这些特性上的不同，根据实际需求选择合适的锁。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“synchronized 和 ReenTrantLock 都是 Java 中用于实现线程同步的机制，但存在以下区别：</p>\n<ul>\n  <li><strong>使用方式</strong>：synchronized 是 Java 关键字，可修饰方法或代码块；ReenTrantLock 是类，需手动调用 lock() 加锁和 unlock() 释放锁，且 unlock() 通常在 finally 块中调用。</li>\n  <li><strong>锁的特性</strong>：二者都可重入，但在公平性上，synchronized 是非公平锁，ReenTrantLock 可指定是否为公平锁；synchronized 不可被中断，ReenTrantLock 可通过 lockInterruptibly() 方法被中断；synchronized 使用 wait()、notify() 和 notifyAll() 实现线程协作，ReenTrantLock 可通过 newCondition() 创建多个条件变量，更精细地控制线程协作。</li>\n  <li><strong>性能</strong>：Java 6 之后 synchronized 性能优化，多数场景下与 ReenTrantLock 相近，ReenTrantLock 在高并发、复杂锁操作场景可能更优。</li>\n</ul>\n<p>在选择时，若需求简单，使用 synchronized 更简洁；若需要灵活的锁控制，如公平锁、可中断锁、多条件变量等，应选择 ReenTrantLock。”</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>你如何选择使用 synchronized 还是 ReentrantLock？</strong></p>\n    <ul>\n      <li>提示：考虑性能、代码可读性和功能需求。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>ReentrantLock 的特点是什么？</strong></p>\n    <ul>\n      <li>提示：关注公平性和可重入特性，是否可以中断。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>能否描述一下 synchronized 的底层实现？</strong></p>\n    <ul>\n      <li>提示：了解监视器、对象头和锁的获取过程。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>什么是死锁？你如何防止死锁的发生？</strong></p>\n    <ul>\n      <li>提示：考虑锁的获取顺序、时间限制等策略。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>举例说明在多线程环境中使用 ReentrantLock 的一些高级特性，例如条件队列。</strong></p>\n    <ul>\n      <li>提示：关注 <code>Condition</code> 接口和其应用场景。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>synchronized 和 ReentrantLock 的性能差异在哪些情况下会显现出来？</strong></p>\n    <ul>\n      <li>提示：考虑高并发场景 vs 低并发场景的性能影响。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何确保在多线程环境中资源的可见性？</strong></p>\n    <ul>\n      <li>提示：强调 <code>volatile</code> 关键字和内存模型。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>描述一下 Java 中的读写锁（ReadWriteLock）是什么以及它与 ReentrantLock 的关系。</strong></p>\n    <ul>\n      <li>提示：讨论读写锁的优势和适用场景。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在高并发的情况下，synchronized 可能会导致什么问题？</strong></p>\n    <ul>\n      <li>提示：考虑锁竞争、线程上下文切换等。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如果用 synchronized 保护了一个方法或代码块，如何判断这个锁的粒度？</strong></p>\n    <ul>\n      <li>提示：讨论锁的粒度对性能和准确性的影响。</li>\n    </ul>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((synchronized 和 ReentrantLock 对比))\n    基本概念\n      synchronized\n      ReentrantLock\n    代码结构和易用性\n      synchronized\n      ReentrantLock\n    可重入性\n    上锁与解锁\n      synchronized\n      ReentrantLock\n    试图获得锁\n      synchronized\n      ReentrantLock\n    中断处理\n      synchronized\n      ReentrantLock\n    Conditions\n      synchronized\n      ReentrantLock\n    性能\n    总结",
    "keynote": "- `synchronized` 是 Java 的内置锁，使用简单；`ReentrantLock` 提供更多功能且更灵活。\n- `synchronized` 可以同步方法或代码块；`ReentrantLock` 需要显式获取和释放锁。\n- 两者都支持可重入性。\n- `synchronized` 自动管理锁的释放；`ReentrantLock` 需要手动释放锁。\n- `ReentrantLock` 支持尝试获取锁（`tryLock()`）而 `synchronized` 不支持。\n- `ReentrantLock` 支持中断响应，`synchronized` 不支持。\n- `synchronized` 使用 `Object.wait()` 和 `notify()` 进行线程协作；`ReentrantLock` 通过 `Condition` 实现更复杂的协作。\n- 在高并发情况下，`ReentrantLock` 通常性能更好。",
    "group_id": 5,
    "kps": [
      "多线程"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "德勤",
      "小红书",
      "京东",
      "Wind万得",
      "宇信科技",
      "顺丰",
      "蔚来",
      "去哪儿旅行",
      "CVTE视源股份",
      "唯品会",
      "途虎养车",
      "快手",
      "美团",
      "美团优选",
      "完美世界",
      "小米",
      "中科微至",
      "南京小西科技",
      "数字马力",
      "腾讯",
      "58同城",
      "字节飞书",
      "字节跳动",
      "阿里巴巴",
      "百度",
      "网易",
      "OPPO",
      "滴滴",
      "拼多多",
      "携程",
      "大华",
      "奇安信",
      "用友",
      "浩鲸科技",
      "同程旅行",
      "帆软",
      "货拉拉",
      "饿了么",
      "英方软件",
      "字节今日头条",
      "达不溜",
      "来未来科技（浙江）熙牛医疗"
    ]
  }
}