{"success":true,"data":{"id":16822,"name":"<p>Java中有哪些加锁方式</p>","options":null,"answer":"<p>在 Java 中，有多种加锁方式，主要可以分为 JVM 层面的锁和 JDK 层面的锁，下面为你详细介绍：</p>\n<h3>JVM 层面的锁</h3>\n<h4>1. synchronized 关键字</h4>\n<p><code>synchronized</code> 是 Java 中最基本的同步机制，它可以保证在同一时刻，只有一个线程能够访问被 <code>synchronized</code> 修饰的代码块或方法。</p>\n<p><strong>使用场景</strong>：</p>\n<ul>\n  <li><strong>修饰实例方法</strong>：对当前实例对象加锁，同一实例的该方法同一时间只能被一个线程访问。</li>\n</ul>\n<pre><code class=\"language-java\">public class SynchronizedExample {\n    public synchronized void method() {\n        // 同步代码块\n        System.out.println(\"Method is locked by \" + Thread.currentThread().getName());\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>修饰静态方法</strong>：对当前类的 Class 对象加锁，同一类的所有实例的该静态方法同一时间只能被一个线程访问。</li>\n</ul>\n<pre><code class=\"language-java\">public class SynchronizedExample {\n    public static synchronized void staticMethod() {\n        // 同步代码块\n        System.out.println(\"Static method is locked by \" + Thread.currentThread().getName());\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>修饰代码块</strong>：可以指定加锁的对象，对指定对象加锁。</li>\n</ul>\n<pre><code class=\"language-java\">public class SynchronizedExample {\n    private final Object lock = new Object();\n    public void blockMethod() {\n        synchronized (lock) {\n            // 同步代码块\n            System.out.println(\"Block is locked by \" + Thread.currentThread().getName());\n        }\n    }\n}\n</code></pre>\n<h3>JDK 层面的锁</h3>\n<h4>2. ReentrantLock</h4>\n<p><code>ReentrantLock</code> 是 <code>java.util.concurrent.locks</code> 包下的一个类，它提供了与 <code>synchronized</code> 类似的同步功能，但更加灵活。</p>\n<p><strong>使用场景</strong>：</p>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReentrantLock;\n\npublic class ReentrantLockExample {\n    private final ReentrantLock lock = new ReentrantLock();\n    public void method() {\n        lock.lock();\n        try {\n            // 同步代码块\n            System.out.println(\"Method is locked by \" + Thread.currentThread().getName());\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n</code></pre>\n<p><strong>特点</strong>：</p>\n<ul>\n  <li>可重入：同一个线程可以多次获取同一把锁。</li>\n  <li>可中断：在等待锁的过程中，线程可以被中断。</li>\n  <li>可定时：可以指定等待锁的时间。</li>\n</ul>\n<h4>3. ReadWriteLock</h4>\n<p><code>ReadWriteLock</code> 是一个接口，它允许在同一时间允许多个线程进行读操作，但在写操作时，同一时间只允许一个线程进行。<code>ReentrantReadWriteLock</code> 是其实现类。</p>\n<p><strong>使用场景</strong>：</p>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class ReadWriteLockExample {\n    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n    public void readMethod() {\n        rwLock.readLock().lock();\n        try {\n            // 读操作\n            System.out.println(\"Read operation by \" + Thread.currentThread().getName());\n        } finally {\n            rwLock.readLock().unlock();\n        }\n    }\n    public void writeMethod() {\n        rwLock.writeLock().lock();\n        try {\n            // 写操作\n            System.out.println(\"Write operation by \" + Thread.currentThread().getName());\n        } finally {\n            rwLock.writeLock().unlock();\n        }\n    }\n}\n</code></pre>\n<p><strong>特点</strong>：</p>\n<ul>\n  <li>读锁可以被多个线程同时持有，提高了读操作的并发性能。</li>\n  <li>写锁是排他锁，同一时间只能被一个线程持有。</li>\n</ul>\n<h4>4. StampedLock</h4>\n<p><code>StampedLock</code> 是 Java 8 引入的一种新的锁机制，它支持三种模式：写锁、读锁和乐观读锁。</p>\n<p><strong>使用场景</strong>：</p>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.StampedLock;\n\npublic class StampedLockExample {\n    private final StampedLock stampedLock = new StampedLock();\n    private int value = 0;\n    public int readValue() {\n        long stamp = stampedLock.tryOptimisticRead();\n        int currentValue = value;\n        if (!stampedLock.validate(stamp)) {\n            stamp = stampedLock.readLock();\n            try {\n                currentValue = value;\n            } finally {\n                stampedLock.unlockRead(stamp);\n            }\n        }\n        return currentValue;\n    }\n    public void writeValue(int newValue) {\n        long stamp = stampedLock.writeLock();\n        try {\n            value = newValue;\n        } finally {\n            stampedLock.unlockWrite(stamp);\n        }\n    }\n}\n</code></pre>\n<p><strong>特点</strong>：</p>\n<ul>\n  <li>乐观读锁：在进行读操作时，不需要加锁，通过版本号来判断数据是否被修改。</li>\n  <li>性能更高：在大多数读多写少的场景下，性能优于 <code>ReentrantReadWriteLock</code>。</li>\n</ul>","type":6,"level":2,"freq":0.008933263,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Java中有哪些加锁方式。</li>\n  <li><strong>考察点</strong>：对Java中不同锁机制的了解，包括锁的使用场景、特点和实现原理。</li>\n</ul>\n<h3>2. 背景知识</h3>\n<ul>\n  <li><strong>锁的作用</strong>：在多线程编程中，为了保证数据的一致性和线程安全，需要对共享资源进行同步访问，锁就是实现同步的重要手段。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）synchronized关键字</h4>\n<ul>\n  <li><strong>使用方式</strong>：\n    <ul>\n      <li><strong>修饰实例方法</strong>：对当前实例对象加锁，同一时刻只能有一个线程访问该实例的同步方法。</li>\n      <li><strong>修饰静态方法</strong>：对当前类的Class对象加锁，同一时刻只能有一个线程访问该类的静态同步方法。</li>\n      <li><strong>修饰代码块</strong>：可以指定加锁的对象，对指定对象加锁，同一时刻只能有一个线程访问该代码块。</li>\n    </ul>\n  </li>\n  <li><strong>特点</strong>：是Java的内置锁，由JVM实现，使用简单，能自动释放锁。</li>\n  <li><strong>原理</strong>：基于对象头的Mark Word实现，通过监视器（Monitor）来实现同步。</li>\n</ul>\n<h4>（2）ReentrantLock</h4>\n<ul>\n  <li><strong>使用方式</strong>：需要手动创建<code>ReentrantLock</code>对象，通过<code>lock()</code>方法加锁，<code>unlock()</code>方法解锁。</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReentrantLock;\n\npublic class ReentrantLockExample {\n    private final ReentrantLock lock = new ReentrantLock();\n\n    public void doSomething() {\n        lock.lock();\n        try {\n            // 临界区代码\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>特点</strong>：可重入锁，支持公平锁和非公平锁，提供了更多的高级功能，如可中断锁、超时锁等。</li>\n  <li><strong>原理</strong>：基于AQS（AbstractQueuedSynchronizer）实现。</li>\n</ul>\n<h4>（3）ReentrantReadWriteLock</h4>\n<ul>\n  <li><strong>使用方式</strong>：包含读锁和写锁，读锁可以被多个线程同时持有，写锁是排他锁，同一时刻只能有一个线程持有。</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class ReentrantReadWriteLockExample {\n    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n    private final ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();\n    private final ReentrantReadWriteLock.WriteLock writeLock = rwLock.writeLock();\n\n    public void read() {\n        readLock.lock();\n        try {\n            // 读操作\n        } finally {\n            readLock.unlock();\n        }\n    }\n\n    public void write() {\n        writeLock.lock();\n        try {\n            // 写操作\n        } finally {\n            writeLock.unlock();\n        }\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>特点</strong>：适用于读多写少的场景，提高了并发性能。</li>\n  <li><strong>原理</strong>：同样基于AQS实现。</li>\n</ul>\n<h4>（4）StampedLock</h4>\n<ul>\n  <li><strong>使用方式</strong>：支持乐观读、悲观读和写锁。乐观读在读取数据时不加锁，读取完成后检查数据是否被修改，如果被修改则升级为悲观读或写锁。</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.StampedLock;\n\npublic class StampedLockExample {\n    private final StampedLock stampedLock = new StampedLock();\n    private int data = 0;\n\n    public int read() {\n        long stamp = stampedLock.tryOptimisticRead();\n        int currentData = data;\n        if (!stampedLock.validate(stamp)) {\n            stamp = stampedLock.readLock();\n            try {\n                currentData = data;\n            } finally {\n                stampedLock.unlockRead(stamp);\n            }\n        }\n        return currentData;\n    }\n\n    public void write(int newData) {\n        long stamp = stampedLock.writeLock();\n        try {\n            data = newData;\n        } finally {\n            stampedLock.unlockWrite(stamp);\n        }\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>特点</strong>：性能更高，适用于读多写少且对性能要求较高的场景。</li>\n  <li><strong>原理</strong>：通过戳（stamp）来控制锁的状态。</li>\n</ul>\n<h3>4. 常见误区</h3>\n<h4>（1）过度使用synchronized</h4>\n<ul>\n  <li>误区：在所有场景都使用<code>synchronized</code>，不考虑性能和功能需求。</li>\n  <li>纠正：根据具体场景选择合适的锁，如读多写少场景可考虑<code>ReentrantReadWriteLock</code>或<code>StampedLock</code>。</li>\n</ul>\n<h4>（2）忘记释放锁</h4>\n<ul>\n  <li>误区：使用<code>ReentrantLock</code>等手动加锁的锁时，忘记调用<code>unlock()</code>方法释放锁。</li>\n  <li>纠正：在<code>finally</code>块中释放锁，确保锁一定会被释放。</li>\n</ul>\n<h4>（3）混淆不同锁的使用场景</h4>\n<ul>\n  <li>误区：不清楚不同锁的特点和适用场景，随意使用。</li>\n  <li>纠正：了解各种锁的特点，根据实际需求选择合适的锁。</li>\n</ul>\n<h3>5. 总结回答</h3>\n<p>Java中有多种加锁方式，主要包括：</p>\n<ul>\n  <li><strong>synchronized关键字</strong>：是Java的内置锁，可修饰实例方法、静态方法和代码块。使用简单，由JVM自动管理锁的获取和释放，基于对象头的Mark Word和监视器实现同步。</li>\n  <li><strong>ReentrantLock</strong>：可重入锁，需要手动创建和管理锁的获取与释放。支持公平锁和非公平锁，提供了可中断锁、超时锁等高级功能，基于AQS实现。</li>\n  <li><strong>ReentrantReadWriteLock</strong>：包含读锁和写锁，读锁可被多个线程同时持有，写锁是排他锁。适用于读多写少的场景，基于AQS实现。</li>\n  <li><strong>StampedLock</strong>：支持乐观读、悲观读和写锁，性能较高。乐观读在读取数据时不加锁，读取完成后检查数据是否被修改，适用于读多写少且对性能要求较高的场景，通过戳来控制锁的状态。</li>\n</ul>\n<p>在选择加锁方式时，需要根据具体的场景和性能需求进行选择，同时要注意避免常见的使用误区。</p>","more_ask":"<ol>\n  <li>\n    <p>\n      <strong>不同加锁方式的性能对比如何，在什么场景下使用哪种加锁方式更合适？</strong>\n      提示：从锁的特性如可重入性、公平性、锁粒度等方面考虑不同场景。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>使用<code>synchronized</code>关键字加锁时，锁的对象不同会有什么影响？</strong>\n      提示：思考锁对象是类对象、实例对象时对同步范围的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong><code>ReentrantLock</code>的<code>tryLock()</code>方法和<code>lock()</code>方法有什么区别，在实际应用中如何选择？</strong>\n      提示：关注方法的阻塞特性和返回值在不同业务场景的应用。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在多线程环境下，使用读写锁<code>ReentrantReadWriteLock</code>时，读锁和写锁的获取与释放顺序有什么要求？</strong>\n      提示：考虑读写锁的互斥规则和并发特性。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong><code>StampedLock</code>与<code>ReentrantReadWriteLock</code>相比，有哪些优势和劣势？</strong>\n      提示：从锁的性能、使用复杂度、锁的特性等方面对比。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如果在加锁代码块中发生异常，不同加锁方式是如何处理的？</strong>\n      提示：思考异常对锁释放的影响以及不同锁的处理机制。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如何使用<code>LockSupport</code>实现简单的锁机制？</strong>\n      提示：了解<code>LockSupport</code>的<code>park()</code>和<code>unpark()</code>方法的作用。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在分布式系统中，上述的加锁方式还适用吗，为什么？</strong>\n      提示：考虑分布式系统的特点如多节点、网络延迟等对锁的影响。\n    </p>\n  </li>\n</ol>","mindmap":"mindmap\n  root((Java加锁方式))\n    JVM层面的锁\n      synchronized关键字\n        基本同步机制\n        使用场景\n          修饰实例方法\n          修饰静态方法\n          修饰代码块\n    JDK层面的锁\n      ReentrantLock\n        类似synchronized但更灵活\n        使用场景\n        特点\n          可重入\n          可中断\n          可定时\n      ReadWriteLock\n        接口，允许多线程读单线程写\n        使用场景\n        特点\n          读锁可多线程持有\n          写锁排他\n      StampedLock\n        Java 8新锁机制\n        使用场景\n        特点\n          乐观读锁\n          读多写少场景性能高","keynote":"Java加锁方式：JVM层面和JDK层面\nJVM层面：synchronized关键字\n  - 基本同步机制，同一时刻仅一线程访问修饰代码块或方法\n  - 使用场景：修饰实例方法、静态方法、代码块\nJDK层面：\n  - ReentrantLock：类似synchronized，更灵活\n    - 特点：可重入、可中断、可定时\n  - ReadWriteLock：接口，允许多线程读单线程写\n    - 特点：读锁可多线程持有，写锁排他\n  - StampedLock：Java 8新锁机制\n    - 特点：乐观读锁，读多写少场景性能高","group_id":5,"kps":["高级特性","面向对象编程"],"years":[2024,2023,2022],"corps":["合思","携程","阿里云","快手","阿里巴巴","数字马力","腾讯音乐","美团","蔚来","好未来","百度","OPPO","字节飞书","字节跳动","科大讯飞","小米","滴滴","拼多多","贝壳","广联达","用友","浩鲸科技（济南）","浩鲸科技","顺丰","腾讯"]}}