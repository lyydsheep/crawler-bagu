{
  "success": true,
  "data": {
    "id": 14169,
    "name": "<p>简述线程的状态</p>",
    "options": null,
    "answer": "<p>在 Java 中，线程有多种状态，这些状态定义在 <code>java.lang.Thread.State</code> 枚举类中。下面详细介绍 Java 线程的各种状态及其转换条件。</p>\n<h3>线程的六种状态</h3>\n<ol>\n  <li><strong>NEW（新建状态）</strong>\n    <ul>\n      <li><strong>描述</strong>：当创建一个 <code>Thread</code> 对象，但还没有调用 <code>start()</code> 方法时，线程处于新建状态。此时，线程仅仅是一个对象实例，还没有真正开始执行。</li>\n      <li><strong>示例代码</strong>：</li>\n    </ul>\n  </li>\n</ol>\n<pre><code class=\"language-java\">Thread thread = new Thread(() -> System.out.println(\"Hello, World!\"));\n// 此时线程处于 NEW 状态\n</code></pre>\n<ol start=\"2\">\n  <li><strong>RUNNABLE（可运行状态）</strong>\n    <ul>\n      <li><strong>描述</strong>：调用 <code>start()</code> 方法后，线程进入可运行状态。该状态包含两种情况：一是线程正在 Java 虚拟机中执行；二是线程已经准备好，等待操作系统的调度器分配 CPU 时间片来执行。</li>\n      <li><strong>示例代码</strong>：</li>\n    </ul>\n  </li>\n</ol>\n<pre><code class=\"language-java\">Thread thread = new Thread(() -> System.out.println(\"Hello, World!\"));\nthread.start();\n// 调用 start() 后，线程进入 RUNNABLE 状态\n</code></pre>\n<ol start=\"3\">\n  <li><strong>BLOCKED（阻塞状态）</strong>\n    <ul>\n      <li><strong>描述</strong>：当线程试图获取一个已经被其他线程持有的对象锁时，线程会进入阻塞状态。在获取到锁之前，线程会一直处于阻塞状态，直到持有锁的线程释放锁。</li>\n      <li><strong>示例代码</strong>：</li>\n    </ul>\n  </li>\n</ol>\n<pre><code class=\"language-java\">public class BlockedExample {\n    private static final Object lock = new Object();\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(() -> {\n            synchronized (lock) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        Thread t2 = new Thread(() -> {\n            synchronized (lock) {\n                System.out.println(\"Acquired lock\");\n            }\n        });\n\n        t1.start();\n        t2.start();\n        // t2 可能会进入 BLOCKED 状态，等待 t1 释放锁\n    }\n}\n</code></pre>\n<ol start=\"4\">\n  <li><strong>WAITING（等待状态）</strong>\n    <ul>\n      <li><strong>描述</strong>：当线程调用 <code>Object.wait()</code>、<code>Thread.join()</code> 或 <code>LockSupport.park()</code> 方法时，线程会进入等待状态。处于等待状态的线程会一直等待，直到其他线程调用 <code>Object.notify()</code>、<code>Object.notifyAll()</code> 或 <code>LockSupport.unpark()</code> 方法来唤醒它。</li>\n      <li><strong>示例代码</strong>：</li>\n    </ul>\n  </li>\n</ol>\n<pre><code class=\"language-java\">public class WaitingExample {\n    public static void main(String[] args) {\n        Object lock = new Object();\n\n        Thread t1 = new Thread(() -> {\n            synchronized (lock) {\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"Thread is awakened\");\n            }\n        });\n\n        Thread t2 = new Thread(() -> {\n            synchronized (lock) {\n                lock.notify();\n            }\n        });\n\n        t1.start();\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        t2.start();\n        // t1 会进入 WAITING 状态，等待 t2 唤醒\n    }\n}\n</code></pre>\n<ol start=\"5\">\n  <li><strong>TIMED_WAITING（定时等待状态）</strong>\n    <ul>\n      <li><strong>描述</strong>：与等待状态类似，但定时等待状态的线程会在指定的时间后自动唤醒。常见的方法有 <code>Thread.sleep(long millis)</code>、<code>Object.wait(long timeout)</code>、<code>Thread.join(long millis)</code> 和 <code>LockSupport.parkNanos(long nanos)</code> 等。</li>\n      <li><strong>示例代码</strong>：</li>\n    </ul>\n  </li>\n</ol>\n<pre><code class=\"language-java\">public class TimedWaitingExample {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"Thread woke up after 2 seconds\");\n        });\n\n        t.start();\n        // t 会进入 TIMED_WAITING 状态，等待 2 秒后自动唤醒\n    }\n}\n</code></pre>\n<ol start=\"6\">\n  <li><strong>TERMINATED（终止状态）</strong>\n    <ul>\n      <li><strong>描述</strong>：当线程的 <code>run()</code> 方法执行完毕，或者线程因为异常而终止时，线程进入终止状态。一旦线程进入终止状态，就不能再重新启动。</li>\n      <li><strong>示例代码</strong>：</li>\n    </ul>\n  </li>\n</ol>\n<pre><code class=\"language-java\">Thread thread = new Thread(() -> System.out.println(\"Hello, World!\"));\nthread.start();\n// 线程执行完毕后，进入 TERMINATED 状态\n</code></pre>\n<h3>线程状态转换图</h3>\n<pre><code class=\"language-plaintext\">          +---------+      start()      +----------+\n          |  NEW    | ---------------> | RUNNABLE |\n          +---------+                   +----------+\n                                           |\n           +------------------------------+\n           |                              |\n           | wait(), join(), park()       | sleep(), wait(time), join(time), parkNanos()\n           v                              v\n    +----------+                    +--------------+\n    | WAITING  |                    | TIMED_WAITING|\n    +----------+                    +--------------+\n           ^                              |\n           | notify(), notifyAll(), unpark() | time elapsed\n           +------------------------------+\n                                           |\n                                           | acquire lock failed\n                                           v\n                                    +----------+\n                                    | BLOCKED  |\n                                    +----------+\n                                           |\n                                           | acquire lock\n                                           v\n                                   +-----------+\n                                   | TERMINATED|\n                                   +-----------+\n</code></pre>\n<p>以上就是 Java 线程的六种状态及其转换条件。理解线程的状态对于编写多线程程序非常重要，可以帮助我们更好地控制线程的执行流程和解决线程同步问题。</p>",
    "type": 6,
    "level": 1,
    "freq": 0.01191102,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：简述Java中线程的状态。</li>\n  <li><strong>考察点</strong>：对Java线程状态的了解，包括各状态的含义、状态之间的转换条件。</li>\n</ul>\n<h3>2. 背景知识</h3>\n<p>在Java中，线程是程序执行的最小单元，线程的状态反映了线程在其生命周期内所处的不同阶段。Java线程状态的管理有助于开发者更好地控制线程的执行流程和资源分配。</p>\n<h3>3. 解析</h3>\n<h4>（1）新建（New）</h4>\n<ul>\n  <li>当创建一个新的<code>Thread</code>对象时，线程就处于新建状态。此时线程仅仅是在内存中被创建出来，但还没有开始执行。例如：</li>\n</ul>\n<pre><code class=\"language-java\">Thread thread = new Thread();\n</code></pre>\n<h4>（2）就绪（Runnable）</h4>\n<ul>\n  <li>当调用线程的<code>start()</code>方法后，线程进入就绪状态。处于就绪状态的线程已经准备好执行，等待获取CPU时间片。一旦获得CPU资源，线程就会开始执行其<code>run()</code>方法。</li>\n</ul>\n<pre><code class=\"language-java\">thread.start();\n</code></pre>\n<h4>（3）运行（Running）</h4>\n<ul>\n  <li>当就绪状态的线程获得CPU时间片后，就进入运行状态，开始执行<code>run()</code>方法中的代码。在单核CPU系统中，同一时刻只有一个线程处于运行状态；在多核CPU系统中，可能有多个线程同时处于运行状态。</li>\n</ul>\n<h4>（4）阻塞（Blocked）</h4>\n<ul>\n  <li>线程在某些情况下会进入阻塞状态，暂时停止执行。阻塞状态分为以下几种情况：\n    <ul>\n      <li><strong>等待阻塞</strong>：当线程调用<code>Object.wait()</code>方法时，线程会释放对象锁并进入等待队列，处于等待阻塞状态。直到其他线程调用相同对象的<code>notify()</code>或<code>notifyAll()</code>方法，该线程才会被唤醒，重新进入就绪状态。</li>\n      <li><strong>同步阻塞</strong>：当线程试图获取一个已经被其他线程持有的对象锁时，线程会进入同步阻塞状态，直到该锁被释放，线程才能获取锁并进入就绪状态。</li>\n      <li><strong>其他阻塞</strong>：当线程执行<code>Thread.sleep()</code>、<code>Thread.join()</code>或进行I/O操作时，线程会进入阻塞状态，直到相应的操作完成，线程才会重新进入就绪状态。</li>\n    </ul>\n  </li>\n</ul>\n<h4>（5）等待（Waiting）</h4>\n<ul>\n  <li>线程调用<code>Object.wait()</code>、<code>Thread.join()</code>或<code>LockSupport.park()</code>方法后，会进入等待状态。处于等待状态的线程需要其他线程进行显式唤醒，否则会一直等待下去。</li>\n</ul>\n<h4>（6）超时等待（Timed Waiting）</h4>\n<ul>\n  <li>线程调用<code>Thread.sleep(long millis)</code>、<code>Object.wait(long timeout)</code>、<code>Thread.join(long millis)</code>或<code>LockSupport.parkNanos()</code>、<code>LockSupport.parkUntil()</code>等带有超时参数的方法时，会进入超时等待状态。在指定的时间内，线程会处于等待状态；如果超时时间到达，线程会自动唤醒，重新进入就绪状态。</li>\n</ul>\n<h4>（7）终止（Terminated）</h4>\n<ul>\n  <li>线程的<code>run()</code>方法执行完毕或者因为异常退出<code>run()</code>方法时，线程进入终止状态。处于终止状态的线程已经结束其生命周期，不能再重新启动。</li>\n</ul>\n<h3>4. 状态转换图</h3>\n<pre><code class=\"language-plaintext\">          start()\nNew -------------> Runnable\n                  |\n                  | 获得CPU时间片\n                  v\n              Running\n                  |\n                  | sleep()、wait()、join()等\n                  v\n            Blocked/Waiting/Timed Waiting\n                  |\n                  | 满足唤醒条件\n                  v\n              Runnable\n                  |\n                  | run()方法执行完毕或异常退出\n                  v\n            Terminated\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆就绪和运行状态</h4>\n<ul>\n  <li>误区：认为调用<code>start()</code>方法后线程就立即开始执行。</li>\n  <li>纠正：调用<code>start()</code>方法后线程进入就绪状态，需要等待获取CPU时间片才能进入运行状态。</li>\n</ul>\n<h4>（2）不清楚阻塞和等待状态的区别</h4>\n<ul>\n  <li>误区：将阻塞和等待状态视为相同的状态。</li>\n  <li>纠正：阻塞状态通常是由于外部资源（如锁、I/O操作）的限制而暂停执行；等待状态是线程主动调用特定方法进入的，需要其他线程显式唤醒。</li>\n</ul>\n<h4>（3）试图重新启动已终止的线程</h4>\n<ul>\n  <li>误区：认为可以再次调用已终止线程的<code>start()</code>方法来重新启动线程。</li>\n  <li>纠正：已终止的线程不能再重新启动，否则会抛出<code>IllegalThreadStateException</code>异常。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>Java中线程有以下几种状态：</p>\n<ul>\n  <li><strong>新建（New）</strong>：创建<code>Thread</code>对象后线程处于此状态，尚未开始执行。</li>\n  <li><strong>就绪（Runnable）</strong>：调用<code>start()</code>方法后，线程准备好执行，等待CPU时间片。</li>\n  <li><strong>运行（Running）</strong>：就绪线程获得CPU时间片后开始执行<code>run()</code>方法。</li>\n  <li><strong>阻塞（Blocked）</strong>：因等待锁、I/O操作等进入此状态，暂停执行。</li>\n  <li><strong>等待（Waiting）</strong>：调用<code>Object.wait()</code>等方法后进入，需其他线程显式唤醒。</li>\n  <li><strong>超时等待（Timed Waiting）</strong>：调用带超时参数的方法进入，超时后自动唤醒。</li>\n  <li><strong>终止（Terminated）</strong>：<code>run()</code>方法执行完毕或异常退出后线程结束。</li>\n</ul>\n<p>线程状态之间会根据不同的操作和条件进行转换，开发者需要正确理解和运用这些状态来控制线程的执行流程。同时，要注意避免常见误区，如混淆状态、试图重启已终止线程等。</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      线程状态之间是如何转换的，能结合代码示例说明吗？\n      提示：思考线程状态转换的触发条件，如调用<code>start()</code>、<code>sleep()</code>、<code>wait()</code>等方法，通过编写简单的多线程代码展示状态转换。\n    </p>\n  </li>\n  <li>\n    <p>\n      <code>TIMED_WAITING</code>和<code>WAITING</code>状态有什么本质区别，在实际应用中如何选择使用？\n      提示：分析两种状态进入和退出的条件，结合生产者 - 消费者等实际场景考虑何时使用哪种状态。\n    </p>\n  </li>\n  <li>\n    <p>\n      当线程处于<code>BLOCKED</code>状态时，会消耗 CPU 资源吗？为什么？\n      提示：从线程调度和 CPU 资源分配的角度思考，结合操作系统的进程调度机制。\n    </p>\n  </li>\n  <li>\n    <p>\n      如何在代码中准确获取线程当前的状态？有哪些方法可以实现？\n      提示：考虑 Java 中提供的获取线程状态的 API，如<code>Thread.getState()</code>方法，思考如何在多线程环境中正确使用。\n    </p>\n  </li>\n  <li>\n    <p>\n      线程状态与线程优先级有什么关系，线程优先级会影响状态转换吗？\n      提示：了解线程优先级的概念和设置方法，分析优先级对线程调度和状态转换的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      在 Java 8 及以后的版本中，线程状态的管理有什么新特性或优化？\n      提示：查阅 Java 8 及以后版本的官方文档，关注与线程状态管理相关的新类、方法或改进。\n    </p>\n  </li>\n  <li>\n    <p>\n      当线程从<code>RUNNABLE</code>状态进入<code>TERMINATED</code>状态后，还能再次启动吗？为什么？\n      提示：从线程的生命周期和资源管理的角度思考，分析再次启动已终止线程可能带来的问题。\n    </p>\n  </li>\n  <li>\n    <p>\n      线程状态在不同的 JVM 实现中会有差异吗？如果有，可能体现在哪些方面？\n      提示：了解不同 JVM （如 HotSpot、OpenJ9 等）的特点和实现细节，思考线程状态管理可能存在的差异。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Java线程状态及转换))\n    线程状态定义\n      java.lang.Thread.State枚举类\n    线程的六种状态\n      NEW（新建状态）\n        创建Thread对象未调用start()\n        未真正开始执行\n      RUNNABLE（可运行状态）\n        调用start()后进入\n        正在执行或等待CPU时间片\n      BLOCKED（阻塞状态）\n        试图获取被其他线程持有的对象锁\n        等待锁释放\n      WAITING（等待状态）\n        调用Object.wait()、Thread.join()、LockSupport.park()\n        等待其他线程唤醒\n      TIMED_WAITING（定时等待状态）\n        指定时间后自动唤醒\n        常见方法如Thread.sleep()等\n      TERMINATED（终止状态）\n        run()方法执行完毕或因异常终止\n        不能重新启动\n    线程状态转换图\n      NEW -> RUNNABLE（start()）\n      RUNNABLE -> WAITING（wait(), join(), park()）\n      RUNNABLE -> TIMED_WAITING（sleep(), wait(time), join(time), parkNanos()）\n      WAITING -> RUNNABLE（notify(), notifyAll(), unpark()）\n      TIMED_WAITING -> RUNNABLE（time elapsed）\n      RUNNABLE -> BLOCKED（acquire lock failed）\n      BLOCKED -> RUNNABLE（acquire lock）\n      RUNNABLE -> TERMINATED",
    "keynote": "Java线程状态定义在java.lang.Thread.State枚举类\n六种状态：\n- NEW：创建Thread对象未调start()，未执行\n- RUNNABLE：调start()后，执行或等CPU\n- BLOCKED：获取被占对象锁，等锁释放\n- WAITING：调wait()等方法，等唤醒\n- TIMED_WAITING：指定时间后自动唤醒\n- TERMINATED：run()完或异常终止，不可重启\n状态转换：\n- NEW -> RUNNABLE：start()\n- RUNNABLE -> WAITING：wait()等\n- RUNNABLE -> TIMED_WAITING：sleep()等\n- WAITING -> RUNNABLE：notify()等\n- TIMED_WAITING -> RUNNABLE：时间到\n- RUNNABLE -> BLOCKED：获锁失败\n- BLOCKED -> RUNNABLE：获锁\n- RUNNABLE -> TERMINATED",
    "group_id": 5,
    "kps": [
      "多线程"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "游族网络",
      "杭州智晟未来信息科技",
      "竹云科技",
      "去哪儿旅行",
      "阿里云",
      "华为",
      "Wind万得",
      "来未来",
      "招银网络科技",
      "南昌某公司",
      "美团",
      "保融科技",
      "TP-LINK",
      "淘天集团",
      "快手",
      "中国移动",
      "传音控股",
      "京东",
      "酷家乐",
      "苏州杉互健康",
      "小米",
      "字节跳动",
      "阿里橙狮体育",
      "百度",
      "OPPO",
      "途虎养车",
      "满帮集团",
      "Shopee虾皮",
      "滴滴",
      "vivo",
      "用友",
      "同程旅行",
      "爱数科技",
      "网易有道",
      "深信服",
      "袋鼠云"
    ]
  }
}