{"success":true,"data":{"id":14378,"name":"<p>线程池的拒绝策略有哪些</p>","options":null,"answer":"<p>在 Java 中，线程池的拒绝策略是当线程池的任务队列已满且线程池中的线程数量达到最大线程数时，对新提交的任务采取的处理方式。<code>java.util.concurrent</code> 包中的 <code>ThreadPoolExecutor</code> 类提供了四种内置的拒绝策略，同时也支持自定义拒绝策略。以下是详细介绍：</p>\n<h3>1. <code>AbortPolicy</code>（默认策略）</h3>\n<ul>\n  <li><strong>描述</strong>：当线程池无法处理新提交的任务时，直接抛出 <code>RejectedExecutionException</code> 异常。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.*;\n\npublic class AbortPolicyExample {\n    public static void main(String[] args) {\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n                1, 1, 0L, TimeUnit.MILLISECONDS,\n                new ArrayBlockingQueue&#x3C;>(1),\n                new ThreadPoolExecutor.AbortPolicy());\n\n        try {\n            executor.execute(() -> {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n            executor.execute(() -> System.out.println(\"Task 2\"));\n            executor.execute(() -> System.out.println(\"Task 3\"));\n        } catch (RejectedExecutionException e) {\n            System.out.println(\"Rejected: \" + e.getMessage());\n        } finally {\n            executor.shutdown();\n        }\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>输出结果</strong>：</li>\n</ul>\n<pre><code>Rejected: Task java.util.concurrent.ThreadPoolExecutor$Worker@xxxxxx rejected from java.util.concurrent.ThreadPoolExecutor@xxxxxx[Running, pool size = 1, active threads = 1, queued tasks = 1, completed tasks = 0]\n</code></pre>\n<h3>2. <code>CallerRunsPolicy</code></h3>\n<ul>\n  <li><strong>描述</strong>：当线程池无法处理新提交的任务时，由提交任务的线程（调用 <code>execute</code> 方法的线程）来执行该任务。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.*;\n\npublic class CallerRunsPolicyExample {\n    public static void main(String[] args) {\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n                1, 1, 0L, TimeUnit.MILLISECONDS,\n                new ArrayBlockingQueue&#x3C;>(1),\n                new ThreadPoolExecutor.CallerRunsPolicy());\n\n        executor.execute(() -> {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        executor.execute(() -> System.out.println(\"Task 2 executed by \" + Thread.currentThread().getName()));\n        executor.execute(() -> System.out.println(\"Task 3 executed by \" + Thread.currentThread().getName()));\n\n        executor.shutdown();\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>输出结果</strong>：</li>\n</ul>\n<pre><code>Task 2 executed by pool-1-thread-1\nTask 3 executed by main\n</code></pre>\n<h3>3. <code>DiscardPolicy</code></h3>\n<ul>\n  <li><strong>描述</strong>：当线程池无法处理新提交的任务时，直接丢弃该任务，不会抛出任何异常。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.*;\n\npublic class DiscardPolicyExample {\n    public static void main(String[] args) {\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n                1, 1, 0L, TimeUnit.MILLISECONDS,\n                new ArrayBlockingQueue&#x3C;>(1),\n                new ThreadPoolExecutor.DiscardPolicy());\n\n        executor.execute(() -> {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        executor.execute(() -> System.out.println(\"Task 2\"));\n        executor.execute(() -> System.out.println(\"Task 3\"));\n\n        executor.shutdown();\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>输出结果</strong>：</li>\n</ul>\n<pre><code>Task 2\n</code></pre>\n<h3>4. <code>DiscardOldestPolicy</code></h3>\n<ul>\n  <li><strong>描述</strong>：当线程池无法处理新提交的任务时，丢弃任务队列中最老的任务，然后尝试重新提交新任务。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.*;\n\npublic class DiscardOldestPolicyExample {\n    public static void main(String[] args) {\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n                1, 1, 0L, TimeUnit.MILLISECONDS,\n                new ArrayBlockingQueue&#x3C;>(1),\n                new ThreadPoolExecutor.DiscardOldestPolicy());\n\n        executor.execute(() -> {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        executor.execute(() -> System.out.println(\"Task 2\"));\n        executor.execute(() -> System.out.println(\"Task 3\"));\n\n        executor.shutdown();\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>输出结果</strong>：</li>\n</ul>\n<pre><code>Task 3\n</code></pre>\n<h3>5. 自定义拒绝策略</h3>\n<ul>\n  <li><strong>描述</strong>：可以通过实现 <code>RejectedExecutionHandler</code> 接口来创建自定义的拒绝策略。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.*;\n\nclass CustomRejectedExecutionHandler implements RejectedExecutionHandler {\n    @Override\n    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n        System.out.println(\"Custom rejection: Task \" + r + \" is rejected.\");\n    }\n}\n\npublic class CustomRejectedPolicyExample {\n    public static void main(String[] args) {\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n                1, 1, 0L, TimeUnit.MILLISECONDS,\n                new ArrayBlockingQueue&#x3C;>(1),\n                new CustomRejectedExecutionHandler());\n\n        executor.execute(() -> {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        executor.execute(() -> System.out.println(\"Task 2\"));\n        executor.execute(() -> System.out.println(\"Task 3\"));\n\n        executor.shutdown();\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>输出结果</strong>：</li>\n</ul>\n<pre><code>Custom rejection: Task java.util.concurrent.ThreadPoolExecutor$Worker@xxxxxx is rejected.\nTask 2\n</code></pre>","type":6,"level":2,"freq":0.006656157,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Java线程池的拒绝策略有哪些。</li>\n  <li><strong>考察点</strong>：对Java线程池工作原理的理解，特别是当线程池达到最大承载能力时，对不同拒绝策略的掌握。</li>\n</ul>\n<h3>2. 背景知识</h3>\n<ul>\n  <li><strong>线程池工作机制</strong>：当提交的任务数超过线程池的最大承载能力（线程池中的线程都在忙碌且任务队列已满）时，就需要采取拒绝策略来处理新提交的任务。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）AbortPolicy（默认策略）</h4>\n<ul>\n  <li><strong>策略内容</strong>：直接抛出RejectedExecutionException异常，阻止系统正常运行。</li>\n  <li><strong>使用场景</strong>：适用于对任务丢失敏感，不允许任务被丢弃的场景，开发者可以捕获异常进行相应处理。</li>\n</ul>\n<h4>（2）CallerRunsPolicy</h4>\n<ul>\n  <li><strong>策略内容</strong>：将任务回退到调用者线程中执行。如果线程池已经关闭，则直接丢弃该任务。</li>\n  <li><strong>使用场景</strong>：可以降低新任务的提交速度，适用于不希望任务丢失，且对性能要求不是特别高的场景。</li>\n</ul>\n<h4>（3）DiscardPolicy</h4>\n<ul>\n  <li><strong>策略内容</strong>：直接丢弃新提交的任务，不做任何处理。</li>\n  <li><strong>使用场景</strong>：适用于对任务丢失不敏感，允许部分任务被丢弃的场景，如日志记录等。</li>\n</ul>\n<h4>（4）DiscardOldestPolicy</h4>\n<ul>\n  <li><strong>策略内容</strong>：丢弃任务队列中最老的任务，然后尝试重新提交新任务。</li>\n  <li><strong>使用场景</strong>：适用于对新任务比较重视，希望优先处理新任务的场景。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">import java.util.concurrent.*;\n\npublic class RejectedPolicyExample {\n    public static void main(String[] args) {\n        // 创建一个固定大小为1的线程池，任务队列容量为1\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n                1, 1, 0L, TimeUnit.MILLISECONDS,\n                new ArrayBlockingQueue&#x3C;>(1),\n                // 使用AbortPolicy拒绝策略\n                new ThreadPoolExecutor.AbortPolicy());\n\n        try {\n            // 提交3个任务，会触发拒绝策略\n            executor.execute(() -> {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"Task 1 executed\");\n            });\n            executor.execute(() -> {\n                System.out.println(\"Task 2 executed\");\n            });\n            executor.execute(() -> {\n                System.out.println(\"Task 3 executed\");\n            });\n        } catch (RejectedExecutionException e) {\n            System.out.println(\"Task rejected: \" + e.getMessage());\n        } finally {\n            executor.shutdown();\n        }\n    }\n}\n</code></pre>\n<ul>\n  <li>在这个例子中，线程池的核心线程数和最大线程数都为1，任务队列容量为1。当提交第3个任务时，会触发AbortPolicy拒绝策略，抛出RejectedExecutionException异常。</li>\n</ul>\n<h3>5. 常见误区</h3>\n<h4>（1）不了解默认策略</h4>\n<ul>\n  <li>误区：不清楚线程池默认的拒绝策略是AbortPolicy。</li>\n  <li>纠正：明确线程池在未指定拒绝策略时，默认使用AbortPolicy。</li>\n</ul>\n<h4>（2）混淆不同拒绝策略的行为</h4>\n<ul>\n  <li>误区：对不同拒绝策略的具体处理方式混淆，如分不清DiscardPolicy和DiscardOldestPolicy的区别。</li>\n  <li>纠正：理解每种拒绝策略的具体行为，根据实际场景选择合适的策略。</li>\n</ul>\n<h4>（3）未考虑业务场景</h4>\n<ul>\n  <li>误区：在选择拒绝策略时，不考虑业务对任务丢失的容忍度和性能要求。</li>\n  <li>纠正：根据业务场景，如任务是否允许丢失、对性能的要求等，选择合适的拒绝策略。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>Java线程池的拒绝策略主要有以下几种：</p>\n<ul>\n  <li><strong>AbortPolicy</strong>：默认策略，直接抛出RejectedExecutionException异常，阻止系统正常运行，适用于对任务丢失敏感的场景。</li>\n  <li><strong>CallerRunsPolicy</strong>：将任务回退到调用者线程中执行，若线程池已关闭则丢弃任务，可降低新任务提交速度，适用于不希望任务丢失且对性能要求不高的场景。</li>\n  <li><strong>DiscardPolicy</strong>：直接丢弃新提交的任务，不做任何处理，适用于对任务丢失不敏感的场景。</li>\n  <li><strong>DiscardOldestPolicy</strong>：丢弃任务队列中最老的任务，然后尝试重新提交新任务，适用于重视新任务的场景。</li>\n</ul>\n<p>在选择拒绝策略时，需要根据业务场景对任务丢失的容忍度和性能要求等因素进行综合考虑。</p>","more_ask":"<ol>\n  <li>\n    <p>\n      请详细阐述 <code>AbortPolicy</code> 拒绝策略在多线程高并发场景下可能引发的问题及解决方案。\n      提示：考虑高并发时任务被拒绝的频率、对系统稳定性的影响，从业务和代码层面思考应对办法。\n    </p>\n  </li>\n  <li>\n    <p>\n      当使用 <code>CallerRunsPolicy</code> 拒绝策略时，如何避免调用线程被长时间阻塞？\n      提示：分析 <code>CallerRunsPolicy</code> 让调用线程执行任务的机制，从任务执行时间、线程资源管理方面考虑。\n    </p>\n  </li>\n  <li>\n    <p>\n      <code>DiscardPolicy</code> 和 <code>DiscardOldestPolicy</code> 在实际应用中分别适用于哪些具体业务场景？\n      提示：结合不同业务对任务丢失的容忍度、任务的时效性等特点来分析。\n    </p>\n  </li>\n  <li>\n    <p>\n      若要自定义一个拒绝策略，需要实现哪个接口，实现该接口时主要关注哪些方法和逻辑？\n      提示：查阅 Java 线程池相关文档，明确自定义拒绝策略的接口，思考拒绝任务时要做的操作。\n    </p>\n  </li>\n  <li>\n    <p>\n      在使用线程池的拒绝策略时，如何监控和统计被拒绝的任务数量？\n      提示：可以从线程池的状态信息、自定义计数器等方面考虑实现监控和统计的方法。\n    </p>\n  </li>\n  <li>\n    <p>\n      当线程池采用 <code>AbortPolicy</code> 拒绝策略抛出 <code>RejectedExecutionException</code> 异常后，如何在业务代码中进行优雅处理？\n      提示：思考异常捕获、日志记录、业务补偿等方面的处理方式。\n    </p>\n  </li>\n  <li>\n    <p>\n      对于 <code>DiscardOldestPolicy</code> 拒绝策略，在队列满时移除最旧任务的具体实现逻辑是怎样的？\n      提示：查看线程池和队列的源码，分析移除最旧任务的步骤和条件。\n    </p>\n  </li>\n  <li>\n    <p>\n      不同的拒绝策略对线程池的性能有怎样的影响？如何根据性能需求选择合适的拒绝策略？\n      提示：从任务处理速度、资源占用、系统响应时间等方面分析不同策略的性能表现。\n    </p>\n  </li>\n</ol>","mindmap":"mindmap\n  root((Java线程池拒绝策略))\n    定义\n      任务队列已满且线程数达最大时对新任务处理方式\n    内置拒绝策略\n      AbortPolicy（默认）\n        描述：无法处理新任务时抛RejectedExecutionException异常\n      CallerRunsPolicy\n        描述：无法处理时由提交任务线程执行\n      DiscardPolicy\n        描述：无法处理时直接丢弃任务，不抛异常\n      DiscardOldestPolicy\n        描述：无法处理时丢弃队列最老任务，重提新任务\n    自定义拒绝策略\n      描述：实现RejectedExecutionHandler接口创建","keynote":"Java线程池拒绝策略定义：任务队列已满且线程数达最大时对新任务处理方式\n内置拒绝策略：\n- AbortPolicy（默认）：无法处理新任务时抛RejectedExecutionException异常\n- CallerRunsPolicy：无法处理时由提交任务线程执行\n- DiscardPolicy：无法处理时直接丢弃任务，不抛异常\n- DiscardOldestPolicy：无法处理时丢弃队列最老任务，重提新任务\n自定义拒绝策略：实现RejectedExecutionHandler接口创建","group_id":5,"kps":["多线程"],"years":[2025,2024,2023,2022],"corps":["快手","蔚来","慧策","B站","同盾科技","京东","阿里国际","易控智驾","字节抖音","美团","字节飞书","字节跳动","法本（阿里外包）","阿里巴巴","OPPO","途虎养车","满帮集团","小米","携程","顺丰","蚂蚁集团","招商银行","百度","瓜子二手车"]}}