{"success":true,"data":{"id":3176,"name":"<p>线程状态及转换？</p>","options":null,"answer":"<p>在Java中，线程的状态可以通过 <code>Thread.State</code> 枚举来表示。一个线程可以处于以下几种状态：</p>\n<ol>\n  <li>\n    <p><strong>NEW</strong>: 线程被创建但尚未被启动。此时线程的 <code>start()</code> 方法尚未被调用。</p>\n  </li>\n  <li>\n    <p><strong>RUNNABLE</strong>: 线程处于可运行状态。这既包括正在执行的线程，也包括在等待CPU时间片的线程。</p>\n  </li>\n  <li>\n    <p><strong>BLOCKED</strong>: 线程因等待获取一个对象的锁而被阻塞。此时线程不会运行，直到它能够获得锁。</p>\n  </li>\n  <li>\n    <p><strong>WAITING</strong>: 线程在等待另一个线程的特定操作（如 <code>Object.wait()</code>、<code>Thread.join()</code> 或 <code>LockSupport.park()</code>）完成。此状态的线程不会占用CPU资源。</p>\n  </li>\n  <li>\n    <p><strong>TIMED_WAITING</strong>: 线程在等待另一个线程的特定操作，并指定了最长等待时间。此状态通常由 <code>Thread.sleep(millis)</code>、<code>Object.wait(millis)</code>、<code>Thread.join(millis)</code> 或 <code>LockSupport.parkNanos(nanos)</code> 引起。</p>\n  </li>\n  <li>\n    <p><strong>TERMINATED</strong>: 线程的生命周期已经结束，线程的 <code>run()</code> 方法执行完毕或者由于异常而终止。</p>\n  </li>\n</ol>\n<h3>线程状态之间的转换</h3>\n<p>线程的状态会在以下情况下相互转换：</p>\n<ul>\n  <li>\n    <p>从 <strong>NEW</strong> 到 <strong>RUNNABLE</strong>: 当调用了线程的 <code>start()</code> 方法时，线程就会从 NEW 状态转为 RUNNABLE 状态。</p>\n  </li>\n  <li>\n    <p>从 <strong>RUNNABLE</strong> 到 <strong>BLOCKED</strong>: 当一个线程尝试获取一个被其他线程持有的锁时，它将进入 BLOCKED 状态。</p>\n  </li>\n  <li>\n    <p>从 <strong>RUNNABLE</strong> 到 <strong>WAITING</strong>: 当一个线程调用了其他线程的 <code>join()</code> 方法，或调用了 <code>Object.wait()</code> 方法时，它将进入 WAITING 状态。</p>\n  </li>\n  <li>\n    <p>从 <strong>RUNNABLE</strong> 到 <strong>TIMED_WAITING</strong>: 当一个线程调用了 <code>Thread.sleep(milliseconds)</code> 方法，或者调用了带有超时时间的 <code>wait()</code>、<code>join()</code> 方法等时，线程将进入 TIMED_WAITING 状态。</p>\n  </li>\n  <li>\n    <p>从 <strong>WAITING</strong> 或 <strong>TIMED_WAITING</strong> 到 <strong>RUNNABLE</strong>: 当被等待的操作完成（如其他线程调用了 <code>notify()</code> 或 <code>notifyAll()</code>，或等待的线程结束），线程将返回 RUNNABLE 状态。</p>\n  </li>\n  <li>\n    <p>从 <strong>RUNNABLE</strong> 到 <strong>TERMINATED</strong>: 当线程的 <code>run()</code> 方法执行完毕或因未处理的异常导致线程终止时，状态将变为 TERMINATED。</p>\n  </li>\n</ul>\n<p>总之，线程的状态转换由程序逻辑和线程间的交互决定，每种状态都有其特定的转变条件。Java中的多线程编程需要了解这些状态和转换，以便更好地控制线程的行为和响应。</p>","type":6,"level":2,"freq":0.0007023705,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Java中线程的状态有哪些以及它们之间如何转换？</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Java线程状态的掌握。</li>\n      <li>理解不同状态之间转换的条件和触发因素。</li>\n      <li>对多线程编程中线程生命周期的理解。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）线程的基本概念</h4>\n<p>线程是程序执行的最小单位，Java提供了丰富的多线程编程支持。线程在其生命周期中会经历不同的状态，了解这些状态和转换有助于更好地编写多线程程序。</p>\n<h4>（2）状态的意义</h4>\n<p>不同的线程状态代表了线程在某一时刻的执行情况，例如是否正在运行、是否在等待资源等。</p>\n<h3>3. 解析</h3>\n<h4>（1）Java线程的六种状态</h4>\n<ul>\n  <li><strong>NEW（新建）</strong>：当创建一个<code>Thread</code>对象时，线程处于此状态。此时线程还未启动，只是一个对象实例，如<code>Thread t = new Thread();</code>。</li>\n  <li><strong>RUNNABLE（可运行）</strong>：调用<code>start()</code>方法后，线程进入此状态。它表示线程可以被线程调度器调度执行，包含两种情况：正在执行和准备执行。在准备执行时，线程处于就绪队列等待CPU资源。</li>\n  <li><strong>BLOCKED（阻塞）</strong>：线程在等待获取一个排他锁（如<code>synchronized</code>块）时，会进入此状态。当其他线程持有该锁时，当前线程会被阻塞，直到锁被释放并被当前线程获取。</li>\n  <li><strong>WAITING（无限期等待）</strong>：线程调用<code>Object.wait()</code>、<code>Thread.join()</code>或<code>LockSupport.park()</code>方法后，会进入此状态。处于此状态的线程需要其他线程显式唤醒，如调用<code>Object.notify()</code>或<code>Object.notifyAll()</code>方法。</li>\n  <li><strong>TIMED_WAITING（限期等待）</strong>：与<code>WAITING</code>类似，但可以指定等待时间。调用<code>Thread.sleep(long millis)</code>、<code>Object.wait(long timeout)</code>、<code>Thread.join(long millis)</code>或<code>LockSupport.parkNanos(long nanos)</code>等方法会使线程进入此状态。在指定时间到达后，线程会自动唤醒。</li>\n  <li><strong>TERMINATED（终止）</strong>：线程执行完<code>run()</code>方法或者因异常退出<code>run()</code>方法后，进入此状态，表明线程的生命周期结束。</li>\n</ul>\n<h4>（2）状态转换</h4>\n<ul>\n  <li><strong>NEW -> RUNNABLE</strong>：调用<code>Thread</code>对象的<code>start()</code>方法，线程从新建状态转换为可运行状态。</li>\n  <li><strong>RUNNABLE &#x3C;-> BLOCKED</strong>：当线程尝试获取一个被其他线程持有的排他锁时，从<code>RUNNABLE</code>状态进入<code>BLOCKED</code>状态；当锁被释放并被当前线程获取时，从<code>BLOCKED</code>状态回到<code>RUNNABLE</code>状态。</li>\n  <li><strong>RUNNABLE &#x3C;-> WAITING</strong>：线程调用<code>Object.wait()</code>、<code>Thread.join()</code>或<code>LockSupport.park()</code>方法，从<code>RUNNABLE</code>状态进入<code>WAITING</code>状态；其他线程调用<code>Object.notify()</code>或<code>Object.notifyAll()</code>方法唤醒等待线程时，线程从<code>WAITING</code>状态回到<code>RUNNABLE</code>状态。</li>\n  <li><strong>RUNNABLE &#x3C;-> TIMED_WAITING</strong>：调用<code>Thread.sleep(long millis)</code>、<code>Object.wait(long timeout)</code>、<code>Thread.join(long millis)</code>或<code>LockSupport.parkNanos(long nanos)</code>等方法，线程从<code>RUNNABLE</code>状态进入<code>TIMED_WAITING</code>状态；当指定时间到达或者被其他线程提前唤醒时，线程从<code>TIMED_WAITING</code>状态回到<code>RUNNABLE</code>状态。</li>\n  <li><strong>RUNNABLE -> TERMINATED</strong>：线程的<code>run()</code>方法执行完毕或者因异常退出<code>run()</code>方法，线程从<code>RUNNABLE</code>状态进入<code>TERMINATED</code>状态。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">class MyThread extends Thread {\n    public void run() {\n        try {\n            System.out.println(\"线程进入RUNNABLE状态\");\n            // 模拟线程执行任务\n            Thread.sleep(1000);\n            System.out.println(\"线程进行TIMED_WAITING状态\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"线程任务执行完毕，进入TERMINATED状态\");\n    }\n}\n\npublic class ThreadStateExample {\n    public static void main(String[] args) {\n        MyThread t = new MyThread();\n        System.out.println(\"线程处于NEW状态\");\n        t.start();\n    }\n}\n</code></pre>\n<p>在这个例子中，<code>MyThread</code>线程对象创建时处于<code>NEW</code>状态，调用<code>start()</code>方法后进入<code>RUNNABLE</code>状态，执行<code>Thread.sleep(1000)</code>时进入<code>TIMED_WAITING</code>状态，任务执行完毕后进入<code>TERMINATED</code>状态。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆<code>RUNNABLE</code>和运行中状态</h4>\n<p>\n  误区：认为<code>RUNNABLE</code>就是线程正在运行。实际上，<code>RUNNABLE</code>包含了线程正在执行和准备执行两种情况，线程处于就绪队列等待CPU资源时也属于<code>RUNNABLE</code>状态。\n  纠正：明确<code>RUNNABLE</code>状态的准确含义，它只是表示线程可以被调度执行。\n</p>\n<h4>（2）对<code>WAITING</code>和<code>TIMED_WAITING</code>区分不清</h4>\n<p>\n  误区：不能准确区分这两种状态的差异。\n  纠正：<code>WAITING</code>是无限期等待，需要其他线程显式唤醒；<code>TIMED_WAITING</code>是限期等待，指定时间到达后会自动唤醒。\n</p>\n<h4>（3）忽略状态转换的条件</h4>\n<p>\n  误区：只记住了线程状态，而不清楚状态之间转换的具体条件。\n  纠正：理解每个状态转换是由哪些方法调用或事件触发的，如<code>start()</code>、<code>wait()</code>、<code>notify()</code>等。\n</p>\n<h3>6. 总结回答</h3>\n<p>Java线程有六种状态，分别是<code>NEW</code>（新建）、<code>RUNNABLE</code>（可运行）、<code>BLOCKED</code>（阻塞）、<code>WAITING</code>（无限期等待）、<code>TIMED_WAITING</code>（限期等待）和<code>TERMINATED</code>（终止）。</p>\n<p>状态转换如下：调用<code>start()</code>方法使线程从<code>NEW</code>状态进入<code>RUNNABLE</code>状态；线程尝试获取被其他线程持有的排他锁时，从<code>RUNNABLE</code>进入<code>BLOCKED</code>状态，锁释放并获取后回到<code>RUNNABLE</code>状态；调用<code>Object.wait()</code>等方法使线程从<code>RUNNABLE</code>进入<code>WAITING</code>状态，其他线程调用<code>Object.notify()</code>等方法唤醒时回到<code>RUNNABLE</code>状态；调用<code>Thread.sleep()</code>等指定时间的方法使线程从<code>RUNNABLE</code>进入<code>TIMED_WAITING</code>状态，时间到达或提前唤醒回到<code>RUNNABLE</code>状态；线程<code>run()</code>方法执行完毕或异常退出时从<code>RUNNABLE</code>进入<code>TERMINATED</code>状态。</p>\n<p>需要注意的是，<code>RUNNABLE</code>状态包含正在执行和准备执行两种情况；<code>WAITING</code>是无限期等待，<code>TIMED_WAITING</code>是限期等待。理解这些状态和转换对于编写多线程程序非常重要。</p>","more_ask":"<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>线程安全是什么？如何保证线程安全？</strong></p>\n    <ul>\n      <li>提示：讨论同步、锁机制以及线程安全的集合类。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>解释一下Java中的死锁，并给出如何避免死锁的方法。</strong></p>\n    <ul>\n      <li>提示：考虑资源的获取顺序和使用并发工具类。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>什么是线程池？线程池的优势是什么？</strong></p>\n    <ul>\n      <li>提示：讨论资源管理、性能优化以及任务重用。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你如何在Java中实现生产者-消费者模式？</strong></p>\n    <ul>\n      <li>提示：考虑使用wait/notify或使用BlockingQueue。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>Java中的volatile关键字是如何工作的？有什么用？</strong></p>\n    <ul>\n      <li>提示：讨论可见性、顺序性以及与其他同步机制的区别。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>什么是Fork/Join框架？适合什么场景？</strong></p>\n    <ul>\n      <li>提示：考虑任务的递归分解和并行处理。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>解释一下Java中的Future和Callable接口的区别。</strong></p>\n    <ul>\n      <li>提示：考虑返回值和异常处理。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你了解JUC (Java.util.concurrent)包吗？能举几个例子吗？</strong></p>\n    <ul>\n      <li>提示：讨论ConcurrentHashMap、CountDownLatch等。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>什么是线程的上下文切换？它的性能影响是什么？</strong></p>\n    <ul>\n      <li>提示：考虑CPU时间、阻塞和上下文数据的保存。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何调试多线程程序中的问题？</strong></p>\n    <ul>\n      <li>提示：考虑使用日志、线程转储和调试工具。</li>\n    </ul>\n  </li>\n</ol>","mindmap":"mindmap\n  root((Java线程状态))\n    NEW\n      start()未被调用\n    RUNNABLE\n      正在执行\n      等待CPU时间片\n    BLOCKED\n      等待获取对象锁\n    WAITING\n      等待其他线程特定操作\n    TIMED_WAITING\n      等待带有超时时间的操作\n    TERMINATED\n      run()方法执行完毕\n      异常导致终止\n    状态转换\n      NEW -> RUNNABLE\n        调用start()\n      RUNNABLE -> BLOCKED\n        尝试获取被占用的锁\n      RUNNABLE -> WAITING\n        调用join()或Object.wait()\n      RUNNABLE -> TIMED_WAITING\n        调用sleep()或带超时的wait()/join()\n      WAITING/TIMED_WAITING -> RUNNABLE\n        等待的操作完成\n      RUNNABLE -> TERMINATED\n        run()结束或异常终止","keynote":"- Java中线程的状态通过`Thread.State`枚举表示。\n- **NEW**：线程已创建但未启动。\n- **RUNNABLE**：线程可运行，包括正在执行和等待CPU资源。\n- **BLOCKED**：线程因尝试获取锁而阻塞。\n- **WAITING**：线程无限期等待另一线程操作完成。\n- **TIMED_WAITING**：线程等待一段时间后自动唤醒。\n- **TERMINATED**：线程已完成执行或因异常终止。\n- **NEW**至**RUNNABLE**：调用`start()`方法。\n- **RUNNABLE**至**BLOCKED**：尝试获取已被占用的锁。\n- **RUNNABLE**至**WAITING**：调用`join()`或`Object.wait()`。\n- **RUNNABLE**至**TIMED_WAITING**：调用带超时参数的方法如`sleep()`、`wait()`等。\n- **WAITING**/**TIMED_WAITING**至**RUNNABLE**：等待条件满足。\n- **RUNNABLE**至**TERMINATED**：线程正常结束或异常。","group_id":5,"kps":["多线程"],"years":[2024,2023,2022],"corps":["华为OD","阿里巴巴","爱数科技","顺丰"]}}