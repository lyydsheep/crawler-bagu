{
  "success": true,
  "data": {
    "id": 3178,
    "name": "<p>线程的 run() 和 start() 有什么区别？</p>",
    "options": null,
    "answer": "<p>在Java中，<code>run()</code> 和 <code>start()</code> 是线程类 (<code>Thread</code>) 中的重要方法，但它们的功能和使用方式有显著的区别。</p>\n<h3><code>run()</code></h3>\n<ul>\n  <li><strong>定义</strong>：<code>run()</code> 方法包含了线程的执行逻辑。当你创建一个线程并调用 <code>run()</code> 方法时，实际上是在当前线程中执行这个方法，而不是在新线程中。</li>\n  <li><strong>使用方式</strong>：通常不直接调用 <code>run()</code> 方法来启动线程。它一般是被 <code>start()</code> 方法内部调用，或者在实现 <code>Runnable</code> 接口时被重写。</li>\n  <li><strong>执行方式</strong>：单纯调用 <code>run()</code> 方法，就像调用普通的方法，执行在调用它的线程中。</li>\n</ul>\n<h3><code>start()</code></h3>\n<ul>\n  <li><strong>定义</strong>：<code>start()</code> 方法用于启动一个新线程。调用 <code>start()</code> 方法后，JVM 会创建一个新的线程，然后调用这个线程的 <code>run()</code> 方法。</li>\n  <li><strong>使用方式</strong>：这是启动线程的标准方法。你应该通过 <code>start()</code> 方法来启动线程，而不是直接调用 <code>run()</code> 方法。</li>\n  <li><strong>执行方式</strong>：一旦调用 <code>start()</code>，新线程会被调度执行，并且 <code>run()</code> 方法将在这个新线程中运行。</li>\n</ul>\n<h3>示例代码</h3>\n<pre><code class=\"language-java\">class MyThread extends Thread {\n    public void run() {\n        System.out.println(\"Thread is running\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyThread thread = new MyThread();\n        \n        // Calling run() method\n        thread.run();  // 这将在主线程中运行，输出 \"Thread is running\"\n        \n        // Starting new thread\n        thread.start();  // 这将在新线程中运行，输出 \"Thread is running\"\n    }\n}\n</code></pre>\n<h3>小结</h3>\n<ul>\n  <li>使用 <code>run()</code> 是在当前线程中执行逻辑，不创建新线程。</li>\n  <li>使用 <code>start()</code> 运行新线程并调用 <code>run()</code> 方法。</li>\n</ul>\n<p>因此，应该始终通过 <code>start()</code> 方法来启动线程，而不是直接调用 <code>run()</code>。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.0001755926,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Java中线程的<code>run()</code>和<code>start()</code>方法有什么区别？</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Java线程启动机制的理解。</li>\n      <li><code>run()</code>和<code>start()</code>方法的功能及使用场景。</li>\n      <li>多线程执行和单线程执行的差异。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）Java线程基础</h4>\n<p>Java中的线程是实现多任务并发执行的重要机制。创建线程通常有两种方式，继承<code>Thread</code>类或实现<code>Runnable</code>接口，这两种方式都需要实现<code>run()</code>方法，该方法定义了线程要执行的任务。</p>\n<h4>（2）线程的生命周期</h4>\n<p>线程有不同的生命周期阶段，包括新建、就绪、运行、阻塞和终止。线程启动后会进入就绪状态，等待CPU调度进入运行状态。</p>\n<h3>3. 解析</h3>\n<h4>（1）<code>run()</code>方法</h4>\n<ul>\n  <li><strong>功能</strong>：<code>run()</code>方法是线程要执行的具体任务代码所在的方法。它只是一个普通的方法，和其他方法调用一样，不会启动新的线程。</li>\n  <li><strong>执行方式</strong>：当直接调用<code>run()</code>方法时，程序会按照顺序执行<code>run()</code>方法中的代码，属于单线程执行模式，即当前线程会执行<code>run()</code>方法中的代码，执行完后才会继续执行后续代码。</li>\n</ul>\n<h4>（2）<code>start()</code>方法</h4>\n<ul>\n  <li><strong>功能</strong>：<code>start()</code>方法用于启动一个新的线程。它会使线程进入就绪状态，等待CPU调度执行。当线程获得CPU时间片后，会自动调用<code>run()</code>方法。</li>\n  <li><strong>执行方式</strong>：调用<code>start()</code>方法会开启一个新的线程，新线程和当前线程并发执行，实现多线程编程。</li>\n</ul>\n<h4>（3）两者区别总结</h4>\n<ul>\n  <li><strong>执行方式</strong>：<code>run()</code>是普通方法调用，单线程顺序执行；<code>start()</code>启动新线程，实现多线程并发执行。</li>\n  <li><strong>作用</strong>：<code>run()</code>定义线程任务；<code>start()</code>触发线程启动和执行。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">class MyThread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i &#x3C; 3; i++) {\n            System.out.println(Thread.currentThread().getName() + \": \" + i);\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\npublic class ThreadTest {\n    public static void main(String[] args) {\n        MyThread thread = new MyThread();\n        // 直接调用run()方法\n        System.out.println(\"直接调用run()方法：\");\n        thread.run();\n        // 调用start()方法\n        System.out.println(\"调用start()方法：\");\n        MyThread newThread = new MyThread();\n        newThread.start();\n        for (int i = 0; i &#x3C; 3; i++) {\n            System.out.println(Thread.currentThread().getName() + \": \" + i);\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n<ul>\n  <li>在上述代码中，直接调用<code>run()</code>方法时，会顺序执行<code>run()</code>方法中的代码；调用<code>start()</code>方法时，新线程会和主线程并发执行。</li>\n</ul>\n<h3>5. 常见误区</h3>\n<h4>（1）认为<code>run()</code>和<code>start()</code>效果相同</h4>\n<ul>\n  <li>误区：不清楚两者区别，以为调用<code>run()</code>和<code>start()</code>都能启动新线程。</li>\n  <li>纠正：明确<code>run()</code>是普通方法调用，<code>start()</code>才是启动新线程的方法。</li>\n</ul>\n<h4>（2）多次调用<code>start()</code>方法</h4>\n<ul>\n  <li>误区：认为可以多次调用<code>start()</code>方法来重新启动线程。</li>\n  <li>纠正：一个线程对象的<code>start()</code>方法只能调用一次，多次调用会抛出<code>IllegalThreadStateException</code>异常。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“在Java中，线程的<code>run()</code>和<code>start()</code>方法有明显区别。<code>run()</code>方法是线程要执行的具体任务代码所在的方法，它只是一个普通的方法，直接调用<code>run()</code>方法不会启动新的线程，而是在当前线程中顺序执行<code>run()</code>方法中的代码，属于单线程执行模式。</p>\n<p>而<code>start()</code>方法用于启动一个新的线程，它会使线程进入就绪状态，等待CPU调度执行。当线程获得CPU时间片后，会自动调用<code>run()</code>方法，实现多线程并发执行。</p>\n<p>需要注意的是，一个线程对象的<code>start()</code>方法只能调用一次，多次调用会抛出<code>IllegalThreadStateException</code>异常。”</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>线程的生命周期</strong><br>提示：你能描述一下线程的不同状态吗？例如，如何在运行中、阻塞和等待状态之间切换？</p>\n  </li>\n  <li>\n    <p><strong>线程安全</strong><br>提示：在多线程环境下，如何保障数据的安全性？你熟悉哪些线程安全的集合类？</p>\n  </li>\n  <li>\n    <p><strong>同步机制</strong><br>提示：你能解释一下synchronized关键字的使用吗？它与Lock接口有什么区别？</p>\n  </li>\n  <li>\n    <p><strong>volatile关键字</strong><br>提示：volatile的作用是什么？它如何影响线程间的可见性？</p>\n  </li>\n  <li>\n    <p><strong>线程池</strong><br>提示：你能说一下Java中的线程池吗？使用线程池的好处是什么？</p>\n  </li>\n  <li>\n    <p><strong>Callable与Runnable</strong><br>提示：Callable与Runnable接口有什么不同？它们分别适用于什么场景？</p>\n  </li>\n  <li>\n    <p><strong>死锁问题</strong><br>提示：什么是死锁？如何避免死锁的发生？</p>\n  </li>\n  <li>\n    <p><strong>ThreadLocal</strong><br>提示：ThreadLocal是什么？在多线程中如何使用它？</p>\n  </li>\n  <li>\n    <p><strong>并发工具类</strong><br>提示：你对java.util.concurrent包中的工具类了解吗？举几个例子并说明它们适合的使用场景。</p>\n  </li>\n  <li>\n    <p><strong>Fork/Join框架</strong><br>提示：你能简单阐述一下Fork/Join框架吗？它是如何提高并行计算效率的？</p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Java线程方法))\n    run()\n      定义\n      使用方式\n      执行方式\n    start()\n      定义\n      使用方式\n      执行方式",
    "keynote": "- `run()` 方法包含线程的执行逻辑，但直接调用不会启动新线程。\n- `start()` 方法用于创建并启动一个新线程，在其中执行 `run()` 方法。\n- 应使用 `start()` 来启动线程，而不是直接调用 `run()`。",
    "group_id": 5,
    "kps": [
      "多线程"
    ],
    "years": [
      2024
    ],
    "corps": [
      "科大讯飞"
    ]
  }
}