{"success":true,"data":{"id":7184,"name":"<p>什么是可重入锁ReentrantLock</p>","options":null,"answer":"<p><code>ReentrantLock</code> 是 Java 中的一种可重入锁，属于 <code>java.util.concurrent.locks</code> 包。它实现了 <code>Lock</code> 接口，提供了比 <code>synchronized</code> 关键字更灵活和功能丰富的锁机制。可重入性是指同一个线程在获得锁后，可以再次获得该锁而不会被阻塞。</p>\n<h3>特性和特点</h3>\n<ol>\n  <li>\n    <p><strong>可重入性</strong>：</p>\n    <ul>\n      <li>当一个线程已经获得了锁，再次请求同样的锁时，它可以继续获取锁，而不会导致死锁。这是通过维护一个计数器和持有锁的线程标识来实现的。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>公平性</strong>：</p>\n    <ul>\n      <li><code>ReentrantLock</code> 可以选择是否为公平锁。如果公平性设置为 <code>true</code>，则先请求锁的线程会优先获得锁；如果设置为 <code>false</code>，则不保证锁的请求顺序，可能会导致某些线程长时间得不到锁。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>可中断的锁获取</strong>：</p>\n    <ul>\n      <li>使用 <code>lockInterruptibly()</code> 方法，线程在获取锁时可以响应中断。如果线程在等待获取锁的过程中被中断，它将会抛出一个 <code>InterruptedException</code>。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>条件变量</strong>：</p>\n    <ul>\n      <li><code>ReentrantLock</code> 提供了条件变量（<code>Condition</code>），可以用来实现线程间的通信。这些条件变量可以替代 <code>Object</code> 类中的 <code>wait()</code> 和 <code>notify()</code> 方法。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>非阻塞尝试锁获取</strong>：</p>\n    <ul>\n      <li>可以使用 <code>tryLock()</code> 方法尝试获取锁，如果获取失败，可以选择继续执行其他操作，而不是被阻塞。</li>\n    </ul>\n  </li>\n</ol>\n<h3>使用示例</h3>\n<p>下面是一个使用 <code>ReentrantLock</code> 的简单示例：</p>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReentrantLock;\n\npublic class ReentrantLockExample {\n    private final ReentrantLock lock = new ReentrantLock();\n    \n    public void safeMethod() {\n        lock.lock(); // 获取锁\n        try {\n            // 进行线程安全的操作\n            System.out.println(\"Thread \" + Thread.currentThread().getName() + \" is executing safeMethod\");\n        } finally {\n            lock.unlock(); // 一定要释放锁\n        }\n    }\n    \n    public static void main(String[] args) {\n        ReentrantLockExample example = new ReentrantLockExample();\n        \n        Runnable task = example::safeMethod;\n        \n        Thread thread1 = new Thread(task);\n        Thread thread2 = new Thread(task);\n        \n        thread1.start();\n        thread2.start();\n    }\n}\n</code></pre>\n<p>在这个示例中，<code>safeMethod</code> 方法被多个线程调用，但 <code>ReentrantLock</code> 会确保同一时间只有一个线程可以进入这个方法，从而保证了线程安全。</p>","type":6,"level":3,"freq":0.0005267779,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：什么是可重入锁ReentrantLock。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对可重入锁概念的理解。</li>\n      <li>ReentrantLock的特性。</li>\n      <li>ReentrantLock与其他锁的对比。</li>\n      <li>ReentrantLock的使用场景。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）锁的基本概念</h4>\n<p>在多线程编程中，锁是一种用于控制多个线程对共享资源访问的机制，防止多个线程同时修改共享资源而导致数据不一致的问题。</p>\n<h4>（2）可重入性</h4>\n<p>可重入是指同一个线程在持有锁的情况下，可以再次获取该锁而不会被阻塞。如果一个锁是可重入的，那么同一个线程可以多次进入被该锁保护的代码块。</p>\n<h3>3. 解析</h3>\n<h4>（1）ReentrantLock的定义</h4>\n<p>ReentrantLock是Java中java.util.concurrent.locks包下的一个类，它实现了Lock接口，是一种可重入的互斥锁。和synchronized关键字类似，它可以保证在同一时刻只有一个线程能够访问被保护的代码块。</p>\n<h4>（2）可重入特性</h4>\n<p>ReentrantLock具有可重入性，即同一个线程可以多次获取同一把锁。每次获取锁时，锁的持有计数会加1，每次释放锁时，持有计数会减1。只有当持有计数为0时，锁才会被真正释放，其他线程才能获取该锁。</p>\n<h4>（3）与synchronized的对比</h4>\n<ul>\n  <li><strong>灵活性</strong>：ReentrantLock比synchronized更加灵活。它提供了更多的方法，如可中断的锁获取（lockInterruptibly()）、尝试获取锁（tryLock()）等。</li>\n  <li><strong>公平性</strong>：ReentrantLock可以选择公平锁或非公平锁。公平锁会按照线程请求锁的顺序来分配锁，而非公平锁则不保证这一点。synchronized是非公平锁。</li>\n  <li><strong>锁的释放</strong>：synchronized是隐式释放锁，当同步块或同步方法执行完毕时，锁会自动释放。而ReentrantLock需要手动调用unlock()方法来释放锁，通常需要在finally块中调用，以确保锁一定会被释放。</li>\n</ul>\n<h4>（4）使用场景</h4>\n<ul>\n  <li>当需要更细粒度的锁控制时，如可中断的锁获取、尝试获取锁等，ReentrantLock更合适。</li>\n  <li>当需要使用公平锁时，ReentrantLock可以满足需求。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReentrantLock;\n\npublic class ReentrantLockExample {\n    private final ReentrantLock lock = new ReentrantLock();\n\n    public void performTask() {\n        lock.lock();\n        try {\n            // 模拟一些需要同步的操作\n            System.out.println(Thread.currentThread().getName() + \" 获取了锁\");\n            nestedTask();\n        } finally {\n            lock.unlock();\n            System.out.println(Thread.currentThread().getName() + \" 释放了锁\");\n        }\n    }\n\n    private void nestedTask() {\n        lock.lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + \" 再次获取了锁\");\n        } finally {\n            lock.unlock();\n            System.out.println(Thread.currentThread().getName() + \" 释放了嵌套的锁\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ReentrantLockExample example = new ReentrantLockExample();\n        new Thread(example::performTask).start();\n    }\n}\n</code></pre>\n<p>在这个例子中，<code>performTask</code>方法和<code>nestedTask</code>方法都使用了同一个ReentrantLock对象。同一个线程可以在<code>performTask</code>方法中获取锁后，再次在<code>nestedTask</code>方法中获取该锁，体现了ReentrantLock的可重入性。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）忘记释放锁</h4>\n<p>\n  误区：在使用ReentrantLock时，忘记在finally块中调用unlock()方法，导致锁无法释放，其他线程无法获取锁。\n  纠正：始终在finally块中调用unlock()方法，确保锁一定会被释放。\n</p>\n<h4>（2）混淆公平锁和非公平锁</h4>\n<p>\n  误区：不清楚公平锁和非公平锁的区别，随意选择锁的类型。\n  纠正：了解公平锁和非公平锁的特点，根据具体需求选择合适的锁类型。\n</p>\n<h4>（3）过度使用ReentrantLock</h4>\n<p>\n  误区：在不需要复杂锁控制的场景下，也使用ReentrantLock，增加了代码的复杂度。\n  纠正：如果只是简单的同步需求，使用synchronized关键字可能更简洁。\n</p>\n<h3>6. 总结回答</h3>\n<p>可重入锁ReentrantLock是Java中java.util.concurrent.locks包下实现了Lock接口的一个类，它是一种可重入的互斥锁。可重入性意味着同一个线程可以多次获取同一把锁，每次获取锁时锁的持有计数加1，释放锁时持有计数减1，当持有计数为0时锁才真正释放。</p>\n<p>与synchronized关键字相比，ReentrantLock更加灵活，提供了可中断的锁获取、尝试获取锁等方法，还可以选择公平锁或非公平锁。使用ReentrantLock时需要手动调用unlock()方法释放锁，通常在finally块中调用以确保锁一定被释放。</p>\n<p>ReentrantLock适用于需要更细粒度锁控制或使用公平锁的场景，但在简单同步需求下，synchronized关键字可能更简洁。在使用ReentrantLock时，要注意避免忘记释放锁、混淆公平锁和非公平锁以及过度使用等问题。</p>","more_ask":"<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>与synchronized的比较</strong><br>提示：请解释ReentrantLock与synchronized关键字的区别和各自的优缺点。</p>\n  </li>\n  <li>\n    <p><strong>公平锁与非公平锁</strong><br>提示：什么是公平锁和非公平锁？ReentrantLock的构造方法中如何指定锁的公平性？</p>\n  </li>\n  <li>\n    <p><strong>锁的性能</strong><br>提示：在什么情况下你认为使用ReentrantLock会有性能上的优势或劣势？</p>\n  </li>\n  <li>\n    <p><strong>锁的中断</strong><br>提示：ReentrantLock如何支持锁的中断？请举例说明使用方法。</p>\n  </li>\n  <li>\n    <p><strong>条件变量</strong><br>提示：ReentrantLock与Condition的关系是什么？如何使用Condition实现生产者-消费者模式？</p>\n  </li>\n  <li>\n    <p><strong>可重入的实现机制</strong><br>提示：ReentrantLock是如何实现可重入性的？具体的机制是什么？</p>\n  </li>\n  <li>\n    <p><strong>锁的释放</strong><br>提示：如果在使用ReentrantLock时抛出了异常，会发生什么？如何确保锁的正确释放？</p>\n  </li>\n  <li>\n    <p><strong>公平性带来的影响</strong><br>提示：在高并发情况下，使用公平锁会对性能产生怎样的影响？</p>\n  </li>\n  <li>\n    <p><strong>性能测试或调优经验</strong><br>提示：你是否经历过因锁相关问题导致的性能瓶颈？你是如何解决的？</p>\n  </li>\n  <li>\n    <p><strong>嵌套锁的处理</strong><br>提示：如果一个线程多次获取同一个ReentrantLock，它是否会导致死锁？为什么？</p>\n  </li>\n</ol>","mindmap":"mindmap\n  root((ReentrantLock))\n    特性和特点\n      可重入性\n      公平性\n      可中断的锁获取\n      条件变量\n      非阻塞尝试锁获取\n    使用示例","keynote":"- ReentrantLock 是 Java 中的一种可重入锁，位于 `java.util.concurrent.locks` 包。\n- 实现了 Lock 接口，提供比 synchronized 更灵活的功能。\n- 可重入性允许线程重复获取同一把锁而不导致死锁。\n- 支持公平与非公平模式选择。\n- 提供 lockInterruptibly() 方法支持中断响应。\n- 通过 Condition 对象支持线程间的条件等待和唤醒。\n- tryLock() 方法允许非阻塞地尝试获取锁。","group_id":5,"kps":["多线程","Java API与常用库"],"years":[2023],"corps":["北森","美团","快手"]}}