{"success":true,"data":{"id":14916,"name":"<p>除了常见的锁，还了解哪些Java中的锁</p>","options":null,"answer":"<p>在 Java 中，除了常见的 <code>synchronized</code> 关键字和 <code>ReentrantLock</code> 等锁之外，还有许多其他类型的锁，下面为你详细介绍：</p>\n<h3>1. 读写锁（<code>ReentrantReadWriteLock</code>）</h3>\n<ul>\n  <li><strong>特点</strong>：允许多个线程同时进行读操作，但在写操作时会独占锁，即同一时间只能有一个线程进行写操作，并且在写操作进行时，不允许其他线程进行读操作。这种锁适用于读多写少的场景，可以提高并发性能。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class ReadWriteLockExample {\n    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n    private final ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();\n    private final ReentrantReadWriteLock.WriteLock writeLock = rwLock.writeLock();\n    private int data = 0;\n\n    public int readData() {\n        readLock.lock();\n        try {\n            return data;\n        } finally {\n            readLock.unlock();\n        }\n    }\n\n    public void writeData(int newData) {\n        writeLock.lock();\n        try {\n            data = newData;\n        } finally {\n            writeLock.unlock();\n        }\n    }\n}\n</code></pre>\n<h3>2. StampedLock</h3>\n<ul>\n  <li><strong>特点</strong>：<code>StampedLock</code> 是 Java 8 引入的一种新的锁机制，它提供了比 <code>ReentrantReadWriteLock</code> 更细粒度的控制和更好的性能。它支持三种模式：写锁、读锁和乐观读。乐观读模式下，不会阻塞写操作，通过版本号（戳）来判断数据是否被修改。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.StampedLock;\n\npublic class StampedLockExample {\n    private final StampedLock stampedLock = new StampedLock();\n    private int data = 0;\n\n    public int readData() {\n        long stamp = stampedLock.tryOptimisticRead();\n        int currentData = data;\n        if (!stampedLock.validate(stamp)) {\n            stamp = stampedLock.readLock();\n            try {\n                currentData = data;\n            } finally {\n                stampedLock.unlockRead(stamp);\n            }\n        }\n        return currentData;\n    }\n\n    public void writeData(int newData) {\n        long stamp = stampedLock.writeLock();\n        try {\n            data = newData;\n        } finally {\n            stampedLock.unlockWrite(stamp);\n        }\n    }\n}\n</code></pre>\n<h3>3. 公平锁和非公平锁</h3>\n<ul>\n  <li><strong>特点</strong>：公平锁和非公平锁并不是具体的锁类，而是锁的一种特性。公平锁会按照线程请求锁的顺序来分配锁，保证每个线程都有公平的机会获取锁；非公平锁则不保证线程获取锁的顺序，可能会导致某些线程长时间得不到锁，但通常具有更高的性能。<code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 都可以通过构造函数指定是否为公平锁。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReentrantLock;\n\npublic class FairLockExample {\n    private final ReentrantLock fairLock = new ReentrantLock(true); // 公平锁\n    private final ReentrantLock nonFairLock = new ReentrantLock(false); // 非公平锁\n\n    public void fairLockMethod() {\n        fairLock.lock();\n        try {\n            // 执行操作\n        } finally {\n            fairLock.unlock();\n        }\n    }\n\n    public void nonFairLockMethod() {\n        nonFairLock.lock();\n        try {\n            // 执行操作\n        } finally {\n            nonFairLock.unlock();\n        }\n    }\n}\n</code></pre>\n<h3>4. 自旋锁</h3>\n<ul>\n  <li><strong>特点</strong>：自旋锁是一种忙等待的锁机制，当线程尝试获取锁失败时，不会进入阻塞状态，而是不断地循环检查锁是否可用。自旋锁适用于锁被持有时间较短的场景，可以避免线程上下文切换带来的开销。</li>\n  <li><strong>示例代码</strong>：</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.atomic.AtomicBoolean;\n\npublic class SpinLock {\n    private AtomicBoolean locked = new AtomicBoolean(false);\n\n    public void lock() {\n        while (!locked.compareAndSet(false, true)) {\n            // 自旋等待\n        }\n    }\n\n    public void unlock() {\n        locked.set(false);\n    }\n}\n</code></pre>\n<h3>5. 偏向锁、轻量级锁和重量级锁</h3>\n<ul>\n  <li><strong>特点</strong>：这三种锁是 <code>synchronized</code> 关键字在不同场景下的优化实现。偏向锁适用于单线程环境，当一个线程第一次获取锁时，会将锁对象的头信息设置为偏向该线程，后续该线程再次获取锁时无需进行同步操作；轻量级锁适用于多线程交替执行的场景，通过 CAS 操作来获取锁；重量级锁则是传统的互斥锁，会导致线程阻塞和上下文切换。</li>\n  <li><strong>说明</strong>：这些锁是 JVM 内部实现的，开发者无需手动操作，JVM 会根据实际情况自动进行锁的升级和降级。</li>\n</ul>","type":6,"level":2,"freq":0.007882291,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：除常见锁外，了解哪些Java中的锁。</li>\n  <li><strong>考察点</strong>：对Java中各类锁的知识面广度，包括不常见锁的原理、特点和使用场景。</li>\n</ul>\n<h3>2. 背景知识</h3>\n<ul>\n  <li><strong>常见锁</strong>：如<code>synchronized</code>关键字实现的内置锁、<code>ReentrantLock</code>可重入锁等，这些锁在日常开发中较为常用。</li>\n  <li><strong>其他锁</strong>：Java中还有多种不同特性和用途的锁，用于满足不同的并发编程需求。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）StampedLock</h4>\n<ul>\n  <li><strong>原理</strong>：它是Java 8引入的一种新的锁机制，结合了读写锁和乐观锁的特点。它使用一个戳（stamp）来表示锁的状态，获取锁时会返回一个戳，释放锁时需要传入该戳。</li>\n  <li><strong>特点</strong>：支持三种模式的锁，分别是写锁、悲观读锁和乐观读锁。乐观读锁在读取数据时不会阻塞写操作，能提高并发性能。</li>\n  <li><strong>使用场景</strong>：适用于读多写少的场景，例如缓存系统。</li>\n</ul>\n<h4>（2）ReadWriteLock</h4>\n<ul>\n  <li><strong>原理</strong>：将读操作和写操作分离，允许多个线程同时进行读操作，但写操作是独占的。</li>\n  <li><strong>特点</strong>：读锁和写锁是分离的，读锁可以被多个线程同时持有，写锁只能被一个线程持有。</li>\n  <li><strong>使用场景</strong>：适用于读操作频繁，写操作较少的场景，如数据库的读写操作。</li>\n</ul>\n<h4>（3）Semaphore</h4>\n<ul>\n  <li><strong>原理</strong>：信号量，它维护了一个许可集，线程可以获取许可来执行操作，执行完后释放许可。</li>\n  <li><strong>特点</strong>：可以控制同时访问某个资源的线程数量。</li>\n  <li><strong>使用场景</strong>：用于限制并发访问的线程数量，如数据库连接池。</li>\n</ul>\n<h4>（4）CountDownLatch</h4>\n<ul>\n  <li><strong>原理</strong>：一个同步辅助类，它允许一个或多个线程等待其他线程完成操作。</li>\n  <li><strong>特点</strong>：通过一个计数器来实现，计数器的初始值为线程的数量，每个线程完成操作后计数器减1，当计数器为0时，等待的线程可以继续执行。</li>\n  <li><strong>使用场景</strong>：适用于多个线程并行执行任务，主线程需要等待所有子线程完成后再继续执行的场景。</li>\n</ul>\n<h4>（5）CyclicBarrier</h4>\n<ul>\n  <li><strong>原理</strong>：一个同步辅助类，它允许一组线程相互等待，直到所有线程都到达一个公共的屏障点。</li>\n  <li><strong>特点</strong>：可以重复使用，当所有线程都到达屏障点后，屏障会被重置，可以继续使用。</li>\n  <li><strong>使用场景</strong>：适用于多个线程需要同时开始执行某个任务的场景。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<h4>（1）StampedLock示例</h4>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.StampedLock;\n\npublic class StampedLockExample {\n    private final StampedLock lock = new StampedLock();\n    private int value = 0;\n\n    public int readValue() {\n        long stamp = lock.tryOptimisticRead();\n        int currentValue = value;\n        if (!lock.validate(stamp)) {\n            stamp = lock.readLock();\n            try {\n                currentValue = value;\n            } finally {\n                lock.unlockRead(stamp);\n            }\n        }\n        return currentValue;\n    }\n\n    public void writeValue(int newValue) {\n        long stamp = lock.writeLock();\n        try {\n            value = newValue;\n        } finally {\n            lock.unlockWrite(stamp);\n        }\n    }\n}\n</code></pre>\n<h4>（2）ReadWriteLock示例</h4>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class ReadWriteLockExample {\n    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n    private int value = 0;\n\n    public int readValue() {\n        lock.readLock().lock();\n        try {\n            return value;\n        } finally {\n            lock.readLock().unlock();\n        }\n    }\n\n    public void writeValue(int newValue) {\n        lock.writeLock().lock();\n        try {\n            value = newValue;\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n}\n</code></pre>\n<h4>（3）Semaphore示例</h4>\n<pre><code class=\"language-java\">import java.util.concurrent.Semaphore;\n\npublic class SemaphoreExample {\n    private final Semaphore semaphore = new Semaphore(2);\n\n    public void accessResource() {\n        try {\n            semaphore.acquire();\n            System.out.println(Thread.currentThread().getName() + \" accessed the resource.\");\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            semaphore.release();\n        }\n    }\n}\n</code></pre>\n<h4>（4）CountDownLatch示例</h4>\n<pre><code class=\"language-java\">import java.util.concurrent.CountDownLatch;\n\npublic class CountDownLatchExample {\n    public static void main(String[] args) throws InterruptedException {\n        int threadCount = 3;\n        CountDownLatch latch = new CountDownLatch(threadCount);\n\n        for (int i = 0; i &#x3C; threadCount; i++) {\n            new Thread(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" is working.\");\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    latch.countDown();\n                }\n            }).start();\n        }\n\n        latch.await();\n        System.out.println(\"All threads have finished working.\");\n    }\n}\n</code></pre>\n<h4>（5）CyclicBarrier示例</h4>\n<pre><code class=\"language-java\">import java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\n\npublic class CyclicBarrierExample {\n    public static void main(String[] args) {\n        int threadCount = 3;\n        CyclicBarrier barrier = new CyclicBarrier(threadCount, () -> {\n            System.out.println(\"All threads have reached the barrier.\");\n        });\n\n        for (int i = 0; i &#x3C; threadCount; i++) {\n            new Thread(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" is waiting at the barrier.\");\n                    barrier.await();\n                    System.out.println(Thread.currentThread().getName() + \" has passed the barrier.\");\n                } catch (InterruptedException | BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n    }\n}\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆不同锁的使用场景</h4>\n<ul>\n  <li>误区：不清楚各种锁的特点和适用场景，随意使用锁，导致性能问题或并发问题。</li>\n  <li>纠正：深入理解每种锁的原理和特点，根据具体的业务场景选择合适的锁。</li>\n</ul>\n<h4>（2）忽略锁的释放</h4>\n<ul>\n  <li>误区：在使用锁时，忘记释放锁，导致死锁或资源泄漏。</li>\n  <li>纠正：使用<code>try-finally</code>块确保锁在使用后被释放。</li>\n</ul>\n<h4>（3）过度使用锁</h4>\n<ul>\n  <li>误区：在不需要锁的场景中使用锁，增加了系统的开销。</li>\n  <li>纠正：评估是否真的需要锁，尽量减少锁的使用。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>除常见的锁外，Java中还有以下几种锁：</p>\n<ul>\n  <li><strong>StampedLock</strong>：结合了读写锁和乐观锁的特点，支持写锁、悲观读锁和乐观读锁三种模式，适用于读多写少的场景。</li>\n  <li><strong>ReadWriteLock</strong>：将读操作和写操作分离，允许多个线程同时进行读操作，但写操作是独占的，适用于读操作频繁，写操作较少的场景。</li>\n  <li><strong>Semaphore</strong>：信号量，用于控制同时访问某个资源的线程数量，适用于限制并发访问的线程数量的场景。</li>\n  <li><strong>CountDownLatch</strong>：允许一个或多个线程等待其他线程完成操作，适用于多个线程并行执行任务，主线程需要等待所有子线程完成后再继续执行的场景。</li>\n  <li><strong>CyclicBarrier</strong>：允许一组线程相互等待，直到所有线程都到达一个公共的屏障点，适用于多个线程需要同时开始执行某个任务的场景。</li>\n</ul>\n<p>在使用这些锁时，需要根据具体的业务场景选择合适的锁，并注意锁的释放，避免死锁和资源泄漏。同时，要避免过度使用锁，以提高系统的性能。</p>","more_ask":"<ol>\n  <li>\n    <p>\n      问：在使用这些特殊锁时，如何进行性能调优？\n      提示：从锁的粒度、锁的持有时间、并发度等方面思考。\n    </p>\n  </li>\n  <li>\n    <p>\n      问：这些特殊锁在高并发场景下可能会遇到什么问题，如何解决？\n      提示：考虑死锁、饥饿、性能瓶颈等问题及对应的解决策略。\n    </p>\n  </li>\n  <li>\n    <p>\n      问：请举例说明在实际项目中，你是如何选择合适的特殊锁来解决问题的？\n      提示：结合具体业务场景，如数据一致性要求、并发访问特点等。\n    </p>\n  </li>\n  <li>\n    <p>\n      问：特殊锁与常见锁在实现原理上有哪些本质区别？\n      提示：从锁的底层数据结构、线程调度机制等方面分析。\n    </p>\n  </li>\n  <li>\n    <p>\n      问：如果多个特殊锁嵌套使用，会有什么潜在风险，如何避免？\n      提示：关注死锁、性能下降等风险及避免方法。\n    </p>\n  </li>\n  <li>\n    <p>\n      问：对于可中断锁，在中断时会发生什么，如何正确处理中断？\n      提示：思考锁的释放、线程状态变化及异常处理。\n    </p>\n  </li>\n  <li>\n    <p>\n      问：特殊锁的公平性是如何实现的，公平锁和非公平锁在实际应用中有什么不同？\n      提示：了解公平锁的排队机制，对比不同场景下的使用效果。\n    </p>\n  </li>\n  <li>\n    <p>\n      问：在分布式系统中，这些特殊锁是否还适用，如何进行扩展？\n      提示：考虑分布式环境的特点，如网络延迟、节点故障等。\n    </p>\n  </li>\n</ol>","mindmap":"mindmap\n  root((Java中其他类型的锁))\n    读写锁（ReentrantReadWriteLock）\n      特点：允许多线程读，写时独占，适用于读多写少场景\n    StampedLock\n      特点：Java 8引入，更细粒度控制和更好性能，支持写锁、读锁、乐观读\n    公平锁和非公平锁\n      特点：锁的特性，公平锁按请求顺序分配，非公平锁不保证顺序\n    自旋锁\n      特点：忙等待机制，适用于锁持有时间短场景\n    偏向锁、轻量级锁和重量级锁\n      特点：synchronized不同场景优化实现\n      说明：JVM内部实现，自动升级和降级","keynote":"读写锁（ReentrantReadWriteLock）：允许多线程读，写时独占，读多写少场景适用\nStampedLock：Java 8引入，细粒度控制和高性能，支持写、读、乐观读\n公平锁和非公平锁：锁特性，公平按请求顺序，非公平不保证顺序\n自旋锁：忙等待，适用于锁持有时间短场景\n偏向锁、轻量级锁和重量级锁：synchronized不同场景优化，JVM自动升级降级","group_id":5,"kps":["高级特性"],"years":[2025,2024,2023,2022],"corps":["京东","好未来","快手","同盾科技","成都零一悦动","首约科技","顺丰","平安产险科技中心","小米","荣耀","腾讯","七牛云","美团","华为","OPPO","度小满","途虎养车","滴滴","拼多多","携程","去哪儿旅行","微众银行","旷视科技","神策数据","饿了么","猿辅导","小红书","字节跳动","百度"]}}