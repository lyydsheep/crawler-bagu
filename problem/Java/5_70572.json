{
  "success": true,
  "data": {
    "id": 70572,
    "name": "<p>请说明 ConcurrentHashMap 的扩容机制</p>",
    "options": null,
    "answer": "<p><code>ConcurrentHashMap</code> 是 Java 中线程安全的哈希表实现，在 JDK 8 及以后版本中，其扩容机制相较于之前版本有了较大的改进。下面详细介绍 JDK 8 中 <code>ConcurrentHashMap</code> 的扩容机制。</p>\n<h3>触发扩容的条件</h3>\n<ol>\n  <li><strong>元素数量达到阈值</strong>：当 <code>ConcurrentHashMap</code> 中的元素数量超过阈值（<code>容量 * 负载因子</code>）时，会触发扩容操作。</li>\n  <li><strong>链表长度过长</strong>：当某个链表的长度达到 8 且数组长度小于 64 时，会先尝试进行数组扩容，而不是将链表转换为红黑树。</li>\n  <li><strong>多线程插入时协助扩容</strong>：在多线程环境下，当一个线程在插入元素时发现当前正在进行扩容操作，会协助进行扩容。</li>\n</ol>\n<h3>扩容的具体过程</h3>\n<h4>1. 初始化扩容相关参数</h4>\n<p>当触发扩容时，会创建一个新的数组，其容量是原数组的两倍。同时，会设置一些扩容相关的标志位和计数器，用于协调多线程的扩容操作。</p>\n<h4>2. 迁移节点</h4>\n<p>迁移节点是扩容的核心步骤，<code>ConcurrentHashMap</code> 采用多线程并发迁移的方式，将原数组中的节点迁移到新数组中。具体步骤如下：</p>\n<ul>\n  <li><strong>划分迁移任务</strong>：将原数组划分为多个小的迁移任务，每个任务负责迁移一段连续的数组位置。</li>\n  <li><strong>线程协作</strong>：多个线程可以同时参与迁移任务，每个线程领取一个迁移任务并进行处理。</li>\n  <li><strong>节点迁移</strong>：对于每个迁移任务，会遍历该任务范围内的数组位置，将节点迁移到新数组中。迁移过程中，会根据节点的类型（链表节点或红黑树节点）进行不同的处理。</li>\n</ul>\n<h4>3. 完成扩容</h4>\n<p>当所有节点都迁移完成后，会将新数组替换原数组，完成扩容操作。</p>\n<h3>代码示例及解释</h3>\n<p>以下是一个简单的示例，展示了 <code>ConcurrentHashMap</code> 的扩容过程：</p>\n<pre><code class=\"language-java\">import java.util.concurrent.ConcurrentHashMap;\n\npublic class ConcurrentHashMapResizeExample {\n    public static void main(String[] args) {\n        ConcurrentHashMap&#x3C;Integer, Integer> map = new ConcurrentHashMap&#x3C;>(4, 0.75f);\n\n        // 插入元素，触发扩容\n        for (int i = 0; i &#x3C; 10; i++) {\n            map.put(i, i);\n        }\n\n        System.out.println(\"扩容后容量: \" + map.size());\n    }\n}\n</code></pre>\n<h3>代码解释</h3>\n<ol>\n  <li><strong>创建 <code>ConcurrentHashMap</code></strong>：创建一个初始容量为 4，负载因子为 0.75 的 <code>ConcurrentHashMap</code>。</li>\n  <li><strong>插入元素</strong>：循环插入 10 个元素，由于初始容量为 4，负载因子为 0.75，当插入元素数量超过 3 时，会触发扩容操作。</li>\n  <li><strong>输出扩容后容量</strong>：输出扩容后 <code>ConcurrentHashMap</code> 的容量。</li>\n</ol>\n<h3>源码分析</h3>\n<p>以下是 <code>ConcurrentHashMap</code> 中触发扩容的部分源码：</p>\n<pre><code class=\"language-java\">final V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node&#x3C;K,V>[] tab = table;;) {\n        Node&#x3C;K,V> f; int n, i, fh;\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        else if ((f = tabAt(tab, i = (n - 1) &#x26; hash)) == null) {\n            if (casTabAt(tab, i, null,\n                         new Node&#x3C;K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) {\n                        binCount = 1;\n                        for (Node&#x3C;K,V> e = f;; ++binCount) {\n                            K ek;\n                            if (e.hash == hash &#x26;&#x26;\n                                ((ek = e.key) == key ||\n                                 (ek != null &#x26;&#x26; key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            Node&#x3C;K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node&#x3C;K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    else if (f instanceof TreeBin) {\n                        Node&#x3C;K,V> p;\n                        binCount = 2;\n                        if ((p = ((TreeBin&#x3C;K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                if (binCount >= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n\nprivate final void addCount(long x, int check) {\n    CounterCell[] as; long b, s;\n    if ((as = counterCells) != null ||\n        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {\n        CounterCell a; long v; int m;\n        boolean uncontended = true;\n        if (as == null || (m = as.length - 1) &#x3C; 0 ||\n            (a = as[ThreadLocalRandom.getProbe() &#x26; m]) == null ||\n            !(uncontended =\n              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {\n            fullAddCount(x, uncontended);\n            return;\n        }\n        s = sumCount();\n    }\n    if (check >= 0) {\n        Node&#x3C;K,V>[] tab, nt; int n, sc;\n        while (s >= (long)(sc = sizeCtl) &#x26;&#x26; (tab = table) != null &#x26;&#x26;\n               (n = tab.length) &#x3C; MAXIMUM_CAPACITY) {\n            int rs = resizeStamp(n);\n            if (sc &#x3C; 0) {\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                    transferIndex &#x3C;= 0)\n                    break;\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                    transfer(tab, nt);\n            }\n            else if (U.compareAndSwapInt(this, SIZECTL, sc,\n                                         (rs &#x3C;&#x3C; RESIZE_STAMP_SHIFT) + 2))\n                transfer(tab, null);\n            s = sumCount();\n        }\n    }\n}\n</code></pre>\n<h3>源码解释</h3>\n<ul>\n  <li><code>putVal</code> 方法：插入元素的核心方法，当插入元素时，如果发现当前正在进行扩容操作（<code>fh == MOVED</code>），会调用 <code>helpTransfer</code> 方法协助扩容。</li>\n  <li><code>addCount</code> 方法：用于更新元素数量，并检查是否需要进行扩容。当元素数量超过阈值时，会调用 <code>transfer</code> 方法进行扩容操作。</li>\n</ul>\n<h3>总结</h3>\n<p><code>ConcurrentHashMap</code> 的扩容机制采用了多线程并发迁移的方式，提高了扩容的效率。在扩容过程中，通过设置标志位和计数器，协调多个线程的操作，确保扩容操作的线程安全。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.0008779631,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：说明 ConcurrentHashMap 的扩容机制。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对 ConcurrentHashMap 数据结构的理解。</li>\n      <li>触发扩容的条件。</li>\n      <li>扩容的具体过程。</li>\n      <li>多线程参与扩容的机制。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）ConcurrentHashMap 简介</h4>\n<p>ConcurrentHashMap 是 Java 中线程安全的哈希表实现，用于在多线程环境下高效地进行并发操作。它采用分段锁或 CAS（Compare - And - Swap）等机制来保证线程安全。</p>\n<h4>（2）哈希表结构</h4>\n<p>ConcurrentHashMap 底层基于数组 + 链表 + 红黑树实现。数组中的每个位置称为一个桶（bucket），当多个元素的哈希值映射到同一个桶时，会以链表或红黑树的形式存储。</p>\n<h3>3. 解析</h3>\n<h4>（1）触发扩容的条件</h4>\n<ul>\n  <li><strong>元素数量达到阈值</strong>：当 ConcurrentHashMap 中的元素数量超过阈值（容量 * 负载因子）时，会触发扩容操作。负载因子默认为 0.75。</li>\n  <li><strong>链表过长</strong>：当某个桶中的链表长度超过 8 且数组长度大于 64 时，链表会转换为红黑树。如果在扩容时，红黑树节点数量小于 6，红黑树会转换回链表。</li>\n  <li><strong>多线程插入</strong>：当一个线程在插入元素时发现当前正在进行扩容操作，会协助进行扩容。</li>\n</ul>\n<h4>（2）扩容的具体过程</h4>\n<ul>\n  <li><strong>创建新数组</strong>：扩容时会创建一个容量为原数组两倍的新数组。</li>\n  <li><strong>数据迁移</strong>：将原数组中的元素迁移到新数组中。迁移过程中，会根据元素的哈希值重新计算其在新数组中的位置。</li>\n</ul>\n<h4>（3）多线程参与扩容的机制</h4>\n<ul>\n  <li><strong>ForwardingNode 节点</strong>：在扩容过程中，会在原数组的每个桶位置放置一个 ForwardingNode 节点。该节点的哈希值为 -1，表示该桶正在进行迁移。</li>\n  <li><strong>协助迁移</strong>：当其他线程插入元素时，如果发现某个桶是 ForwardingNode 节点，说明该桶正在迁移，线程会协助进行迁移操作。</li>\n  <li><strong>迁移任务分配</strong>：每个线程会分配一段连续的桶区间进行迁移，通过 CAS 操作来保证线程安全。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">import java.util.concurrent.ConcurrentHashMap;\n\npublic class ConcurrentHashMapExample {\n    public static void main(String[] args) {\n        ConcurrentHashMap&#x3C;String, Integer> map = new ConcurrentHashMap&#x3C;>();\n        for (int i = 0; i &#x3C; 1000; i++) {\n            map.put(String.valueOf(i), i);\n        }\n    }\n}\n</code></pre>\n<p>在上述代码中，当元素数量不断增加，达到阈值时，ConcurrentHashMap 会触发扩容操作。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）认为扩容是单线程操作</h4>\n<ul>\n  <li>误区：认为 ConcurrentHashMap 的扩容和普通哈希表一样，是单线程操作。</li>\n  <li>纠正：ConcurrentHashMap 的扩容是多线程协作完成的，多个线程可以同时参与数据迁移，提高了扩容效率。</li>\n</ul>\n<h4>（2）忽略 ForwardingNode 节点的作用</h4>\n<ul>\n  <li>误区：不清楚 ForwardingNode 节点在扩容中的作用。</li>\n  <li>纠正：ForwardingNode 节点用于标记该桶正在进行迁移，其他线程遇到该节点时会协助迁移。</li>\n</ul>\n<h4>（3）不理解扩容时的数据迁移规则</h4>\n<ul>\n  <li>误区：不明白元素在扩容时如何重新计算位置。</li>\n  <li>纠正：元素在扩容时会根据其哈希值重新计算在新数组中的位置，通常是通过哈希值与新数组长度进行按位与运算。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>ConcurrentHashMap 的扩容机制是为了在元素数量增加时保持高效的性能。触发扩容的条件主要有元素数量达到阈值、链表过长以及多线程插入时发现正在扩容。</p>\n<p>扩容时，会创建一个容量为原数组两倍的新数组，然后将原数组中的元素迁移到新数组中。在迁移过程中，会使用 ForwardingNode 节点标记正在迁移的桶。多个线程可以同时参与扩容，每个线程会分配一段连续的桶区间进行迁移，通过 CAS 操作保证线程安全。</p>\n<p>需要注意的是，ConcurrentHashMap 的扩容是多线程协作完成的，这与普通哈希表的单线程扩容不同。同时，要理解 ForwardingNode 节点的作用以及元素在扩容时的迁移规则。</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      <strong>扩容时如何保证线程安全？</strong>\n      提示：思考ConcurrentHashMap在扩容过程中使用了哪些锁机制和原子操作来避免多线程冲突。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>扩容过程中，其他线程对ConcurrentHashMap进行读写操作会怎样？</strong>\n      提示：分别考虑读操作和写操作，结合ConcurrentHashMap的分段锁和数据迁移机制分析。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>扩容阈值是如何确定的，为什么这样设计？</strong>\n      提示：了解ConcurrentHashMap中负载因子和容量的关系，思考这样设计对性能和空间的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>扩容时数据迁移的具体步骤是怎样的？</strong>\n      提示：关注数据从旧数组迁移到新数组的过程，包括如何定位元素、如何处理链表和红黑树。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如果扩容过程中发生异常，会有什么影响，如何处理？</strong>\n      提示：考虑异常对数据一致性和线程安全的影响，以及ConcurrentHashMap的恢复机制。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>ConcurrentHashMap的扩容和HashMap的扩容有什么区别？</strong>\n      提示：从线程安全、扩容机制、数据迁移等方面进行对比。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>扩容时如何处理哈希冲突？</strong>\n      提示：结合ConcurrentHashMap的链表和红黑树结构，分析在扩容过程中哈希冲突的处理方式。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>扩容对ConcurrentHashMap的性能有什么影响？</strong>\n      提示：考虑扩容过程中的锁竞争、数据迁移开销等因素对读写性能的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>ConcurrentHashMap在什么情况下会触发多次扩容？</strong>\n      提示：思考ConcurrentHashMap的使用场景和数据变化情况，分析多次扩容的触发条件。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>扩容时如何保证数据的有序性（如果有要求）？</strong>\n      提示：如果需要保证数据有序，考虑ConcurrentHashMap的结构和扩容机制如何满足这一要求。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((JDK 8中ConcurrentHashMap的扩容机制))\n    触发扩容的条件\n      元素数量达到阈值\n      链表长度过长\n      多线程插入时协助扩容\n    扩容的具体过程\n      初始化扩容相关参数\n      迁移节点\n        划分迁移任务\n        线程协作\n        节点迁移\n      完成扩容\n    代码示例及解释\n      创建ConcurrentHashMap\n      插入元素\n      输出扩容后容量\n    源码分析\n      putVal方法\n      addCount方法\n    总结\n      多线程并发迁移\n      线程安全",
    "keynote": "触发扩容条件：元素数量超阈值、链表长且数组短、多线程插入协助\n扩容过程：初始化参数、迁移节点（划分任务、线程协作、节点迁移）、完成扩容\n代码示例：创建、插入元素触发扩容、输出容量\n源码：putVal协助扩容，addCount检查扩容\n总结：多线程并发迁移，保证线程安全",
    "group_id": 5,
    "kps": [
      "多线程",
      "高级特性",
      "集合框架"
    ],
    "years": [
      2024,
      2023,
      2022
    ],
    "corps": [
      "腾讯",
      "阿里巴巴",
      "快手",
      "贝壳"
    ]
  }
}