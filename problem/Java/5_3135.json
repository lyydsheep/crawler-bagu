{
  "success": true,
  "data": {
    "id": 3135,
    "name": "<p>为什么重写 equals() 就一定要重写 hashCode() 方法？</p>",
    "options": null,
    "answer": "<p>在 Java 中，当你重写 <code>equals()</code> 方法时，必然要重写 <code>hashCode()</code> 方法，原因涉及到 Java 的集合框架，特别是使用基于哈希的集合（像 <code>HashSet</code>、<code>HashMap</code>）中的对象存储和查找。</p>\n<h3>原因解析</h3>\n<ol>\n  <li>\n    <p>\n      <strong>合同规定</strong>：\n      根据 <code>Object</code> 类的约定，如果两个对象通过 <code>equals()</code> 方法被认为是相等的（即 <code>a.equals(b)</code> 返回 <code>true</code>），那么这两个对象的 <code>hashCode()</code> 方法必须返回相同的整数值。这是 Java 的一个重要原则，称为“hashCode 合同”。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>哈希表的工作机制</strong>：\n      哈希表通过将对象的哈希值映射到数组的索引来存储对象。当你将对象存入 <code>HashMap</code> 或 <code>HashSet</code> 时，集合会使用 <code>hashCode()</code> 方法来确定对象的位置。因此，如果两个对象被视为相等（即 <code>equals()</code> 返回 <code>true</code>），它们必须有相同的哈希值，这样才能在集合中被正确处理。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>避免逻辑错误</strong>：\n      如果你只重写 <code>equals()</code> 而不重写 <code>hashCode()</code>，可能会导致严重的问题。例如，将一个对象放入 <code>HashSet</code> 后，如果你改变了该对象的某些字段并根据这些字段重写了 <code>equals()</code>，但没有更新 <code>hashCode()</code>，那么你可能会无法正确找到这个对象，因为它的哈希值与哈希表中的索引不再对应。\n    </p>\n  </li>\n</ol>\n<h3>示例</h3>\n<p>考虑以下简单示例：</p>\n<pre><code class=\"language-java\">public class Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (!(obj instanceof Person)) return false;\n        Person other = (Person) obj;\n        return name.equals(other.name) &#x26;&#x26; age == other.age;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n}\n</code></pre>\n<h3>总结</h3>\n<p>如果你重写了 <code>equals()</code>，你需要确保 <code>hashCode()</code> 方法的一致性，以遵循 Java 的集合框架规律，保证对象在集合中能被正确存取。这将有助于避免潜在的错误和异常行为。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.001580334,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：在 Java 中，为什么重写 equals() 就一定要重写 hashCode() 方法？</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对 Java 中 equals() 方法和 hashCode() 方法的理解。</li>\n      <li>哈希表（如 HashMap、HashSet）的工作原理。</li>\n      <li>equals() 方法和 hashCode() 方法的契约关系。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）equals() 方法</h4>\n<ul>\n  <li>equals() 方法用于比较两个对象是否相等。在 Object 类中，equals() 方法比较的是两个对象的引用是否相等，即是否指向同一个内存地址。但很多类会重写 equals() 方法来实现逻辑上的相等比较，比如比较对象的属性值。</li>\n</ul>\n<h4>（2）hashCode() 方法</h4>\n<ul>\n  <li>hashCode() 方法返回对象的哈希码，这是一个 int 类型的整数。哈希码的主要作用是在哈希表中快速查找对象。在 Object 类中，hashCode() 方法返回的是对象的内存地址经过某种转换后的整数值。</li>\n</ul>\n<h4>（3）哈希表的工作原理</h4>\n<ul>\n  <li>哈希表（如 HashMap、HashSet）使用哈希码来确定对象在表中的存储位置。当向哈希表中插入一个对象时，首先计算对象的哈希码，然后根据哈希码找到对应的存储桶，再在该存储桶中查找或插入对象。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）equals() 和 hashCode() 的契约关系</h4>\n<ul>\n  <li>Java 规定，如果两个对象通过 equals() 方法比较相等，那么它们的 hashCode() 方法返回值必须相等。如果只重写 equals() 方法而不重写 hashCode() 方法，就会违反这个契约。</li>\n</ul>\n<h4>（2）不重写 hashCode() 可能导致的问题</h4>\n<ul>\n  <li><strong>哈希表无法正常工作</strong>：在使用哈希表时，哈希表首先根据对象的哈希码来确定存储位置。如果两个对象通过 equals() 方法比较相等，但它们的哈希码不同，那么它们可能会被存储在不同的存储桶中。这样，当使用 equals() 方法认为相等的对象去查找时，可能会找不到该对象，导致哈希表的功能失效。</li>\n</ul>\n<h4>（3）重写 hashCode() 的作用</h4>\n<ul>\n  <li>确保相等的对象具有相同的哈希码，从而保证哈希表能够正常工作。当两个对象通过 equals() 方法比较相等时，它们的哈希码相同，会被存储在同一个存储桶中，这样在查找时就能正确找到该对象。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">import java.util.HashMap;\nimport java.util.Map;\n\nclass Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // 重写 equals() 方法\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass()!= o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age &#x26;&#x26; name.equals(person.name);\n    }\n\n    // 未重写 hashCode() 方法\n\n    public static void main(String[] args) {\n        Person p1 = new Person(\"Alice\", 20);\n        Person p2 = new Person(\"Alice\", 20);\n\n        Map&#x3C;Person, String> map = new HashMap&#x3C;>();\n        map.put(p1, \"Value\");\n\n        // 虽然 p1 和 p2 通过 equals() 方法比较相等，但由于没有重写 hashCode() 方法，可能无法正确获取值\n        System.out.println(map.get(p2)); // 可能输出 null\n    }\n}\n</code></pre>\n<ul>\n  <li>在这个例子中，<code>Person</code> 类重写了 equals() 方法，但没有重写 hashCode() 方法。当使用 <code>p1</code> 作为键插入到 <code>HashMap</code> 中，然后使用 <code>p2</code> 作为键去获取值时，由于 <code>p1</code> 和 <code>p2</code> 的哈希码不同，可能无法正确获取到值。</li>\n</ul>\n<h3>5. 常见误区</h3>\n<h4>（1）认为不重写 hashCode() 也没关系</h4>\n<ul>\n  <li>误区：觉得只重写 equals() 方法就能实现对象的相等比较，忽略了哈希表的工作原理。</li>\n  <li>纠正：在使用哈希表时，必须保证 equals() 和 hashCode() 方法的一致性，否则会导致哈希表无法正常工作。</li>\n</ul>\n<h4>（2）随意重写 hashCode() 方法</h4>\n<ul>\n  <li>误区：重写 hashCode() 方法时没有考虑 equals() 方法的逻辑，导致相等的对象哈希码不同。</li>\n  <li>纠正：重写 hashCode() 方法时，要根据 equals() 方法中比较的属性来计算哈希码，确保相等的对象具有相同的哈希码。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“在 Java 中，重写 equals() 方法就一定要重写 hashCode() 方法，这是因为 Java 规定，如果两个对象通过 equals() 方法比较相等，那么它们的 hashCode() 方法返回值必须相等。哈希表（如 HashMap、HashSet）依赖对象的哈希码来确定存储位置，如果只重写 equals() 方法而不重写 hashCode() 方法，可能会导致相等的对象具有不同的哈希码，从而被存储在不同的存储桶中，使得哈希表无法正常工作。</p>\n<p>例如，当我们使用重写了 equals() 方法但未重写 hashCode() 方法的对象作为键插入到哈希表中，再使用另一个与之相等的对象去查找时，可能无法找到该对象。因此，为了保证哈希表的正常功能，当重写 equals() 方法时，必须同时重写 hashCode() 方法，确保相等的对象具有相同的哈希码。”</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>请解释 hashMap 是如何利用 hashCode() 和 equals() 的？</strong></p>\n    <ul>\n      <li>提示：考虑哈希表的存储机制和冲突解决策略。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如果只重写了 equals() 而没有重写 hashCode()，会导致什么问题？</strong></p>\n    <ul>\n      <li>提示：想一下对象存储在集合中的表现和查找的结果。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在重写 equals() 和 hashCode() 时，有哪些最佳实践？</strong></p>\n    <ul>\n      <li>提示：考虑 null 值、对象字段的使用和一致性。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>可以给出一个简单的代码示例，展示如何重写 equals() 和 hashCode() 吗？</strong></p>\n    <ul>\n      <li>提示：包括基本的字段比较和哈希值计算。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在 Java 中，默认的 equals() 和 hashCode() 是如何工作的？</strong></p>\n    <ul>\n      <li>提示：考虑对象的内存地址比较和类层级。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>为什么在集合中使用不当的 equals() 和 hashCode() 会导致问题？</strong></p>\n    <ul>\n      <li>提示：思考元素的唯一性和查找性能。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何确保 hashCode() 的分散性，以优化哈希表性能？</strong></p>\n    <ul>\n      <li>提示：考虑散列函数的设计和分布原则。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如果一个类的属性在生命周期内会改变，如何处理 equals() 和 hashCode()？</strong></p>\n    <ul>\n      <li>提示：思考对可变对象的设计策略。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在实现 equals() 时，使用 instanceof 检查有什么优缺点？</strong></p>\n    <ul>\n      <li>提示：考虑类型安全和强制类型转换的可能性。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在比较两个对象时，严格相等（identity）和逻辑相等（equality）有什么区别？</strong></p>\n  </li>\n</ol>\n<ul>\n  <li>提示：思考对象的不同上下文和需求。</li>\n</ul>",
    "mindmap": "mindmap\n  重写equals与hashCode\n    合同规定\n    哈希表的工作机制\n    避免逻辑错误\n    示例\n    总结",
    "keynote": "- 当重写`equals()`方法时，必须同时重写`hashCode()`方法。\n- 如果两个对象通过`equals()`被认为是相等的，则它们的`hashCode()`值也必须相同。\n- `hashCode()`用于哈希表中确定对象的位置；相等的对象需有相同的哈希码以确保正确存储和检索。\n- 只重写`equals()`而不重写`hashCode()`可能导致集合中的查找问题或逻辑错误。\n- 使用`Objects.hash()`可以方便地基于对象的一个或多个字段生成哈希码。",
    "group_id": 5,
    "kps": [
      "面向对象编程",
      "Java API与常用库"
    ],
    "years": [
      2024,
      2023,
      2022
    ],
    "corps": [
      "凡拓数创",
      "美团",
      "纷享销客",
      "百度",
      "同程旅行",
      "爱奇艺"
    ]
  }
}