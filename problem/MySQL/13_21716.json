{
  "success": true,
  "data": {
    "id": 21716,
    "name": "<p>MySQL索引like在什么时候会失效</p>",
    "options": null,
    "answer": "<p>在MySQL中，LIKE语句使用不当会导致索引失效，以下是几种常见情况：</p>\n<h3>以通配符开头</h3>\n<p>当LIKE语句以通配符（如<code>%</code>）开头时，索引通常会失效。例如：</p>\n<pre><code class=\"language-sql\">SELECT * FROM users WHERE name LIKE '%John';\n</code></pre>\n<p>在这个查询中，由于<code>%</code>在<code>John</code>前面，MySQL无法利用<code>name</code>列上的索引进行快速查找。因为索引是按照索引列的值进行排序存储的，以<code>%</code>开头意味着要从索引的任意位置开始匹配，无法通过索引的有序性快速定位数据，只能进行全表扫描。</p>\n<h3>函数操作</h3>\n<p>如果对LIKE语句中的索引列使用了函数，索引会失效。例如：</p>\n<pre><code class=\"language-sql\">SELECT * FROM users WHERE UPPER(name) LIKE 'JOHN%';\n</code></pre>\n<p>这里对<code>name</code>列使用了<code>UPPER</code>函数，MySQL无法直接使用<code>name</code>列上的索引。因为索引是基于原始列值构建的，函数的使用改变了索引列的原始值，使得MySQL无法通过索引快速定位符合条件的数据，从而进行全表扫描。</p>\n<h3>隐式类型转换</h3>\n<p>当LIKE语句中索引列存在隐式类型转换时，索引会失效。例如，<code>id</code>列是<code>INT</code>类型，但在查询时使用了字符串类型进行LIKE匹配：</p>\n<pre><code class=\"language-sql\">SELECT * FROM users WHERE id LIKE '123%';\n</code></pre>\n<p>由于<code>id</code>列是整数类型，而查询中使用了字符串类型进行匹配，MySQL会进行隐式类型转换，将<code>id</code>列的值转换为字符串类型。这种转换会导致索引无法正常使用，只能进行全表扫描。</p>\n<h3>复合索引未遵循最左前缀原则</h3>\n<p>如果使用的是复合索引，而LIKE查询没有遵循最左前缀原则，索引可能会失效。例如，有一个复合索引<code>(first_name, last_name)</code>，查询如下：</p>\n<pre><code class=\"language-sql\">SELECT * FROM users WHERE last_name LIKE 'Smith%';\n</code></pre>\n<p>由于没有使用复合索引的最左列<code>first_name</code>，MySQL无法利用这个复合索引进行快速查找，可能会导致索引失效，进行全表扫描。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.0004917629,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：MySQL索引like在什么时候会失效。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对MySQL索引原理的理解。</li>\n      <li>对like语句使用规则的掌握。</li>\n      <li>了解影响索引使用的因素。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）MySQL索引原理</h4>\n<p>MySQL索引是一种数据结构，用于提高数据库查询的效率。常见的索引类型有B树索引、哈希索引等。索引通过对数据进行排序和组织，使得数据库可以快速定位到符合查询条件的数据。</p>\n<h4>（2）like语句作用</h4>\n<p>like语句用于在查询中进行模糊匹配，通常使用通配符<code>%</code>（表示任意多个字符）和<code>_</code>（表示单个字符）。</p>\n<h3>3. 解析</h3>\n<h4>（1）以通配符开头的like查询</h4>\n<p>\n  当like语句以<code>%</code>开头时，索引会失效。因为索引是有序的数据结构，以<code>%</code>开头的查询无法利用索引的有序性来快速定位数据，数据库需要扫描全量数据来进行匹配。\n  例如：\n</p>\n<pre><code class=\"language-sql\">SELECT * FROM users WHERE name LIKE '%John';\n</code></pre>\n<p>在这个查询中，由于<code>%</code>在开头，无法使用<code>name</code>字段上的索引。</p>\n<h4>（2）使用函数处理索引列</h4>\n<p>\n  如果在like语句中对索引列使用了函数，索引会失效。因为函数的使用会改变索引列的值，使得数据库无法直接使用索引进行查找。\n  例如：\n</p>\n<pre><code class=\"language-sql\">SELECT * FROM users WHERE UPPER(name) LIKE 'JOHN%';\n</code></pre>\n<p>这里对<code>name</code>字段使用了<code>UPPER</code>函数，导致<code>name</code>字段上的索引无法使用。</p>\n<h4>（3）类型不匹配</h4>\n<p>\n  如果查询条件中的数据类型与索引列的数据类型不匹配，索引可能会失效。MySQL在进行比较时会进行隐式类型转换，这可能会导致索引无法正常使用。\n  例如，索引列<code>id</code>是整数类型，但查询时使用字符串类型：\n</p>\n<pre><code class=\"language-sql\">SELECT * FROM users WHERE id LIKE '123%';\n</code></pre>\n<p>由于隐式类型转换，<code>id</code>字段上的索引可能无法生效。</p>\n<h4>（4）复合索引使用不当</h4>\n<p>\n  对于复合索引，如果like查询没有从复合索引的最左列开始，索引会失效。复合索引的使用遵循最左前缀原则，即必须从最左边的列开始依次使用。\n  例如，有复合索引<code>(name, age)</code>，以下查询会导致索引失效：\n</p>\n<pre><code class=\"language-sql\">SELECT * FROM users WHERE age LIKE '20%';\n</code></pre>\n<p>因为没有从<code>name</code>列开始使用复合索引。</p>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-sql\">-- 创建测试表\nCREATE TABLE users (\n    id INT PRIMARY KEY,\n    name VARCHAR(50),\n    age INT\n);\n\n-- 创建索引\nCREATE INDEX idx_name ON users (name);\nCREATE INDEX idx_name_age ON users (name, age);\n\n-- 以通配符开头，索引失效\nEXPLAIN SELECT * FROM users WHERE name LIKE '%John';\n\n-- 使用函数处理索引列，索引失效\nEXPLAIN SELECT * FROM users WHERE UPPER(name) LIKE 'JOHN%';\n\n-- 类型不匹配，索引可能失效\nEXPLAIN SELECT * FROM users WHERE id LIKE '123%';\n\n-- 复合索引使用不当，索引失效\nEXPLAIN SELECT * FROM users WHERE age LIKE '20%';\n</code></pre>\n<p>通过<code>EXPLAIN</code>关键字可以查看查询的执行计划，判断索引是否被使用。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）认为like查询都能使用索引</h4>\n<p>\n  误区：认为只要有索引，like查询就一定能使用索引。\n  纠正：以<code>%</code>开头的like查询、对索引列使用函数、类型不匹配以及复合索引使用不当等情况会导致索引失效。\n</p>\n<h4>（2）忽视复合索引的最左前缀原则</h4>\n<p>\n  误区：在使用复合索引时，不考虑最左前缀原则，随意使用索引列进行查询。\n  纠正：复合索引必须从最左边的列开始依次使用，否则索引会失效。\n</p>\n<h3>6. 总结回答</h3>\n<p>“MySQL索引like在以下几种情况下会失效：</p>\n<ol>\n  <li>当like语句以通配符<code>%</code>开头时，无法利用索引的有序性，数据库需要全量扫描数据，导致索引失效。</li>\n  <li>如果在like语句中对索引列使用了函数，函数会改变索引列的值，使得数据库无法直接使用索引进行查找。</li>\n  <li>查询条件中的数据类型与索引列的数据类型不匹配，MySQL进行隐式类型转换时可能导致索引无法正常使用。</li>\n  <li>对于复合索引，若like查询没有从复合索引的最左列开始，不满足最左前缀原则，索引会失效。</li>\n</ol>\n<p>在编写SQL查询时，应尽量避免上述情况，以提高查询效率。例如，尽量避免以<code>%</code>开头的like查询，确保查询条件的数据类型与索引列一致，合理使用复合索引等。”</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      除了<code>like</code>，MySQL 中还有哪些常见的索引失效场景？\n      提示：从 SQL 语句的使用、数据类型等方面去思考。\n    </p>\n  </li>\n  <li>\n    <p>\n      当<code>like</code>索引失效后，如何优化查询性能？\n      提示：可以从 SQL 语句改写、索引调整等角度考虑。\n    </p>\n  </li>\n  <li>\n    <p>\n      对于复合索引，<code>like</code>查询在什么情况下会部分使用索引，什么情况下完全不使用？\n      提示：结合复合索引的顺序和<code>like</code>查询的条件分析。\n    </p>\n  </li>\n  <li>\n    <p>\n      在不同的存储引擎（如 InnoDB、MyISAM）中，<code>like</code>索引失效的情况会有差异吗？\n      提示：考虑不同存储引擎的索引结构和特性。\n    </p>\n  </li>\n  <li>\n    <p>\n      当表数据量非常大时，<code>like</code>索引失效对查询性能的影响会有怎样的变化？\n      提示：从查询时间、资源消耗等方面去分析。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((MySQL中LIKE语句导致索引失效的常见情况))\n    以通配符开头\n      通配符在前无法利用索引有序性\n      只能全表扫描\n    函数操作\n      函数改变索引列原始值\n      无法通过索引定位数据\n      全表扫描\n    隐式类型转换\n      索引列类型与查询类型不匹配\n      隐式转换导致索引无法使用\n      全表扫描\n    复合索引未遵循最左前缀原则\n      未用复合索引最左列\n      无法利用复合索引\n      可能全表扫描",
    "keynote": "- 以通配符开头：通配符在前，无法利用索引有序性，全表扫描\n- 函数操作：函数改变索引列原始值，无法定位数据，全表扫描\n- 隐式类型转换：索引列与查询类型不匹配，隐式转换使索引无法用，全表扫描\n- 复合索引未遵循最左前缀原则：未用最左列，无法利用复合索引，可能全表扫描",
    "group_id": 13,
    "kps": [
      "索引与查询优化"
    ],
    "years": [
      2024
    ],
    "corps": [
      "数字马力",
      "卓望"
    ]
  }
}