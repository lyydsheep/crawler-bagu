{
  "success": true,
  "data": {
    "id": 5491,
    "name": "<p>数据库悲观锁和乐观锁介绍一下？</p>",
    "options": null,
    "answer": "<p>在MySQL中，悲观锁和乐观锁是两种控制并发的策略，用于保证数据的一致性和完整性。它们各自有不同的应用场景和实现方式。</p>\n<h3>悲观锁</h3>\n<p><strong>定义</strong>: 悲观锁是一种认为冲突会经常发生的策略。在读取或修改数据之前，系统会先对数据加锁，以防止其他事务同时访问。</p>\n<p><strong>实现方式</strong>:</p>\n<ul>\n  <li><strong>SELECT ... FOR UPDATE</strong>: 在查询时对结果集中的行加锁，防止其他事务修改。</li>\n  <li><strong>LOCK IN SHARE MODE</strong>: 读取数据时加共享锁，允许其他事务读但不允许写。</li>\n</ul>\n<p><strong>优点</strong>:</p>\n<ul>\n  <li>数据一致性高，避免了脏读、不可重复读和幻读等问题。</li>\n  <li>适用于高冲突的场景，如银行转账。</li>\n</ul>\n<p><strong>缺点</strong>:</p>\n<ul>\n  <li>性能开销大，锁的竞争可能导致低并发。</li>\n  <li>长时间持锁可能会造成死锁。</li>\n</ul>\n<h3>乐观锁</h3>\n<p><strong>定义</strong>: 乐观锁是一种认为冲突不常发生的策略。它在修改数据时先不加锁，而是在提交时验证数据是否被其他事务修改过。</p>\n<p><strong>实现方式</strong>:</p>\n<ul>\n  <li><strong>版本号</strong>: 数据表中增加一个版本号字段，每次修改时验证版本号。</li>\n  <li><strong>时间戳</strong>: 使用时间戳字段来记录数据最后修改的时间，提交时检查。</li>\n</ul>\n<p><strong>优点</strong>:</p>\n<ul>\n  <li>性能通常较好，适合读多写少的场景。</li>\n  <li>不会持有锁，降低了死锁的风险。</li>\n</ul>\n<p><strong>缺点</strong>:</p>\n<ul>\n  <li>如果频繁出现冲突，事务就需要重试，可能导致一定的性能损失。</li>\n  <li>不能完全避免脏读、不可重复读和幻读问题，需要结合其他措施。</li>\n</ul>\n<h3>何时选择哪种锁？</h3>\n<ul>\n  <li>\n    <p><strong>悲观锁</strong>: 适用于对数据一致性要求非常高的场景、频繁的并发写操作，以及对性能要求不太高的情况。</p>\n  </li>\n  <li>\n    <p><strong>乐观锁</strong>: 适用于读多写少且冲突较少的场景，可以保证性能和响应时间。</p>\n  </li>\n</ul>\n<p>在实际应用中，选择哪种锁机制还要结合具体的业务需求和系统架构来决定。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.009097615,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：介绍数据库悲观锁和乐观锁。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对悲观锁和乐观锁概念的理解。</li>\n      <li>两种锁的使用场景。</li>\n      <li>两种锁的实现方式。</li>\n      <li>两种锁的优缺点。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<ul>\n  <li><strong>锁的概念</strong>：在数据库中，锁是用于控制并发访问的机制，确保在多个事务同时访问数据时数据的一致性和完整性。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）悲观锁</h4>\n<ul>\n  <li><strong>概念</strong>：悲观锁的核心思想是“先取锁再访问”，它总是假设最坏的情况，认为在对数据进行操作时，一定会有其他事务来修改数据，所以在操作数据前先加锁，防止其他事务同时访问和修改。</li>\n  <li><strong>实现方式</strong>：在 MySQL 中，常用的实现方式是使用<code>SELECT... FOR UPDATE</code>语句。例如：</li>\n</ul>\n<pre><code class=\"language-sql\">START TRANSACTION;\nSELECT * FROM table_name WHERE condition FOR UPDATE;\n-- 进行数据操作\nCOMMIT;\n</code></pre>\n<p>在事务中使用<code>FOR UPDATE</code>，会对查询结果集中的记录加排他锁，其他事务只能等待该事务提交或回滚后才能对这些记录进行操作。</p>\n<ul>\n  <li><strong>使用场景</strong>：适用于并发竞争激烈、对数据一致性要求高的场景，如库存管理、金融交易等。因为这些场景一旦数据被错误修改，会造成严重的后果。</li>\n  <li><strong>优点</strong>：可以保证数据的强一致性，避免了并发修改带来的数据冲突问题。</li>\n  <li><strong>缺点</strong>：加锁会影响系统的并发性能，因为其他事务需要等待锁的释放，可能会导致大量的阻塞和死锁问题。</li>\n</ul>\n<h4>（2）乐观锁</h4>\n<ul>\n  <li><strong>概念</strong>：乐观锁的核心思想是“先访问再判断”，它假设在大多数情况下，不会有其他事务同时修改数据，所以在操作数据时不会加锁，而是在更新数据时检查数据是否被其他事务修改过。</li>\n  <li><strong>实现方式</strong>：常见的实现方式是使用版本号机制或时间戳机制。以版本号机制为例，在表中添加一个<code>version</code>字段，每次更新数据时，先查询出数据的版本号，然后在更新语句中判断版本号是否和查询时一致，如果一致则更新数据并将版本号加 1。示例如下：</li>\n</ul>\n<pre><code class=\"language-sql\">-- 查询数据及版本号\nSELECT id, data, version FROM table_name WHERE condition;\n-- 更新数据并检查版本号\nUPDATE table_name SET data = new_data, version = version + 1 WHERE id = id_value AND version = old_version;\n</code></pre>\n<ul>\n  <li><strong>使用场景</strong>：适用于并发竞争相对较小、冲突概率较低的场景，如商品评论、文章点赞等。这些场景对数据一致性的要求相对较低，允许一定程度的并发修改。</li>\n  <li><strong>优点</strong>：不会对数据加锁，提高了系统的并发性能，减少了事务之间的等待时间。</li>\n  <li><strong>缺点</strong>：如果并发冲突频繁，可能会导致大量的更新失败，需要进行重试操作，增加了系统的开销。</li>\n</ul>\n<h3>4. 常见误区</h3>\n<h4>（1）混淆两种锁的适用场景</h4>\n<ul>\n  <li>误区：在并发竞争小的场景使用悲观锁，或者在并发竞争激烈的场景使用乐观锁。</li>\n  <li>纠正：应根据实际的业务场景和并发情况选择合适的锁机制。</li>\n</ul>\n<h4>（2）对实现方式理解错误</h4>\n<ul>\n  <li>误区：错误地认为乐观锁不需要任何机制来保证数据一致性。</li>\n  <li>纠正：乐观锁需要使用版本号或时间戳等机制来检查数据是否被修改。</li>\n</ul>\n<h3>5. 总结回答</h3>\n<p>“数据库中的悲观锁和乐观锁是两种不同的并发控制机制。</p>\n<p>悲观锁总是假设会有其他事务来修改数据，在操作数据前先加锁。在 MySQL 中常用<code>SELECT... FOR UPDATE</code>来实现，它能保证数据的强一致性，适用于并发竞争激烈、对数据一致性要求高的场景，如库存管理、金融交易等。但它会影响系统的并发性能，可能导致大量的阻塞和死锁问题。</p>\n<p>乐观锁假设大多数情况下不会有其他事务同时修改数据，操作数据时不加锁，在更新数据时检查数据是否被修改过，常见的实现方式是使用版本号或时间戳机制。它提高了系统的并发性能，适用于并发竞争相对较小、冲突概率较低的场景，如商品评论、文章点赞等。不过，如果并发冲突频繁，可能会导致大量的更新失败，需要进行重试操作，增加系统开销。”</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>你能举例说明在什么场景下应该使用悲观锁和乐观锁吗？</strong><br>提示：考虑资源争用和事务的特性。</p>\n  </li>\n  <li>\n    <p><strong>如何实现悲观锁和乐观锁？请分别描述。</strong><br>提示：关注具体的数据库操作和代码实现。</p>\n  </li>\n  <li>\n    <p><strong>悲观锁和乐观锁对性能有什么影响？</strong><br>提示：分析锁的开销以及并发性能。</p>\n  </li>\n  <li>\n    <p><strong>在高并发情况下，乐观锁如何处理冲突？</strong><br>提示：探讨版本控制或时间戳的使用。</p>\n  </li>\n  <li>\n    <p><strong>你认为在什么情况下乐观锁可能失败？如何处理这些失败？</strong><br>提示：讨论重试机制或业务逻辑的调整。</p>\n  </li>\n  <li>\n    <p><strong>如果使用了乐观锁，如何设计系统以减少冲突的可能性？</strong><br>提示：考虑数据访问模式和业务流程。</p>\n  </li>\n  <li>\n    <p><strong>在分布式系统中，如何实现锁机制？</strong><br>提示：讨论使用Zookeeper、Redis等组件的情况。</p>\n  </li>\n  <li>\n    <p><strong>除了悲观锁和乐观锁，还有哪些其他策略可以控制并发？</strong><br>提示：思考行级锁、表级锁等其它机制。</p>\n  </li>\n  <li>\n    <p><strong>在使用乐观锁时，如何保证操作的一致性？</strong><br>提示：关注事务隔离级别和确保数据完整性。</p>\n  </li>\n  <li>\n    <p><strong>你能讲述一下MySQL的具体实现机制吗，比如InnoDB存储引擎中的锁策略？</strong><br>提示：关注行级锁和表级锁的实现细节。</p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((并发控制策略))\n    悲观锁\n      定义\n      实现方式\n        SELECT ... FOR UPDATE\n        LOCK IN SHARE MODE\n      优点\n        数据一致性高\n        适用于高冲突场景\n      缺点\n        性能开销大\n        可能造成死锁\n    乐观锁\n      定义\n      实现方式\n        版本号\n        时间戳\n      优点\n        性能较好\n        降低死锁风险\n      缺点\n        频繁冲突需重试\n        不能完全避免读问题\n    选择依据\n      悲观锁适用情况\n      乐观锁适用情况",
    "keynote": "- 悲观锁假设冲突频繁，修改前加锁。\n- 悲观锁通过`SELECT ... FOR UPDATE`和`LOCK IN SHARE MODE`实现。\n- 悲观锁保证数据一致性但性能开销大。\n- 乐观锁假设冲突不常发生，提交时验证。\n- 乐观锁使用版本号或时间戳机制实现。\n- 乐观锁提高性能并减少死锁，但可能需要事务重试。\n- 根据业务需求选择合适的锁机制。",
    "group_id": 13,
    "kps": [
      "事务与并发控制"
    ],
    "years": [
      2024,
      2023,
      2022
    ],
    "corps": [
      "保融科技",
      "Shopee虾皮",
      "元戎启行",
      "阿里巴巴",
      "网易",
      "小米",
      "小黑盒",
      "云智研发",
      "科大讯飞",
      "GE医疗外包公司,GEHC",
      "字节跳动",
      "腾讯",
      "美团优选",
      "阿里菜鸟",
      "快手",
      "OPPO",
      "满帮集团",
      "滴滴",
      "蚂蚁集团",
      "B站",
      "用友",
      "小红书",
      "微众银行",
      "同盾科技",
      "货拉拉",
      "百度",
      "字节懂车帝",
      "美团"
    ]
  }
}