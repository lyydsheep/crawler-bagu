{
  "success": true,
  "data": {
    "id": 5486,
    "name": "<p>什么是不可重复读？</p>",
    "options": null,
    "answer": "<p>在 MySQL 中，不可重复读（Non-repeatable read）是一种可能在事务处理中出现的并发控制问题。它指的是在同一个事务中，对同一个数据行的多次读取可能会返回不同的结果。这种现象通常发生在事务的隔离级别较低的情况下，比如读已提交（Read Committed）或未提交读（Read Uncommitted）。</p>\n<h3>举个例子：</h3>\n<p>假设有两个事务，事务 A 和事务 B：</p>\n<ol>\n  <li><strong>事务 A</strong> 开始并读取了一行数据（例如，读取用户的账户余额）。</li>\n  <li><strong>事务 B</strong> 开始并对同一行数据进行了更新（例如，修改该用户的账户余额）。</li>\n  <li><strong>事务 A</strong> 再次读取同一行数据，这次得到的余额可能与第一次读取时的结果不同。</li>\n</ol>\n<h3>解决方案：</h3>\n<p>为了避免不可重复读，可以将数据库的隔离级别提升到可重复读（Repeatable Read）或串行化（Serializable）。在可重复读级别下，事务 A 即使在多次读取相同数据时，也会获得一致的结果，因为事务的所有操作都是基于第一次读取时的数据快照。</p>\n<h3>结论：</h3>\n<p>不可重复读是一种常见的并发问题，它可能导致数据的不一致性。在设计数据库应用时，尤其是在涉及事务的场景中，需要仔细选择隔离级别以平衡并发性和数据一致性。</p>",
    "type": 6,
    "level": 2,
    "freq": 0.0002458815,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：什么是不可重复读。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对数据库事务隔离级别的理解。</li>\n      <li>对不可重复读概念的掌握。</li>\n      <li>不可重复读现象产生的原因和影响。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）数据库事务</h4>\n<p>数据库事务是一组不可分割的数据库操作序列，这些操作要么全部执行成功，要么全部失败回滚。事务具有原子性、一致性、隔离性和持久性（ACID特性）。</p>\n<h4>（2）事务隔离级别</h4>\n<p>不同的事务隔离级别决定了一个事务对其他事务的可见性和相互影响程度。常见的事务隔离级别有读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。</p>\n<h3>3. 解析</h3>\n<h4>（1）不可重复读的定义</h4>\n<p>不可重复读是数据库事务中的一种现象，它发生在一个事务内多次读取同一数据时，由于其他事务对该数据进行了更新操作并提交，导致该事务在不同时间读取到的数据不一致。</p>\n<h4>（2）产生原因</h4>\n<p>不可重复读主要是因为事务的隔离级别设置较低，例如在“读已提交”隔离级别下，一个事务只能读取到其他事务已经提交的数据。当一个事务在执行过程中，另一个事务对其正在读取的数据进行了更新并提交，那么该事务再次读取相同数据时，就会得到不同的结果。</p>\n<h4>（3）影响</h4>\n<p>不可重复读可能会导致业务逻辑出现错误，因为同一个事务内的数据读取结果不一致，可能会使依赖这些数据进行的计算、判断等操作产生不符合预期的结果。</p>\n<h4>（4）解决方法</h4>\n<p>可以通过提高事务的隔离级别来解决不可重复读问题。例如，将隔离级别设置为“可重复读”，在该隔离级别下，一个事务在执行期间多次读取同一数据时，会保证读取到的数据是一致的，即使其他事务对该数据进行了更新操作，也要等到当前事务提交后才会生效。</p>\n<h3>4. 示例场景</h3>\n<p>假设有两个事务T1和T2，数据库中有一张表<code>users</code>，其中有一条记录<code>(1, 'Alice', 20)</code>，表示用户ID为1，姓名为Alice，年龄为20。</p>\n<ul>\n  <li>事务T1开始，执行<code>SELECT age FROM users WHERE id = 1;</code>，得到结果20。</li>\n  <li>事务T2开始，执行<code>UPDATE users SET age = 21 WHERE id = 1;</code>并提交。</li>\n  <li>事务T1再次执行<code>SELECT age FROM users WHERE id = 1;</code>，如果此时事务T1的隔离级别是“读已提交”，则会得到结果21，这就出现了不可重复读的现象。</li>\n</ul>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆不可重复读和脏读</h4>\n<ul>\n  <li>误区：将不可重复读和脏读的概念混淆，认为都是读取到了不一致的数据。</li>\n  <li>纠正：脏读是指一个事务读取到了另一个未提交事务修改的数据，而不可重复读是指一个事务在多次读取同一数据时，由于其他已提交事务的更新操作导致读取结果不一致。</li>\n</ul>\n<h4>（2）认为不可重复读总是有害的</h4>\n<ul>\n  <li>误区：认为不可重复读一定会导致业务逻辑错误，必须完全避免。</li>\n  <li>纠正：在某些对数据实时性要求较高，而对数据一致性要求相对较低的场景下，不可重复读可能是可以接受的，因为它可以提高并发性能。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>不可重复读是数据库事务中的一种现象，指在一个事务内多次读取同一数据时，由于其他事务对该数据进行了更新操作并提交，导致该事务在不同时间读取到的数据不一致。</p>\n<p>它通常发生在较低的事务隔离级别下，如“读已提交”。不可重复读可能会影响业务逻辑的正确性，但在一些对数据实时性要求较高的场景下是可以接受的。为了避免不可重复读，可以将事务隔离级别提高到“可重复读”，以保证一个事务在执行期间多次读取同一数据时结果一致。</p>",
    "more_ask": "<p>面试官可能会进一步问：</p>\n<ol>\n  <li>\n    <p><strong>可重复读和幻读的区别是什么？</strong></p>\n    <ul>\n      <li>提示：请解释两个概念，并给出示例。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在MySQL中，如何通过事务隔离级别来解决不可重复读的问题？</strong></p>\n    <ul>\n      <li>提示：提到事务隔离级别的等级以及如何设置。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>你能举一个实际的场景示例，说明不可重复读会导致什么问题吗？</strong></p>\n    <ul>\n      <li>提示：考虑在电商或者银行交易中的潜在影响。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如何使用行级锁来避免不可重复读？</strong></p>\n    <ul>\n      <li>提示：讨论锁的机制和应用场景。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在你的项目中，你是如何处理可重复读的事务的？</strong></p>\n    <ul>\n      <li>提示：分享个人经历或使用的策略。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>如果采用快照读（Snapshot Read），是否可以解决不可重复读？请说明理由。</strong></p>\n    <ul>\n      <li>提示：讨论快照读的实现原理。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在分布式数据库环境中，如何处理不可重复读问题？</strong></p>\n    <ul>\n      <li>提示：考虑一致性和事务管理的挑战。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>可以通过什么手段来监控和诊断不可重复读的发生？</strong></p>\n    <ul>\n      <li>提示：可以考虑如Slow Query Log、性能监控工具等。</li>\n    </ul>\n  </li>\n  <li>\n    <p><strong>在高并发场景下，如何优化数据库操作以避免不可重复读？</strong></p>\n    <ul>\n      <li>提示：讨论可能的策略，如读写分离或缓存机制。</li>\n    </ul>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((不可重复读))\n    定义\n      在同一事务中多次读取可能不同\n      发生在较低隔离级别\n        读已提交\n        未提交读\n    例子\n      事务A首次读取\n      事务B更新数据\n      事务A再次读取结果不同\n    解决方案\n      提升隔离级别\n        可重复读\n        串行化\n    结论\n      导致数据不一致\n      需要平衡并发与一致性",
    "keynote": "- 不可重复读指在同一事务内对相同数据的多次读取返回不同结果。\n- 通常发生在较低隔离级别，如读已提交或未提交读。\n- 通过提升到可重复读或串行化隔离级别来解决。\n- 不可重复读可能导致数据不一致性，在设计应用时需考虑隔离级别的选择。",
    "group_id": 13,
    "kps": [
      "事务与并发控制"
    ],
    "years": [
      2023
    ],
    "corps": [
      "快手"
    ]
  }
}