{
  "success": true,
  "data": {
    "id": 54142,
    "name": "<p>请说明spring boot用到了哪些设计模式，从源码层面说说熟悉的以及实现</p>",
    "options": null,
    "answer": "<p>Spring Boot 框架在设计和实现过程中运用了多种设计模式，下面从源码层面介绍几种常见的设计模式及其实现。</p>\n<h3>1. 单例模式</h3>\n<ul>\n  <li><strong>说明</strong>：单例模式确保一个类只有一个实例，并提供一个全局访问点。在 Spring Boot 中，默认情况下，Spring 容器中的 Bean 都是单例的。</li>\n  <li><strong>源码实现</strong>：在 Spring 的 <code>DefaultSingletonBeanRegistry</code> 类中，维护了一个 <code>singletonObjects</code> 缓存，用于存储单例 Bean 的实例。当需要获取 Bean 时，首先会检查该缓存中是否已经存在该 Bean 的实例，如果存在则直接返回，否则创建新的实例并放入缓存中。</li>\n</ul>\n<pre><code class=\"language-java\">// DefaultSingletonBeanRegistry 类中的部分代码\nprivate final Map&#x3C;String, Object> singletonObjects = new ConcurrentHashMap&#x3C;>(256);\n\npublic Object getSingleton(String beanName) {\n    return getSingleton(beanName, true);\n}\n\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null &#x26;&#x26; isSingletonCurrentlyInCreation(beanName)) {\n        // 处理正在创建中的单例 Bean\n    }\n    return singletonObject;\n}\n</code></pre>\n<h3>2. 工厂模式</h3>\n<ul>\n  <li><strong>说明</strong>：工厂模式定义了一个创建对象的接口，让子类决定实例化哪个类。Spring Boot 中的 <code>BeanFactory</code> 就是工厂模式的典型应用，它负责创建和管理 Bean 实例。</li>\n  <li><strong>源码实现</strong>：<code>AbstractBeanFactory</code> 是 <code>BeanFactory</code> 的一个抽象实现，其中的 <code>doGetBean</code> 方法负责创建和获取 Bean 实例。</li>\n</ul>\n<pre><code class=\"language-java\">// AbstractBeanFactory 类中的部分代码\nprotected &#x3C;T> T doGetBean(\n        String name, @Nullable Class&#x3C;T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)\n        throws BeansException {\n\n    String beanName = transformedBeanName(name);\n    Object sharedInstance = getSingleton(beanName);\n\n    if (sharedInstance != null &#x26;&#x26; args == null) {\n        // 从单例缓存中获取 Bean\n    } else {\n        // 创建新的 Bean 实例\n        if (mbd.isSingleton()) {\n            sharedInstance = getSingleton(beanName, () -> {\n                try {\n                    return createBean(beanName, mbd, args);\n                } catch (BeansException ex) {\n                    // 处理异常\n                }\n            });\n        } else if (mbd.isPrototype()) {\n            // 处理原型 Bean\n        } else {\n            // 处理其他作用域的 Bean\n        }\n    }\n    return (T) bean;\n}\n</code></pre>\n<h3>3. 代理模式</h3>\n<ul>\n  <li><strong>说明</strong>：代理模式为其他对象提供一种代理以控制对这个对象的访问。Spring Boot 中的 AOP（面向切面编程）就是基于代理模式实现的，通过代理对象在目标方法执行前后插入额外的逻辑。</li>\n  <li><strong>源码实现</strong>：Spring AOP 主要有两种代理方式：JDK 动态代理和 CGLIB 代理。以 JDK 动态代理为例，<code>JdkDynamicAopProxy</code> 类实现了 <code>InvocationHandler</code> 接口，在 <code>invoke</code> 方法中实现了代理逻辑。</li>\n</ul>\n<pre><code class=\"language-java\">// JdkDynamicAopProxy 类中的部分代码\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    MethodInvocation invocation;\n    Object oldProxy = null;\n    boolean setProxyContext = false;\n\n    TargetSource targetSource = this.advised.targetSource;\n    Object target = null;\n\n    try {\n        if (!this.equalsDefined &#x26;&#x26; AopUtils.isEqualsMethod(method)) {\n            // 处理 equals 方法\n        } else if (!this.hashCodeDefined &#x26;&#x26; AopUtils.isHashCodeMethod(method)) {\n            // 处理 hashCode 方法\n        } else if (method.getDeclaringClass() == DecoratingProxy.class) {\n            // 处理 DecoratingProxy 接口方法\n        } else if (!this.advised.opaque &#x26;&#x26; method.getDeclaringClass().isInterface() &#x26;&#x26;\n                method.getDeclaringClass().isAssignableFrom(Advised.class)) {\n            // 处理 Advised 接口方法\n        }\n\n        Object retVal;\n\n        if (this.advised.exposeProxy) {\n            // 暴露代理对象\n        }\n\n        target = targetSource.getTarget();\n        Class&#x3C;?> targetClass = (target != null ? target.getClass() : null);\n\n        // 创建方法调用对象\n        invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n\n        // 执行方法调用\n        retVal = invocation.proceed();\n\n        // 处理返回值\n        return retVal;\n    } finally {\n        if (target != null &#x26;&#x26; !targetSource.isStatic()) {\n            // 释放目标对象\n        }\n    }\n}\n</code></pre>\n<h3>4. 观察者模式</h3>\n<ul>\n  <li><strong>说明</strong>：观察者模式定义了对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新。Spring Boot 中的事件机制就是基于观察者模式实现的。</li>\n  <li><strong>源码实现</strong>：<code>ApplicationEventPublisher</code> 是事件发布者，<code>ApplicationListener</code> 是事件监听器。当事件发布时，<code>SimpleApplicationEventMulticaster</code> 会将事件通知给所有注册的监听器。</li>\n</ul>\n<pre><code class=\"language-java\">// SimpleApplicationEventMulticaster 类中的部分代码\npublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {\n    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));\n    Executor executor = getTaskExecutor();\n    for (ApplicationListener&#x3C;?> listener : getApplicationListeners(event, type)) {\n        if (executor != null) {\n            executor.execute(() -> invokeListener(listener, event));\n        } else {\n            invokeListener(listener, event);\n        }\n    }\n}\n\nprotected void invokeListener(ApplicationListener&#x3C;?> listener, ApplicationEvent event) {\n    ErrorHandler errorHandler = getErrorHandler();\n    if (errorHandler != null) {\n        try {\n            doInvokeListener(listener, event);\n        } catch (Throwable err) {\n            errorHandler.handleError(err);\n        }\n    } else {\n        doInvokeListener(listener, event);\n    }\n}\n\nprivate void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {\n    try {\n        listener.onApplicationEvent(event);\n    } catch (ClassCastException ex) {\n        // 处理异常\n    }\n}\n</code></pre>\n<h3>5. 策略模式</h3>\n<ul>\n  <li><strong>说明</strong>：策略模式定义了一系列的算法，并将每个算法封装起来，使它们可以相互替换。Spring Boot 中的 <code>PropertySourceLoader</code> 就是策略模式的应用，不同的 <code>PropertySourceLoader</code> 实现类负责加载不同格式的配置文件。</li>\n  <li><strong>源码实现</strong>：<code>PropertiesPropertySourceLoader</code> 负责加载 <code>.properties</code> 文件，<code>YamlPropertySourceLoader</code> 负责加载 <code>.yaml</code> 文件。在 <code>ConfigFileApplicationListener</code> 中，根据文件的扩展名选择合适的 <code>PropertySourceLoader</code> 来加载配置文件。</li>\n</ul>\n<pre><code class=\"language-java\">// ConfigFileApplicationListener 类中的部分代码\nprivate List&#x3C;PropertySourceLoader> getPropertySourceLoaders() {\n    return SpringFactoriesLoader.loadFactories(PropertySourceLoader.class, getClass().getClassLoader());\n}\n\nprivate void loadIntoGroup(String location, DocumentFilterFactory filterFactory,\n        DocumentConsumer consumer) {\n    for (PropertySourceLoader loader : getPropertySourceLoaders()) {\n        if (canLoadFileExtension(loader, location)) {\n            try {\n                Resource resource = this.resourceLoader.getResource(location);\n                List&#x3C;PropertySource&#x3C;?>> propertySources = loader.load(location, resource);\n                if (propertySources != null) {\n                    for (PropertySource&#x3C;?> propertySource : propertySources) {\n                        consumer.accept(filterFactory.getDocumentFilter(), propertySource);\n                    }\n                }\n            } catch (Exception ex) {\n                // 处理异常\n            }\n        }\n    }\n}\n</code></pre>",
    "type": 6,
    "level": 2,
    "freq": 0.008010681,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：说明Spring Boot用到的设计模式，从源码层面阐述熟悉的设计模式及其实现。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Spring Boot框架的深入理解。</li>\n      <li>对常见设计模式的掌握。</li>\n      <li>从源码角度分析设计模式在Spring Boot中的应用。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）设计模式概述</h4>\n<p>设计模式是软件开发中针对反复出现问题总结归纳出的通用解决方案，常见的有单例模式、工厂模式、代理模式等。</p>\n<h4>（2）Spring Boot框架</h4>\n<p>Spring Boot是基于Spring框架的快速开发框架，简化了Spring应用的开发配置，其源码中广泛运用了各种设计模式来实现功能和提高可维护性。</p>\n<h3>3. 解析</h3>\n<h4>（1）单例模式</h4>\n<ul>\n  <li><strong>作用</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li>\n  <li><strong>源码实现</strong>：在Spring Boot中，默认情况下，Bean的作用域是单例的。例如，在<code>DefaultSingletonBeanRegistry</code>类中，有一个<code>singletonObjects</code>的<code>Map</code>用于存储单例Bean。</li>\n</ul>\n<pre><code class=\"language-java\">private final Map&#x3C;String, Object> singletonObjects = new ConcurrentHashMap&#x3C;>(256);\n</code></pre>\n<p>当需要获取一个Bean时，会先从这个<code>Map</code>中查找，如果存在则直接返回，不存在则创建并放入<code>Map</code>中。</p>\n<pre><code class=\"language-java\">protected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null &#x26;&#x26; isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null &#x26;&#x26; allowEarlyReference) {\n                ObjectFactory&#x3C;?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    singletonObject = singletonFactory.getObject();\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return singletonObject;\n}\n</code></pre>\n<h4>（2）工厂模式</h4>\n<ul>\n  <li><strong>作用</strong>：定义一个创建对象的接口，让子类决定实例化哪个类。</li>\n  <li><strong>源码实现</strong>：Spring Boot中的<code>BeanFactory</code>就是工厂模式的典型应用。<code>DefaultListableBeanFactory</code>是<code>BeanFactory</code>的一个具体实现类，它负责创建和管理Bean。</li>\n</ul>\n<pre><code class=\"language-java\">public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory\n        implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {\n\n    @Override\n    public &#x3C;T> T getBean(Class&#x3C;T> requiredType) throws BeansException {\n        return getBean(requiredType, (Object[]) null);\n    }\n\n    // 其他方法...\n}\n</code></pre>\n<p>通过<code>getBean</code>方法可以根据类型或名称获取对应的Bean实例，具体的创建过程由<code>BeanFactory</code>内部实现。</p>\n<h4>（3）代理模式</h4>\n<ul>\n  <li><strong>作用</strong>：为其他对象提供一种代理以控制对这个对象的访问。</li>\n  <li><strong>源码实现</strong>：Spring Boot的AOP（面向切面编程）功能使用了代理模式。在<code>ProxyFactory</code>类中，根据不同的情况创建代理对象。</li>\n</ul>\n<pre><code class=\"language-java\">public class ProxyFactory extends ProxyCreatorSupport {\n\n    public Object getProxy() {\n        return createAopProxy().getProxy();\n    }\n\n    // 其他方法...\n}\n</code></pre>\n<p>当需要对某个Bean进行增强时，会创建一个代理对象，代理对象会在调用目标方法前后执行额外的逻辑，如日志记录、事务管理等。</p>\n<h3>4. 常见误区</h3>\n<h4>（1）对设计模式概念理解不准确</h4>\n<ul>\n  <li>误区：将设计模式的概念混淆，不能准确区分不同设计模式的特点和应用场景。</li>\n  <li>纠正：深入学习设计模式的定义和原理，通过实际例子加深理解。</li>\n</ul>\n<h4>（2）只知道设计模式名称，不了解源码实现</h4>\n<ul>\n  <li>误区：仅能说出Spring Boot中用到的设计模式名称，但无法从源码层面解释其实现。</li>\n  <li>纠正：阅读Spring Boot的源码，结合设计模式的原理进行分析，理解设计模式在框架中的具体应用。</li>\n</ul>\n<h4>（3）忽略设计模式的作用</h4>\n<ul>\n  <li>误区：只关注设计模式的实现，而忽略了它们在Spring Boot中所起到的作用和优势。</li>\n  <li>纠正：在学习设计模式时，思考它们如何提高框架的可维护性、可扩展性和灵活性。</li>\n</ul>\n<h3>5. 总结回答</h3>\n<p>Spring Boot中用到了多种设计模式，以下从源码层面介绍几种常见的设计模式及其实现：</p>\n<ul>\n  <li><strong>单例模式</strong>：Spring Boot默认情况下Bean的作用域是单例的。在<code>DefaultSingletonBeanRegistry</code>类中，通过<code>singletonObjects</code>的<code>Map</code>存储单例Bean，获取Bean时先从该<code>Map</code>查找，若存在则直接返回，不存在则创建并放入<code>Map</code>，确保一个类只有一个实例。</li>\n  <li><strong>工厂模式</strong>：<code>BeanFactory</code>是工厂模式的典型应用，<code>DefaultListableBeanFactory</code>作为具体实现类，通过<code>getBean</code>方法根据类型或名称获取对应的Bean实例，负责创建和管理Bean。</li>\n  <li><strong>代理模式</strong>：Spring Boot的AOP功能使用了代理模式。<code>ProxyFactory</code>类根据不同情况创建代理对象，代理对象在调用目标方法前后执行额外逻辑，实现对目标对象的增强。</li>\n</ul>\n<p>在学习和使用Spring Boot时，要准确理解设计模式的概念，深入阅读源码了解其实现，同时关注设计模式对框架性能和可维护性的提升。</p>",
    "more_ask": "<h3>1. 具体设计模式的应用细节</h3>\n<ul>\n  <li><strong>问题</strong>：在Spring Boot的自动配置模块里，工厂方法模式是如何具体实现的，能结合源码详细说说吗？\n    <ul>\n      <li><strong>提示</strong>：可以从<code>AutoConfigurationImportSelector</code>类入手，查看它如何根据不同条件选择不同的自动配置类，这类似于工厂根据不同参数创建不同对象。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 设计模式的组合使用</h3>\n<ul>\n  <li><strong>问题</strong>：Spring Boot中是否存在多种设计模式组合使用的场景，能举例说明并分析其优势吗？\n    <ul>\n      <li><strong>提示</strong>：思考在Spring Boot的启动流程或者某个核心功能模块中，是否有多种设计模式协同工作，比如单例模式和策略模式结合。</li>\n    </ul>\n  </li>\n</ul>\n<h3>3. 设计模式对性能的影响</h3>\n<ul>\n  <li><strong>问题</strong>：Spring Boot里使用的设计模式对系统性能有什么影响，以你熟悉的一种设计模式为例说明。\n    <ul>\n      <li><strong>提示</strong>：以单例模式为例，分析其减少对象创建开销对性能的提升，同时考虑多线程环境下的同步问题对性能的影响。</li>\n    </ul>\n  </li>\n</ul>\n<h3>4. 设计模式的扩展性</h3>\n<ul>\n  <li><strong>问题</strong>：从源码角度看，Spring Boot中使用的设计模式是如何支持系统扩展性的，以某个设计模式为例阐述。\n    <ul>\n      <li><strong>提示</strong>：以观察者模式为例，查看Spring Boot中事件监听机制的源码，分析如何通过添加新的监听器来扩展系统功能。</li>\n    </ul>\n  </li>\n</ul>\n<h3>5. 设计模式的替换方案</h3>\n<ul>\n  <li><strong>问题</strong>：对于Spring Boot中使用的某个设计模式，是否有其他设计模式可以替代，替换后会有什么优缺点？\n    <ul>\n      <li><strong>提示</strong>：比如对于Spring Boot中使用的代理模式，考虑是否可以用装饰器模式替代，分析两种模式的差异和替换后的影响。</li>\n    </ul>\n  </li>\n</ul>\n<h3>6. 设计模式在不同版本的变化</h3>\n<ul>\n  <li><strong>问题</strong>：Spring Boot不同版本中，某些设计模式的实现有什么变化，这种变化带来了什么影响？\n    <ul>\n      <li><strong>提示</strong>：查看Spring Boot 1.x和2.x版本中自动配置模块的源码，对比工厂方法模式的实现差异。</li>\n    </ul>\n  </li>\n</ul>",
    "mindmap": "mindmap\n  root((Spring Boot常见设计模式及源码实现))\n    单例模式\n      说明\n      源码实现\n    工厂模式\n      说明\n      源码实现\n    代理模式\n      说明\n      源码实现\n    观察者模式\n      说明\n      源码实现\n    策略模式\n      说明\n      源码实现",
    "keynote": "单例模式：确保类只有一个实例并提供全局访问点，Spring容器中Bean默认单例，`DefaultSingletonBeanRegistry`用`singletonObjects`缓存存储单例Bean\n工厂模式：定义创建对象接口，让子类决定实例化类，`BeanFactory`是典型应用，`AbstractBeanFactory`的`doGetBean`方法创建和获取Bean\n代理模式：为对象提供代理控制访问，Spring AOP基于此实现，有JDK动态和CGLIB代理，`JdkDynamicAopProxy`实现代理逻辑\n观察者模式：定义对象一对多依赖，状态改变通知依赖对象，Spring Boot事件机制基于此，`ApplicationEventPublisher`发布，`ApplicationListener`监听\n策略模式：封装算法可相互替换，`PropertySourceLoader`应用此模式，不同实现类加载不同格式配置文件",
    "group_id": 7,
    "kps": [
      "基础知识"
    ],
    "years": [
      2024,
      2023
    ],
    "corps": [
      "华为"
    ]
  }
}