{
  "success": true,
  "data": {
    "id": 15739,
    "name": "<p>Spring Boot常用的注解有哪些</p>",
    "options": null,
    "answer": "<p>Spring Boot 中有许多常用的注解，以下为你详细介绍：</p>\n<h3>项目启动类相关注解</h3>\n<ul>\n  <li><strong>@SpringBootApplication</strong>：这是一个组合注解，包含了 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。<code>@SpringBootConfiguration</code> 本质上就是 <code>@Configuration</code>，用于定义配置类；<code>@EnableAutoConfiguration</code> 能让 Spring Boot 根据类路径中的依赖自动配置 Spring 应用程序上下文；<code>@ComponentScan</code> 会自动扫描指定包及其子包下的组件。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre>\n<h3>依赖注入相关注解</h3>\n<ul>\n  <li><strong>@Autowired</strong>：Spring 框架提供的注解，用于自动装配 Bean。它可以作用在构造函数、字段、方法上。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserService {\n    private UserRepository userRepository;\n\n    @Autowired\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>@Qualifier</strong>：当有多个相同类型的 Bean 时，<code>@Qualifier</code> 可以和 <code>@Autowired</code> 配合使用，通过指定 Bean 的名称来明确要注入的 Bean。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserService {\n    @Autowired\n    @Qualifier(\"userRepositoryImpl\")\n    private UserRepository userRepository;\n}\n</code></pre>\n<ul>\n  <li><strong>@Resource</strong>：JSR-250 规范提供的注解，也用于依赖注入。它默认按照名称进行注入，如果找不到名称匹配的 Bean，则按照类型进行注入。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import javax.annotation.Resource;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserService {\n    @Resource\n    private UserRepository userRepository;\n}\n</code></pre>\n<h3>组件定义相关注解</h3>\n<ul>\n  <li><strong>@Component</strong>：这是一个通用的组件注解，用于将一个类标记为 Spring 组件，让 Spring 自动扫描并将其注册为 Bean。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.stereotype.Component;\n\n@Component\npublic class MyComponent {\n    // 类的具体实现\n}\n</code></pre>\n<ul>\n  <li><strong>@Service</strong>：通常用于标记业务逻辑层的类，是 <code>@Component</code> 的特殊化，语义上更明确表示这是一个服务类。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.stereotype.Service;\n\n@Service\npublic class UserService {\n    // 业务逻辑方法\n}\n</code></pre>\n<ul>\n  <li><strong>@Repository</strong>：一般用于标记数据访问层的类，同样是 <code>@Component</code> 的特殊化，用于将数据访问对象（DAO）注册为 Bean，还能将特定的数据库异常转换为 Spring 的统一异常体系。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.stereotype.Repository;\n\n@Repository\npublic class UserRepository {\n    // 数据访问方法\n}\n</code></pre>\n<ul>\n  <li><strong>@Controller</strong>：用于标记控制器类，处理 HTTP 请求。它也是 <code>@Component</code> 的特殊化。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class UserController {\n    @GetMapping(\"/hello\")\n    @ResponseBody\n    public String hello() {\n        return \"Hello, World!\";\n    }\n}\n</code></pre>\n<h3>配置相关注解</h3>\n<ul>\n  <li><strong>@Configuration</strong>：用于定义配置类，相当于传统的 XML 配置文件。配置类中可以使用 <code>@Bean</code> 注解来定义 Bean。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n    @Bean\n    public MyBean myBean() {\n        return new MyBean();\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>@Bean</strong>：用于在配置类中定义 Bean，将方法的返回值注册到 Spring 容器中。示例代码如上。</li>\n  <li><strong>@PropertySource</strong>：用于加载外部属性文件，将属性文件中的配置加载到 Spring 环境中。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.PropertySource;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@PropertySource(\"classpath:application.properties\")\npublic class AppConfig {\n    // 配置类的具体实现\n}\n</code></pre>\n<ul>\n  <li><strong>@Value</strong>：用于从配置文件中获取属性值并注入到字段中。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class MyComponent {\n    @Value(\"${my.property}\")\n    private String myProperty;\n}\n</code></pre>\n<h3>切面编程相关注解</h3>\n<ul>\n  <li><strong>@Aspect</strong>：用于标记一个类为切面类，该类中可以定义切点和通知。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class LoggingAspect {\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceMethods() {}\n\n    @Before(\"serviceMethods()\")\n    public void beforeServiceMethod() {\n        System.out.println(\"Before service method execution\");\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>@Before</strong>、<strong>@After</strong>、<strong>@Around</strong>、<strong>@AfterReturning</strong>、<strong>@AfterThrowing</strong>：这些注解用于定义不同类型的通知，分别表示在目标方法执行前、执行后、环绕执行、正常返回后、抛出异常后执行相应的逻辑。示例代码如上。</li>\n</ul>\n<h3>Web 开发相关注解</h3>\n<ul>\n  <li><strong>@RestController</strong>：是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的组合注解，用于创建 RESTful 风格的控制器，返回的结果会直接作为 HTTP 响应体。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class UserController {\n    @GetMapping(\"/users\")\n    public String getUsers() {\n        return \"List of users\";\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>@RequestMapping</strong>：用于映射 HTTP 请求到控制器的处理方法，可以指定请求的路径、请求方法等。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/api\")\npublic class ApiController {\n    @RequestMapping(value = \"/hello\", method = RequestMethod.GET)\n    public String hello() {\n        return \"Hello, API!\";\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>@GetMapping</strong>、<strong>@PostMapping</strong>、<strong>@PutMapping</strong>、<strong>@DeleteMapping</strong>：这些是 <code>@RequestMapping</code> 的简化注解，分别对应 HTTP 的 GET、POST、PUT、DELETE 请求方法。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.web.bind.annotation.DeleteMapping;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.PutMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n    @GetMapping\n    public String getUsers() {\n        return \"List of users\";\n    }\n\n    @PostMapping\n    public String createUser() {\n        return \"User created\";\n    }\n\n    @PutMapping\n    public String updateUser() {\n        return \"User updated\";\n    }\n\n    @DeleteMapping\n    public String deleteUser() {\n        return \"User deleted\";\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>@RequestBody</strong>：用于将 HTTP 请求的主体部分绑定到方法的参数上，通常用于处理 JSON 或 XML 格式的数据。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n    @PostMapping\n    public String createUser(@RequestBody User user) {\n        // 处理用户创建逻辑\n        return \"User created\";\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>@PathVariable</strong>：用于从 URL 路径中获取变量值，并绑定到方法的参数上。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n    @GetMapping(\"/{id}\")\n    public String getUser(@PathVariable Long id) {\n        return \"User with id: \" + id;\n    }\n}\n</code></pre>\n<ul>\n  <li><strong>@RequestParam</strong>：用于从 HTTP 请求的参数中获取值，并绑定到方法的参数上。示例代码如下：</li>\n</ul>\n<pre><code class=\"language-java\">import org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n    @GetMapping\n    public String getUsers(@RequestParam(required = false) String name) {\n        if (name != null) {\n            return \"Users with name: \" + name;\n        }\n        return \"All users\";\n    }\n}\n</code></pre>",
    "type": 6,
    "level": 1,
    "freq": 0.105474,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Spring Boot常用的注解有哪些。</li>\n  <li><strong>考察点</strong>：对Spring Boot框架中常用注解的了解，包括注解的功能、使用场景。</li>\n</ul>\n<h3>2. 背景知识</h3>\n<p>Spring Boot是基于Spring框架的快速开发框架，注解在Spring Boot中起到了简化配置、实现特定功能的重要作用。通过使用注解，开发者可以减少大量的XML配置，提高开发效率。</p>\n<h3>3. 解析</h3>\n<h4>（1）启动类相关注解</h4>\n<ul>\n  <li><strong>@SpringBootApplication</strong>：这是一个组合注解，包含了<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>。<code>@SpringBootConfiguration</code>表示这是一个Spring Boot的配置类；<code>@EnableAutoConfiguration</code>开启Spring Boot的自动配置功能；<code>@ComponentScan</code>用于扫描指定包下的组件。通常用于Spring Boot应用的主类上。</li>\n</ul>\n<h4>（2）依赖注入相关注解</h4>\n<ul>\n  <li><strong>@Autowired</strong>：Spring框架提供的注解，用于自动装配依赖的Bean。可以作用在构造函数、字段、方法上。</li>\n  <li><strong>@Qualifier</strong>：当有多个相同类型的Bean时，使用<code>@Qualifier</code>指定要注入的Bean的名称。</li>\n  <li><strong>@Resource</strong>：Java提供的注解，也用于依赖注入，可通过<code>name</code>属性指定要注入的Bean的名称。</li>\n</ul>\n<h4>（3）组件定义相关注解</h4>\n<ul>\n  <li><strong>@Component</strong>：通用的组件注解，用于将一个类标识为Spring的组件，让Spring自动扫描并创建Bean。</li>\n  <li><strong>@Service</strong>：通常用于标识业务逻辑层的类，是<code>@Component</code>的特殊化。</li>\n  <li><strong>@Repository</strong>：用于标识数据访问层的类，同样是<code>@Component</code>的特殊化，还能将特定的异常转换为Spring的持久化异常。</li>\n  <li><strong>@Controller</strong>：用于标识控制器层的类，也是<code>@Component</code>的特殊化，结合Spring MVC使用。</li>\n</ul>\n<h4>（4）配置类相关注解</h4>\n<ul>\n  <li><strong>@Configuration</strong>：用于定义配置类，相当于传统的XML配置文件。配置类中可以使用<code>@Bean</code>注解定义Bean。</li>\n  <li><strong>@Bean</strong>：用于在配置类中定义Bean，方法的返回值会被注册为Spring容器中的Bean。</li>\n</ul>\n<h4>（5）请求映射相关注解（Spring MVC部分）</h4>\n<ul>\n  <li><strong>@RequestMapping</strong>：用于映射HTTP请求到控制器的处理方法，可以指定请求的路径、请求方法等。</li>\n  <li><strong>@GetMapping</strong>：<code>@RequestMapping(method = RequestMethod.GET)</code>的快捷方式，用于处理HTTP GET请求。</li>\n  <li><strong>@PostMapping</strong>：<code>@RequestMapping(method = RequestMethod.POST)</code>的快捷方式，用于处理HTTP POST请求。</li>\n</ul>\n<h4>（6）属性注入相关注解</h4>\n<ul>\n  <li><strong>@Value</strong>：用于从配置文件中读取属性值并注入到字段中。</li>\n  <li><strong>@ConfigurationProperties</strong>：用于将配置文件中的属性批量绑定到一个Java类中。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n// 启动类\n@SpringBootApplication\npublic class SpringBootApp implements CommandLineRunner {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootApp.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        System.out.println(\"Spring Boot application started.\");\n    }\n}\n\n// 服务类\n@Service\nclass MyService {\n    public String doSomething() {\n        return \"Service is working.\";\n    }\n}\n\n// 配置类\n@Configuration\nclass AppConfig {\n    @Bean\n    public String myBean() {\n        return \"This is a bean.\";\n    }\n}\n\n// 控制器类\n@RestController\nclass MyController {\n\n    @Autowired\n    private MyService myService;\n\n    @GetMapping(\"/test\")\n    public String test() {\n        return myService.doSomething();\n    }\n}\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆注解功能</h4>\n<ul>\n  <li>误区：将不同功能的注解混用，比如将请求映射注解用于服务类。</li>\n  <li>纠正：明确每个注解的功能和使用场景，根据实际需求选择合适的注解。</li>\n</ul>\n<h4>（2）忽略注解的参数</h4>\n<ul>\n  <li>误区：使用注解时不关注注解的参数，导致无法实现预期的功能。</li>\n  <li>纠正：仔细阅读注解的文档，了解注解的参数含义和使用方法。</li>\n</ul>\n<h4>（3）过度依赖注解</h4>\n<ul>\n  <li>误区：认为所有功能都可以通过注解实现，忽略了XML配置和Java代码的灵活性。</li>\n  <li>纠正：根据项目的实际情况，合理选择注解、XML配置和Java代码来实现功能。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>Spring Boot常用的注解有很多，主要包括以下几类：</p>\n<ul>\n  <li>启动类相关：<code>@SpringBootApplication</code>，用于开启Spring Boot应用的自动配置、组件扫描等功能。</li>\n  <li>依赖注入相关：<code>@Autowired</code>、<code>@Qualifier</code>、<code>@Resource</code>，用于自动装配依赖的Bean。</li>\n  <li>组件定义相关：<code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>，用于标识不同层次的组件。</li>\n  <li>配置类相关：<code>@Configuration</code>、<code>@Bean</code>，用于定义配置类和Bean。</li>\n  <li>请求映射相关：<code>@RequestMapping</code>、<code>@GetMapping</code>、<code>@PostMapping</code>，用于映射HTTP请求到控制器的处理方法。</li>\n  <li>属性注入相关：<code>@Value</code>、<code>@ConfigurationProperties</code>，用于从配置文件中读取属性值。</li>\n</ul>\n<p>在使用这些注解时，要明确其功能和使用场景，避免混淆和错误使用。同时，要根据项目的实际情况，合理选择注解来实现功能。</p>",
    "more_ask": "<ol>\n  <li>\n    <p>\n      <code>@SpringBootApplication</code> 注解的原理是什么，它内部组合了哪些注解？\n      提示：从源码角度分析，查看该注解的定义，了解其内部引用的其他注解及其作用。\n    </p>\n  </li>\n  <li>\n    <p>\n      <code>@Value</code> 注解在注入配置值时，如果配置文件中没有对应的值会怎样，如何设置默认值？\n      提示：可以通过实际代码测试不同情况，查看 <code>@Value</code> 注解的处理逻辑，思考默认值的设置方式。\n    </p>\n  </li>\n  <li>\n    <p>\n      <code>@ComponentScan</code> 注解的扫描规则是怎样的，如何自定义扫描路径和排除某些类？\n      提示：参考官方文档关于 <code>@ComponentScan</code> 的说明，研究其属性的使用方法来实现自定义。\n    </p>\n  </li>\n  <li>\n    <p>\n      <code>@RestController</code> 注解和 <code>@Controller</code> 注解有什么区别，在什么场景下使用 <code>@RestController</code>？\n      提示：从返回值的处理方式、注解的功能等方面对比两者，结合实际业务场景思考使用场景。\n    </p>\n  </li>\n  <li>\n    <p>\n      <code>@Async</code> 注解实现异步方法调用的原理是什么，使用时需要注意什么？\n      提示：了解 Spring 的线程池机制，思考异步方法调用时的线程管理和异常处理等问题。\n    </p>\n  </li>\n  <li>\n    <p>\n      <code>@Transactional</code> 注解的传播行为有哪些，分别在什么场景下使用？\n      提示：查阅文档了解不同传播行为的定义，结合实际业务中事务的处理需求来分析使用场景。\n    </p>\n  </li>\n  <li>\n    <p>\n      <code>@Conditional</code> 注解及其衍生注解（如 <code>@ConditionalOnBean</code> 等）的作用是什么，如何自定义条件注解？\n      提示：理解条件注解的核心思想是根据条件来决定是否加载 Bean，通过查看源码学习自定义条件注解的实现方式。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Spring Boot常用注解))\n    项目启动类相关注解\n      @SpringBootApplication\n        @SpringBootConfiguration\n        @EnableAutoConfiguration\n        @ComponentScan\n    依赖注入相关注解\n      @Autowired\n      @Qualifier\n      @Resource\n    组件定义相关注解\n      @Component\n      @Service\n      @Repository\n      @Controller\n    配置相关注解\n      @Configuration\n      @Bean\n      @PropertySource\n      @Value\n    切面编程相关注解\n      @Aspect\n      @Before\n      @After\n      @Around\n      @AfterReturning\n      @AfterThrowing\n    Web开发相关注解\n      @RestController\n      @RequestMapping\n      @GetMapping\n      @PostMapping\n      @PutMapping\n      @DeleteMapping\n      @RequestBody\n      @PathVariable\n      @RequestParam",
    "keynote": "项目启动类相关注解：@SpringBootApplication（组合注解，含@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan）\n依赖注入相关注解：@Autowired（自动装配Bean）、@Qualifier（与@Autowired配合指定Bean名称）、@Resource（按名称或类型注入）\n组件定义相关注解：@Component（通用组件注解）、@Service（标记业务逻辑层）、@Repository（标记数据访问层）、@Controller（标记控制器类）\n配置相关注解：@Configuration（定义配置类）、@Bean（在配置类中定义Bean）、@PropertySource（加载外部属性文件）、@Value（从配置文件获取属性值注入字段）\n切面编程相关注解：@Aspect（标记切面类）、@Before等（定义不同类型通知）\nWeb开发相关注解：@RestController（创建RESTful控制器）、@RequestMapping（映射HTTP请求）、@GetMapping等（简化@RequestMapping）、@RequestBody（绑定请求主体）、@PathVariable（获取URL路径变量）、@RequestParam（获取请求参数）",
    "group_id": 7,
    "kps": [
      "核心注解"
    ],
    "years": [
      2025,
      2024,
      2023,
      2022
    ],
    "corps": [
      "搜狐畅游",
      "卓望",
      "百度",
      "中航信",
      "趣链科技",
      "恒生电子",
      "上海电气",
      "数字马力",
      "万达信息",
      "海康威视",
      "中国人寿",
      "天津java小公司",
      "数字政通",
      "中国联通",
      "中兴通讯",
      "cvte视源",
      "阳光电源",
      "快手",
      "小米",
      "Wind万得",
      "中国移动",
      "华为",
      "北京亚信",
      "欢聚集团",
      "小红书",
      "货拉拉",
      "经纬恒润",
      "数蓬科技",
      "杭州银行",
      "泰豪软件",
      "美团",
      "京东",
      "网易",
      "科大讯飞",
      "联想集团",
      "滴滴",
      "招银网络科技",
      "奇安信",
      "用友",
      "4399",
      "网易有道",
      "微众银行",
      "浩鲸科技（济南）",
      "中科闻歌（北京）",
      "星环科技",
      "游卡",
      "闪送科技",
      "中国工商银行",
      "好未来"
    ]
  }
}