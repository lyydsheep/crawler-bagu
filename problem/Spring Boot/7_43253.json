{
  "success": true,
  "data": {
    "id": 43253,
    "name": "<p>请说明 AOP，以及拦截器的实现方式，拦截器和过滤器的区别</p>",
    "options": null,
    "answer": "<h3>AOP</h3>\n<p>AOP 即面向切面编程，是一种编程范式，它是对面向对象编程（OOP）的一种补充。在 OOP 中，主要的关注点是类和对象，通过封装、继承和多态来组织代码。而 AOP 则是将那些与业务逻辑无关，但却被多个业务模块所共同调用的逻辑或责任（如日志记录、事务管理、权限验证等）提取出来，封装成一个可重用的模块，这个模块被称为切面（Aspect）。</p>\n<p>AOP 的核心概念包括：</p>\n<ul>\n  <li><strong>切面（Aspect）</strong>：一个切面可以包含多个通知和切点，它是通知和切点的结合。</li>\n  <li><strong>通知（Advice）</strong>：定义了在目标方法执行前后、抛出异常时等不同时机要执行的代码，常见的通知类型有前置通知（Before Advice）、后置通知（After Advice）、返回通知（After Returning Advice）、异常通知（After Throwing Advice）和环绕通知（Around Advice）。</li>\n  <li><strong>切点（Pointcut）</strong>：用于定义哪些方法会被增强，即确定哪些方法会被织入切面的逻辑。</li>\n  <li><strong>连接点（Join Point）</strong>：程序执行过程中能够插入切面的点，例如方法调用、异常抛出等。</li>\n  <li><strong>织入（Weaving）</strong>：将切面应用到目标对象并创建出代理对象的过程。</li>\n</ul>\n<p>在 Spring Boot 中，通常使用 AspectJ 注解来实现 AOP，示例代码如下：</p>\n<pre><code class=\"language-java\">import org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class LoggingAspect {\n\n    @Pointcut(\"execution(* com.example.demo.service.*.*(..))\")\n    public void serviceMethods() {}\n\n    @Before(\"serviceMethods()\")\n    public void beforeAdvice(JoinPoint joinPoint) {\n        System.out.println(\"Before method: \" + joinPoint.getSignature().getName());\n    }\n\n    @After(\"serviceMethods()\")\n    public void afterAdvice(JoinPoint joinPoint) {\n        System.out.println(\"After method: \" + joinPoint.getSignature().getName());\n    }\n}\n</code></pre>\n<h3>拦截器的实现方式</h3>\n<p>在 Spring Boot 中，拦截器通常通过实现 <code>HandlerInterceptor</code> 接口或继承 <code>HandlerInterceptorAdapter</code> 类（Spring 5.3 及以后版本已弃用）来实现。以下是具体步骤：</p>\n<ol>\n  <li><strong>创建拦截器类</strong>：实现 <code>HandlerInterceptor</code> 接口，并重写其中的方法。</li>\n</ol>\n<pre><code class=\"language-java\">import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.web.servlet.HandlerInterceptor;\n\npublic class MyInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        System.out.println(\"Pre-handle method is called\");\n        // 返回 true 表示继续执行请求处理链，返回 false 则中断请求处理链\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, org.springframework.web.servlet.ModelAndView modelAndView) throws Exception {\n        System.out.println(\"Post-handle method is called\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        System.out.println(\"After-completion method is called\");\n    }\n}\n</code></pre>\n<ol start=\"2\">\n  <li><strong>注册拦截器</strong>：创建一个配置类，实现 <code>WebMvcConfigurer</code> 接口，并重写 <code>addInterceptors</code> 方法。</li>\n</ol>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new MyInterceptor())\n               .addPathPatterns(\"/**\") // 拦截所有请求\n               .excludePathPatterns(\"/login\"); // 排除登录请求\n    }\n}\n</code></pre>\n<h3>拦截器和过滤器的区别</h3>\n<ul>\n  <li><strong>应用范围</strong>\n    <ul>\n      <li><strong>过滤器</strong>：是 Servlet 规范中的一部分，它可以对所有进入 Servlet 容器的请求进行过滤，包括静态资源请求。</li>\n      <li><strong>拦截器</strong>：是 Spring 框架中的一部分，它只能对 Spring MVC 框架处理的请求进行拦截，无法拦截静态资源请求。</li>\n    </ul>\n  </li>\n  <li><strong>实现机制</strong>\n    <ul>\n      <li><strong>过滤器</strong>：基于函数回调，通过 <code>doFilter</code> 方法对请求和响应进行过滤。</li>\n      <li><strong>拦截器</strong>：基于 Java 的反射机制，通过 <code>HandlerInterceptor</code> 接口的方法对请求进行拦截。</li>\n    </ul>\n  </li>\n  <li><strong>使用场景</strong>\n    <ul>\n      <li><strong>过滤器</strong>：主要用于对请求进行预处理，如字符编码过滤、敏感词汇过滤等。</li>\n      <li><strong>拦截器</strong>：主要用于对请求进行业务逻辑处理，如权限验证、日志记录等。</li>\n    </ul>\n  </li>\n  <li><strong>执行顺序</strong>\n    <ul>\n      <li><strong>过滤器</strong>：在请求进入 Servlet 容器后，在 Servlet 之前执行。</li>\n      <li><strong>拦截器</strong>：在请求进入 Spring MVC 框架后，在控制器方法执行前后执行。</li>\n    </ul>\n  </li>\n  <li><strong>依赖注入</strong>\n    <ul>\n      <li><strong>过滤器</strong>：由于过滤器是 Servlet 规范的一部分，它无法使用 Spring 的依赖注入。</li>\n      <li><strong>拦截器</strong>：可以使用 Spring 的依赖注入，方便与 Spring 框架集成。</li>\n    </ul>\n  </li>\n</ul>",
    "type": 6,
    "level": 2,
    "freq": 0.001335114,
    "analysis": "<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：说明AOP、拦截器的实现方式以及拦截器和过滤器的区别。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对AOP概念的理解。</li>\n      <li>拦截器的实现方法。</li>\n      <li>拦截器和过滤器在功能、使用场景、执行顺序等方面的差异。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）AOP（面向切面编程）</h4>\n<ul>\n  <li>AOP是一种编程范式，它允许开发者在不修改原有业务逻辑的基础上，对程序进行增强。通过将横切关注点（如日志记录、事务管理等）与核心业务逻辑分离，提高代码的可维护性和可复用性。</li>\n</ul>\n<h4>（2）拦截器</h4>\n<ul>\n  <li>拦截器是Spring框架提供的一种机制，用于在请求处理的前后进行额外的处理，如权限验证、日志记录等。</li>\n</ul>\n<h4>（3）过滤器</h4>\n<ul>\n  <li>过滤器是Servlet规范中的一部分，用于对请求和响应进行预处理和后处理，如字符编码转换、请求过滤等。</li>\n</ul>\n<h3>3. 解析</h3>\n<h4>（1）AOP</h4>\n<ul>\n  <li><strong>原理</strong>：AOP的实现基于代理模式，Spring AOP使用JDK动态代理和CGLIB代理来创建代理对象。在运行时，代理对象会拦截目标方法的调用，并在方法前后插入额外的逻辑。</li>\n  <li><strong>使用场景</strong>：日志记录、事务管理、权限验证、性能监控等。</li>\n  <li><strong>实现步骤</strong>：\n    <ul>\n      <li>定义切面类，使用<code>@Aspect</code>注解标记。</li>\n      <li>定义切入点，使用<code>@Pointcut</code>注解指定要拦截的方法。</li>\n      <li>定义通知，使用<code>@Before</code>、<code>@After</code>、<code>@Around</code>等注解在切入点前后执行额外的逻辑。</li>\n    </ul>\n  </li>\n</ul>\n<h4>（2）拦截器的实现方式</h4>\n<ul>\n  <li><strong>实现<code>HandlerInterceptor</code>接口</strong>：\n    <ul>\n      <li><code>preHandle</code>方法：在请求处理之前执行，返回<code>true</code>表示继续执行后续的拦截器和处理器，返回<code>false</code>表示中断请求处理。</li>\n      <li><code>postHandle</code>方法：在请求处理之后、视图渲染之前执行。</li>\n      <li><code>afterCompletion</code>方法：在整个请求处理完成后执行，通常用于资源清理。</li>\n    </ul>\n  </li>\n  <li><strong>注册拦截器</strong>：实现<code>WebMvcConfigurer</code>接口，重写<code>addInterceptors</code>方法，将拦截器注册到<code>InterceptorRegistry</code>中。</li>\n</ul>\n<h4>（3）拦截器和过滤器的区别</h4>\n<ul>\n  <li><strong>功能层面</strong>：\n    <ul>\n      <li>过滤器主要用于对请求和响应进行预处理和后处理，如字符编码转换、请求过滤等，更侧重于对请求和响应的内容进行处理。</li>\n      <li>拦截器主要用于在请求处理的前后进行额外的处理，如权限验证、日志记录等，更侧重于对请求的业务逻辑进行增强。</li>\n    </ul>\n  </li>\n  <li><strong>使用场景层面</strong>：\n    <ul>\n      <li>过滤器适用于对所有请求进行统一处理的场景，如字符编码转换、请求过滤等。</li>\n      <li>拦截器适用于对特定请求进行处理的场景，如权限验证、日志记录等。</li>\n    </ul>\n  </li>\n  <li><strong>执行顺序层面</strong>：\n    <ul>\n      <li>过滤器在请求进入Servlet容器时就会被执行，在拦截器之前。</li>\n      <li>拦截器在请求进入Spring MVC框架后才会被执行，在过滤器之后。</li>\n    </ul>\n  </li>\n  <li><strong>实现层面</strong>：\n    <ul>\n      <li>过滤器是Servlet规范中的一部分，需要实现<code>Filter</code>接口。</li>\n      <li>拦截器是Spring框架提供的一种机制，需要实现<code>HandlerInterceptor</code>接口。</li>\n    </ul>\n  </li>\n</ul>\n<h3>4. 示例代码</h3>\n<h4>（1）AOP示例</h4>\n<pre><code class=\"language-java\">import org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class LoggingAspect {\n\n    @Pointcut(\"execution(* com.example.demo.service.*.*(..))\")\n    public void serviceMethods() {}\n\n    @Before(\"serviceMethods()\")\n    public void beforeServiceMethod(JoinPoint joinPoint) {\n        System.out.println(\"Before method: \" + joinPoint.getSignature().getName());\n    }\n\n    @After(\"serviceMethods()\")\n    public void afterServiceMethod(JoinPoint joinPoint) {\n        System.out.println(\"After method: \" + joinPoint.getSignature().getName());\n    }\n}\n</code></pre>\n<h4>（2）拦截器示例</h4>\n<pre><code class=\"language-java\">import org.springframework.stereotype.Component;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@Component\npublic class MyInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        System.out.println(\"Pre-handle request\");\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, org.springframework.web.servlet.ModelAndView modelAndView) throws Exception {\n        System.out.println(\"Post-handle request\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        System.out.println(\"After completion\");\n    }\n}\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\");\n    }\n}\n</code></pre>\n<h3>5. 常见误区</h3>\n<h4>（1）混淆AOP和拦截器的概念</h4>\n<ul>\n  <li>误区：认为AOP和拦截器的功能相同，没有区分它们的使用场景。</li>\n  <li>纠正：AOP更侧重于对横切关注点的处理，而拦截器更侧重于对请求的业务逻辑进行增强。</li>\n</ul>\n<h4>（2）不清楚拦截器和过滤器的区别</h4>\n<ul>\n  <li>误区：认为拦截器和过滤器的功能和使用场景相同。</li>\n  <li>纠正：拦截器和过滤器在功能、使用场景、执行顺序和实现方式等方面都存在差异。</li>\n</ul>\n<h4>（3）忽略拦截器和过滤器的执行顺序</h4>\n<ul>\n  <li>误区：在编写代码时，没有考虑拦截器和过滤器的执行顺序，导致逻辑错误。</li>\n  <li>纠正：过滤器在请求进入Servlet容器时就会被执行，在拦截器之前；拦截器在请求进入Spring MVC框架后才会被执行，在过滤器之后。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“AOP即面向切面编程，是一种编程范式，它允许开发者在不修改原有业务逻辑的基础上，对程序进行增强。通过将横切关注点（如日志记录、事务管理等）与核心业务逻辑分离，提高代码的可维护性和可复用性。Spring AOP基于代理模式，使用JDK动态代理和CGLIB代理来创建代理对象，在运行时拦截目标方法的调用，并插入额外的逻辑。</p>\n<p>拦截器是Spring框架提供的一种机制，用于在请求处理的前后进行额外的处理。实现拦截器需要实现<code>HandlerInterceptor</code>接口，重写<code>preHandle</code>、<code>postHandle</code>和<code>afterCompletion</code>方法，并通过实现<code>WebMvcConfigurer</code>接口的<code>addInterceptors</code>方法将拦截器注册到<code>InterceptorRegistry</code>中。</p>\n<p>拦截器和过滤器存在以下区别：</p>\n<ul>\n  <li>功能上，过滤器主要用于对请求和响应进行预处理和后处理，如字符编码转换、请求过滤等；拦截器主要用于在请求处理的前后进行额外的处理，如权限验证、日志记录等。</li>\n  <li>使用场景上，过滤器适用于对所有请求进行统一处理的场景；拦截器适用于对特定请求进行处理的场景。</li>\n  <li>执行顺序上，过滤器在请求进入Servlet容器时就会被执行，在拦截器之前；拦截器在请求进入Spring MVC框架后才会被执行，在过滤器之后。</li>\n  <li>实现上，过滤器是Servlet规范中的一部分，需要实现<code>Filter</code>接口；拦截器是Spring框架提供的一种机制，需要实现<code>HandlerInterceptor</code>接口。”</li>\n</ul>",
    "more_ask": "<h3>AOP 相关</h3>\n<ol>\n  <li>\n    <p>\n      <strong>AOP 的底层实现原理中，JDK 动态代理和 CGLIB 代理的具体使用场景是什么？</strong>\n      提示：从目标对象是否实现接口、性能等方面去考虑不同场景。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在 Spring AOP 里，如何处理切面中的异常，有哪些方式？</strong>\n      提示：可以从增强类型（如 @AfterThrowing）以及全局异常处理等角度思考。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>请说明 AOP 中切入点表达式的多种写法及适用场景。</strong>\n      提示：像 execution、within、@annotation 等表达式，结合不同的业务场景分析。\n    </p>\n  </li>\n</ol>\n<h3>拦截器实现方式相关</h3>\n<ol>\n  <li>\n    <p>\n      <strong>在 Spring Boot 拦截器中，如何实现拦截器的顺序控制，有哪些方法？</strong>\n      提示：可以从配置类、实现 Ordered 接口等方面考虑。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>拦截器中 preHandle 方法返回 false 时，后续的拦截器和请求处理流程会怎样？</strong>\n      提示：思考对后续拦截器的 preHandle 方法、请求处理方法以及 postHandle、afterCompletion 方法的影响。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>如果要在拦截器中获取请求的参数，有哪些方式？</strong>\n      提示：可以从 HttpServletRequest 对象的方法、请求体读取等方面去想。\n    </p>\n  </li>\n</ol>\n<h3>拦截器和过滤器区别相关</h3>\n<ol>\n  <li>\n    <p>\n      <strong>在性能方面，拦截器和过滤器哪个更优，为什么？</strong>\n      提示：从执行时机、底层实现、资源消耗等方面对比分析。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>当需要对请求进行字符编码处理时，使用拦截器还是过滤器更合适，为什么？</strong>\n      提示：结合两者的执行顺序、功能特点来判断。\n    </p>\n  </li>\n  <li>\n    <p>\n      <strong>在一个复杂的 Web 项目中，如何合理地搭配使用拦截器和过滤器？</strong>\n      提示：根据不同的功能需求，如权限验证、日志记录、字符编码处理等分配两者的任务。\n    </p>\n  </li>\n</ol>",
    "mindmap": "mindmap\n  root((Spring相关技术))\n    AOP\n      定义\n        面向切面编程，是对OOP的补充\n        提取与业务逻辑无关的共同调用逻辑封装成切面\n      核心概念\n        切面（Aspect）\n        通知（Advice）\n          前置通知（Before Advice）\n          后置通知（After Advice）\n          返回通知（After Returning Advice）\n          异常通知（After Throwing Advice）\n          环绕通知（Around Advice）\n        切点（Pointcut）\n        连接点（Join Point）\n        织入（Weaving）\n      Spring Boot实现\n        使用AspectJ注解\n    拦截器的实现方式\n      创建拦截器类\n        实现HandlerInterceptor接口\n      注册拦截器\n        实现WebMvcConfigurer接口，重写addInterceptors方法\n    拦截器和过滤器的区别\n      应用范围\n        过滤器：Servlet规范，可过滤所有进入Servlet容器请求\n        拦截器：Spring框架，只能拦截Spring MVC请求\n      实现机制\n        过滤器：基于函数回调\n        拦截器：基于Java反射机制\n      使用场景\n        过滤器：请求预处理\n        拦截器：请求业务逻辑处理\n      执行顺序\n        过滤器：请求进入Servlet容器后，Servlet之前\n        拦截器：请求进入Spring MVC框架后，控制器方法前后\n      依赖注入\n        过滤器：无法使用Spring依赖注入\n        拦截器：可使用Spring依赖注入",
    "keynote": "AOP：面向切面编程，补充OOP，提取共同逻辑封装成切面；核心概念有切面、通知、切点、连接点、织入；Spring Boot用AspectJ注解实现\n拦截器实现：创建类实现HandlerInterceptor接口，配置类实现WebMvcConfigurer接口重写addInterceptors方法注册\n拦截器和过滤器区别：应用范围、实现机制、使用场景、执行顺序、依赖注入方面不同",
    "group_id": 7,
    "kps": [
      "基础知识",
      "核心注解"
    ],
    "years": [
      2022
    ],
    "corps": [
      "同花顺"
    ]
  }
}