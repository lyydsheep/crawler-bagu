{"success":true,"data":{"id":50423,"name":"<p>Spring Boot如何解决循环依赖问题？</p>","options":null,"answer":"<p>在Spring Boot中，循环依赖指的是两个或多个Bean之间相互依赖，形成一个闭环。Spring Boot基于Spring框架，主要通过三级缓存机制来解决循环依赖问题。下面详细介绍相关原理和机制。</p>\n<h3>三级缓存</h3>\n<p>Spring容器内部维护了三个缓存，用于存储不同状态的Bean实例，它们分别是：</p>\n<ol>\n  <li><strong>singletonObjects（一级缓存）</strong>：用于存储已经完全初始化好的单例Bean实例，这些Bean可以直接被使用。</li>\n  <li><strong>singletonFactories（二级缓存）</strong>：存储的是创建Bean的工厂对象，当需要解决循环依赖时，可以通过这些工厂对象提前获取到一个早期的Bean引用。</li>\n  <li><strong>earlySingletonObjects（三级缓存）</strong>：存储的是提前曝光的早期Bean实例，这些Bean还没有完成属性注入和初始化操作。</li>\n</ol>\n<h3>解决循环依赖的流程</h3>\n<p>下面以两个相互依赖的Bean（A和B）为例，详细说明Spring Boot解决循环依赖的具体流程：</p>\n<ol>\n  <li><strong>创建Bean A</strong>\n    <ul>\n      <li>Spring容器开始创建Bean A，首先将A对应的ObjectFactory添加到singletonFactories（二级缓存）中，此时A处于正在创建的状态。</li>\n      <li>接着在对A进行属性注入时，发现需要依赖Bean B。</li>\n    </ul>\n  </li>\n  <li><strong>创建Bean B</strong>\n    <ul>\n      <li>由于Bean B还未创建，Spring容器开始创建Bean B，同样将B对应的ObjectFactory添加到singletonFactories（二级缓存）中。</li>\n      <li>在对B进行属性注入时，发现需要依赖Bean A。</li>\n    </ul>\n  </li>\n  <li><strong>解决B对A的依赖</strong>\n    <ul>\n      <li>此时Spring容器会先从singletonObjects（一级缓存）中查找Bean A，发现没有找到。</li>\n      <li>接着从earlySingletonObjects（三级缓存）中查找，也没有找到。</li>\n      <li>最后从singletonFactories（二级缓存）中找到A对应的ObjectFactory，通过调用其getObject()方法获取到A的早期引用，并将A的早期引用从singletonFactories（二级缓存）移除，添加到earlySingletonObjects（三级缓存）中。</li>\n      <li>将A的早期引用注入到B中，完成B的属性注入和初始化操作，然后将B添加到singletonObjects（一级缓存）中。</li>\n    </ul>\n  </li>\n  <li><strong>完成A的创建</strong>\n    <ul>\n      <li>由于B已经创建完成，将B注入到A中，完成A的属性注入和初始化操作，最后将A添加到singletonObjects（一级缓存）中。</li>\n    </ul>\n  </li>\n</ol>\n<h3>代码示例</h3>\n<p>以下是一个简单的代码示例，展示了两个相互依赖的Bean：</p>\n<pre><code class=\"language-java\">import org.springframework.stereotype.Component;\n\n@Component\npublic class A {\n    private B b;\n\n    public A(B b) {\n        this.b = b;\n    }\n\n    public B getB() {\n        return b;\n    }\n}\n\n@Component\npublic class B {\n    private A a;\n\n    public B(A a) {\n        this.a = a;\n    }\n\n    public A getA() {\n        return a;\n    }\n}\n</code></pre>\n<p>在上述代码中，Bean A依赖于Bean B，Bean B又依赖于Bean A，形成了循环依赖。但由于Spring Boot的三级缓存机制，这种循环依赖可以被正常解决。</p>\n<h3>注意事项</h3>\n<ul>\n  <li>三级缓存机制只能解决单例Bean的循环依赖问题，对于原型（prototype）作用域的Bean，Spring无法解决其循环依赖问题，因为原型作用域的Bean每次请求都会创建一个新的实例，无法使用缓存来提前曝光早期引用。</li>\n  <li>构造器注入无法解决循环依赖问题，因为构造器注入是在Bean实例化时就需要完成依赖注入，而此时Bean还没有被添加到缓存中，无法提供早期引用。只有通过setter方法或字段注入才能利用三级缓存机制解决循环依赖。</li>\n</ul>","type":6,"level":2,"freq":0.009345794,"analysis":"<h3>1. 题目核心</h3>\n<ul>\n  <li><strong>问题</strong>：Spring Boot如何解决循环依赖问题。</li>\n  <li><strong>考察点</strong>：\n    <ul>\n      <li>对Spring Boot依赖注入机制的理解。</li>\n      <li>对循环依赖概念的掌握。</li>\n      <li>Spring Boot解决循环依赖的具体原理和方式。</li>\n    </ul>\n  </li>\n</ul>\n<h3>2. 背景知识</h3>\n<h4>（1）循环依赖的概念</h4>\n<p>循环依赖指的是多个Bean之间相互依赖，形成一个闭环。例如，Bean A依赖于Bean B，而Bean B又依赖于Bean A。在传统的依赖注入过程中，这种情况可能会导致无限循环，无法完成Bean的创建。</p>\n<h4>（2）Spring Boot的依赖注入机制</h4>\n<p>Spring Boot基于Spring框架，采用依赖注入（DI）来管理Bean之间的依赖关系。在创建Bean的过程中，Spring会根据配置信息将依赖的Bean注入到目标Bean中。</p>\n<h3>3. 解析</h3>\n<h4>（1）三级缓存机制</h4>\n<p>Spring Boot主要通过三级缓存来解决循环依赖问题。这三级缓存分别是：</p>\n<ul>\n  <li><strong>singletonObjects</strong>：单例对象缓存，存储已经完全创建好的单例Bean。</li>\n  <li><strong>singletonFactories</strong>：单例工厂缓存，存储创建单例Bean的工厂对象。</li>\n  <li><strong>earlySingletonObjects</strong>：早期单例对象缓存，存储提前暴露的单例Bean，这些Bean还未完全初始化。</li>\n</ul>\n<h4>（2）解决循环依赖的过程</h4>\n<p>假设存在Bean A和Bean B相互依赖的情况：</p>\n<ul>\n  <li><strong>创建Bean A</strong>：\n    <ul>\n      <li>Spring开始创建Bean A，首先将一个创建Bean A的工厂对象放入<code>singletonFactories</code>中。</li>\n      <li>然后开始填充Bean A的属性，发现需要注入Bean B。</li>\n    </ul>\n  </li>\n  <li><strong>创建Bean B</strong>：\n    <ul>\n      <li>Spring开始创建Bean B，同样将创建Bean B的工厂对象放入<code>singletonFactories</code>中。</li>\n      <li>填充Bean B的属性时，发现需要注入Bean A。</li>\n      <li>此时，Spring会从<code>singletonFactories</code>中查找是否有创建Bean A的工厂对象，如果有，则通过该工厂对象获取一个早期的Bean A实例，并将其放入<code>earlySingletonObjects</code>中，同时从<code>singletonFactories</code>中移除该工厂对象。</li>\n      <li>将这个早期的Bean A实例注入到Bean B中，完成Bean B的创建，并将其放入<code>singletonObjects</code>中。</li>\n    </ul>\n  </li>\n  <li><strong>完成Bean A的创建</strong>：\n    <ul>\n      <li>由于Bean B已经创建完成，将其注入到Bean A中，完成Bean A的创建，并将其放入<code>singletonObjects</code>中。</li>\n    </ul>\n  </li>\n</ul>\n<h4>（3）注意事项</h4>\n<ul>\n  <li>这种解决方式只适用于单例Bean的循环依赖，对于原型（prototype）Bean的循环依赖，Spring无法解决，会抛出<code>BeanCurrentlyInCreationException</code>异常。</li>\n  <li>对于构造器注入的循环依赖，Spring也无法解决，因为在调用构造器时就需要依赖的Bean，而此时还没有将创建Bean的工厂对象放入<code>singletonFactories</code>中。</li>\n</ul>\n<h3>4. 示例代码</h3>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class BeanA {\n    @Autowired\n    private BeanB beanB;\n\n    public BeanA() {}\n\n    public BeanB getBeanB() {\n        return beanB;\n    }\n}\n\n@Component\npublic class BeanB {\n    @Autowired\n    private BeanA beanA;\n\n    public BeanB() {}\n\n    public BeanA getBeanA() {\n        return beanA;\n    }\n}\n</code></pre>\n<p>在这个例子中，<code>BeanA</code>和<code>BeanB</code>相互依赖，Spring Boot会通过三级缓存机制解决它们之间的循环依赖问题。</p>\n<h3>5. 常见误区</h3>\n<h4>（1）认为Spring Boot能解决所有循环依赖问题</h4>\n<ul>\n  <li>误区：认为Spring Boot可以解决所有类型的循环依赖，包括原型Bean和构造器注入的循环依赖。</li>\n  <li>纠正：Spring Boot的三级缓存机制只适用于单例Bean的属性注入循环依赖，对于原型Bean和构造器注入的循环依赖无法解决。</li>\n</ul>\n<h4>（2）忽视三级缓存的作用</h4>\n<ul>\n  <li>误区：只知道Spring Boot能解决循环依赖，但不清楚三级缓存的具体作用和工作原理。</li>\n  <li>纠正：理解三级缓存（<code>singletonObjects</code>、<code>singletonFactories</code>、<code>earlySingletonObjects</code>）在解决循环依赖过程中的作用，以及它们之间的协作关系。</li>\n</ul>\n<h3>6. 总结回答</h3>\n<p>“Spring Boot主要通过三级缓存机制来解决单例Bean的属性注入循环依赖问题。这三级缓存分别是<code>singletonObjects</code>（存储完全创建好的单例Bean）、<code>singletonFactories</code>（存储创建单例Bean的工厂对象）和<code>earlySingletonObjects</code>（存储提前暴露的单例Bean）。</p>\n<p>在创建Bean的过程中，Spring会先将创建Bean的工厂对象放入<code>singletonFactories</code>中。当遇到循环依赖时，会从<code>singletonFactories</code>中获取早期的Bean实例，并将其放入<code>earlySingletonObjects</code>中，完成依赖注入。最后，将完全创建好的Bean放入<code>singletonObjects</code>中。</p>\n<p>需要注意的是，这种解决方式只适用于单例Bean的属性注入循环依赖，对于原型Bean和构造器注入的循环依赖，Spring Boot无法解决。”</p>","more_ask":"<h3>1. Spring Boot 解决循环依赖的三级缓存机制中，每个缓存具体存储的是什么类型的对象？</h3>\n<p>提示：思考三级缓存的名称和作用，分别从早期对象、完整对象等角度去分析每个缓存存储的对象特征。</p>\n<h3>2. 当循环依赖涉及到 AOP 代理时，Spring Boot 解决循环依赖的过程会有什么不同？</h3>\n<p>提示：考虑 AOP 代理对象的创建时机和方式，以及它对对象在三级缓存中流转的影响。</p>\n<h3>3. 能否举例说明在什么情况下 Spring Boot 无法解决循环依赖问题？</h3>\n<p>提示：从对象的创建过程、依赖注入的方式等方面去思考可能导致循环依赖无法解决的场景。</p>\n<h3>4. Spring Boot 解决循环依赖的机制在多线程环境下是否会有问题？如何解决？</h3>\n<p>提示：分析多线程环境下对象创建和缓存操作可能出现的并发问题，思考相应的同步机制。</p>\n<h3>5. 如果手动禁用 Spring Boot 解决循环依赖的功能，会出现什么情况？</h3>\n<p>提示：结合循环依赖的本质和 Spring Boot 解决循环依赖的作用，推测禁用后的结果。</p>\n<h3>6. 在 Spring Boot 中，构造器注入和 setter 注入在处理循环依赖时有什么区别？</h3>\n<p>提示：对比构造器注入和 setter 注入的执行时机，以及它们对对象创建和依赖注入过程的影响。</p>\n<h3>7. Spring Boot 解决循环依赖的机制对系统性能有什么影响？如何优化？</h3>\n<p>提示：从缓存操作、对象创建过程等方面分析对性能的影响，思考减少不必要操作的优化方法。</p>","mindmap":"mindmap\n  root((Spring Boot循环依赖))\n    循环依赖定义\n      两个或多个Bean相互依赖形成闭环\n    解决机制\n      三级缓存\n        singletonObjects（一级缓存）\n          存储完全初始化好的单例Bean实例\n        singletonFactories（二级缓存）\n          存储创建Bean的工厂对象\n        earlySingletonObjects（三级缓存）\n          存储提前曝光的早期Bean实例\n    解决流程\n      创建Bean A\n        添加A的ObjectFactory到二级缓存\n        属性注入时发现依赖B\n      创建Bean B\n        添加B的ObjectFactory到二级缓存\n        属性注入时发现依赖A\n      解决B对A的依赖\n        一级缓存找A，未找到\n        三级缓存找A，未找到\n        二级缓存找A的ObjectFactory获取早期引用\n        早期引用移到三级缓存\n        A早期引用注入B，B完成创建并加入一级缓存\n      完成A的创建\n        B注入A，A完成创建并加入一级缓存\n    注意事项\n      只能解决单例Bean循环依赖\n      构造器注入无法解决循环依赖","keynote":"Spring Boot循环依赖：两个或多个Bean相互依赖成闭环\n解决机制：三级缓存\n  - 一级缓存（singletonObjects）：存完全初始化单例Bean\n  - 二级缓存（singletonFactories）：存创建Bean的工厂对象\n  - 三级缓存（earlySingletonObjects）：存早期Bean实例\n解决流程：\n  1. 创建Bean A：加A的ObjectFactory到二级缓存，属性注入发现依赖B\n  2. 创建Bean B：加B的ObjectFactory到二级缓存，属性注入发现依赖A\n  3. 解决B对A的依赖：一、三级缓存找A无果，二级缓存获取A早期引用，移到三级缓存，注入B，B入一级缓存\n  4. 完成A的创建：B注入A，A入一级缓存\n注意事项：\n  - 仅解决单例Bean循环依赖\n  - 构造器注入无法解决循环依赖","group_id":7,"kps":["基础知识"],"years":[2024,2023,2022],"corps":["陌陌","字节跳动","美团","快手","用友"]}}